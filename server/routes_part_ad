
      res.json({ success: true, message: statusMessage });

    } catch (error: any) {
      console.error('Update user status error:', error);
      res.status(500).json({ success: false, error: "Failed to update user status" });
    }
  });

  // Admin manually update user subscription plan
  app.put("/api/admin/users/:userId/plan", requireAdmin, async (req, res) => {
    try {
      const { userId } = req.params;
      const { subscriptionTier, planExpiry } = req.body;

      // Validate subscription tier
      const allowedTiers = ['elementary', 'high_school', 'college_university', 'free', null];
      if (subscriptionTier !== null && !allowedTiers.includes(subscriptionTier)) {
        return res.status(400).json({ 
          success: false, 
          error: "Invalid subscription tier. Must be elementary, high_school, college_university, free, or null" 
        });
      }

      // First get the UUID for the user
      const user = await db
        .select({ id: users.id })
        .from(users)
        .where(eq(users.userId, userId))
        .limit(1);

      if (user.length === 0) {
        return res.status(404).json({ success: false, error: "User not found" });
      }

      // Prepare update data
      const updateData: any = { 
        updatedAt: new Date() 
      };

      if (subscriptionTier !== undefined) {
        updateData.subscriptionTier = subscriptionTier;
      }

      if (planExpiry !== undefined) {
        updateData.planExpiry = planExpiry ? new Date(planExpiry) : null;
      }

      // Update user profile with new subscription details
      await db
        .update(profiles)
        .set(updateData)
        .where(eq(profiles.userId, user[0].id));

      const tierMessage = subscriptionTier === null || subscriptionTier === 'free' 
        ? 'Plan removed' 
        : `Plan set to ${subscriptionTier}`;

      res.json({ 
        success: true, 
        message: `${tierMessage}${planExpiry ? ` with expiry ${new Date(planExpiry).toLocaleDateString()}` : ''}` 
      });

    } catch (error: any) {
      console.error('Update user plan error:', error);
      res.status(500).json({ success: false, error: "Failed to update user plan" });
    }
  });

  // Admin manually add funds to user wallet
  app.post("/api/admin/users/:userId/add-funds", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { userId } = req.params;
      const { amount, reason } = req.body;

      // Validate amount
      if (!amount || isNaN(parseFloat(amount)) || parseFloat(amount) <= 0) {
        return res.status(400).json({ 
          success: false, 
          error: "Invalid amount. Must be a positive number." 
        });
      }

      // Get user UUID from userId
      const user = await db
        .select({ id: users.id })
        .from(users)
        .where(eq(users.userId, userId))
        .limit(1);

      if (user.length === 0) {
        return res.status(404).json({ success: false, error: "User not found" });
      }

      // Get or create shop customer record
      let customer = await storage.getShopCustomerByUserId(user[0].id);
      
      if (!customer) {
        // Get user profile for basic info
        const profile = await db
          .select()
          .from(profiles)
          .where(eq(profiles.userId, user[0].id))
          .limit(1);

        if (profile.length === 0) {
          return res.status(404).json({ success: false, error: "User profile not found" });
        }

        // Get user email
        const userRecord = await db
          .select({ email: users.email })
          .from(users)
          .where(eq(users.id, user[0].id))
          .limit(1);

        // Create shop customer record if it doesn't exist
        customer = await storage.createShopCustomer({
          userId: user[0].id,
          fullName: profile[0].name,
          email: userRecord[0]?.email || '',
        });
      }

      // Add funds to wallet
      const updatedCustomer = await storage.updateWalletBalance(customer.id, parseFloat(amount));

      // Record the transaction
      await db.insert(shopTransactions).values({
        customerId: customer.id,
        amount: amount.toString(),
        type: 'add_funds',
        description: reason || `Manual fund addition by admin (Cash payment)`,
        status: 'paid',
        referenceId: `admin-manual-${Date.now()}`
      });

      res.json({ 
        success: true, 
        message: `Successfully added $${amount} to user's wallet`,
        newBalance: updatedCustomer.walletBalance
      });

    } catch (error: any) {
      console.error('Admin add funds error:', error);
      res.status(500).json({ success: false, error: "Failed to add funds to user wallet" });
    }
  });

  // Admin impersonate user
  app.post("/api/admin/impersonate", requireAuth, requireAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const { targetUserId } = req.body;
      const adminUser = req.user;

      if (!targetUserId) {
        return res.status(400).json({ success: false, error: "Target user ID is required" });
      }

      // Get the target user and profile
      const targetUser = await db
        .select()
        .from(users)
        .where(eq(users.userId, targetUserId))
        .limit(1);

      if (targetUser.length === 0) {
        return res.status(404).json({ success: false, error: "Target user not found" });
      }

      // Get user's profile to determine role
      const userProfile = await db
        .select()
        .from(profiles)
        .where(eq(profiles.userId, targetUser[0].id))
        .limit(1);

      // Create a new session for the target user
      const newSessionId = uuidv4();
      const expiresAt = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000); // 30 days

      await db.insert(userLoginSessions).values({
        id: uuidv4(),
        userId: targetUser[0].id,
        sessionId: newSessionId,
        ipAddress: req.ip || req.headers['x-forwarded-for'] as string || 'unknown',
        userAgent: req.headers['user-agent'] || 'unknown',
        expiresAt,
        createdAt: new Date()
      });

      res.json({ 
        success: true, 
        sessionId: newSessionId,
        user: {
          id: targetUser[0].id,
          userId: targetUser[0].userId,
          email: targetUser[0].email
        },
        profile: userProfile[0],
        role: userProfile[0]?.role || 'student',
        message: `Successfully logged in as ${targetUserId}`
      });

    } catch (error: any) {
      console.error('Admin impersonate error:', error);
      res.status(500).json({ success: false, error: "Failed to impersonate user" });
    }
  });

  // Advertise page button configuration endpoint
  app.get("/api/admin/system-settings/advertise-buttons", async (req, res) => {
    try {
      const buttonSettings = await db
        .select()
        .from(systemSettings)
        .where(
          or(
            eq(systemSettings.key, 'advertise_contact_button_enabled'),
            eq(systemSettings.key, 'advertise_create_banner_button_enabled')
          )
        );

      const settings = buttonSettings.reduce((acc, setting) => {
        if (setting.key === 'advertise_contact_button_enabled') {
          acc.contactDesignTeamEnabled = setting.value === 'true';
        } else if (setting.key === 'advertise_create_banner_button_enabled') {
          acc.createBannerEnabled = setting.value === 'true';
        }
        return acc;
      }, {} as any);

      // Default to enabled if no settings exist
      if (Object.keys(settings).length === 0) {
        settings.contactDesignTeamEnabled = true;
        settings.createBannerEnabled = true;
      }

      res.json(settings);
    } catch (error: any) {
      console.error('Advertise button settings error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch advertise button settings" });
    }
  });

  app.put("/api/admin/system-settings/advertise-buttons", requireAuth, requireAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const { contactDesignTeamEnabled, createBannerEnabled } = req.body;

      // Update or insert contact button setting
      const contactSetting = await db
        .select()
        .from(systemSettings)
        .where(eq(systemSettings.key, 'advertise_contact_button_enabled'))
        .limit(1);

      if (contactSetting.length > 0) {
        await db
          .update(systemSettings)
          .set({ value: String(contactDesignTeamEnabled), updatedAt: new Date() })
          .where(eq(systemSettings.key, 'advertise_contact_button_enabled'));
      } else {
        await db.insert(systemSettings).values({
          key: 'advertise_contact_button_enabled',
          value: String(contactDesignTeamEnabled),
          type: 'boolean',
          description: 'Enable/disable Contact Design Team button on advertise page',
          category: 'advertise_page'
        });
      }

      // Update or insert create banner button setting
      const bannerSetting = await db
        .select()
        .from(systemSettings)
        .where(eq(systemSettings.key, 'advertise_create_banner_button_enabled'))
        .limit(1);

      if (bannerSetting.length > 0) {
        await db
          .update(systemSettings)
          .set({ value: String(createBannerEnabled), updatedAt: new Date() })
          .where(eq(systemSettings.key, 'advertise_create_banner_button_enabled'));
      } else {
        await db.insert(systemSettings).values({
          key: 'advertise_create_banner_button_enabled',
          value: String(createBannerEnabled),
          type: 'boolean',
          description: 'Enable/disable Create Banner Now button on advertise page',
          category: 'advertise_page'
        });
      }

      res.json({ success: true, message: "Advertise button settings updated successfully" });
    } catch (error: any) {
      console.error('Update advertise button settings error:', error);
      res.status(500).json({ success: false, error: "Failed to update advertise button settings" });
    }
  });

  // ==========================================
  // EcoCash Manual Payment Settings
  // ==========================================
  
  // GET /api/ecocash/manual-payment-settings - Get EcoCash manual payment configuration (public)
  app.get("/api/ecocash/manual-payment-settings", async (req, res) => {
    try {
      const settingKeys = [
        'ecocash_manual_payment_enabled',
        'ecocash_manual_instructions',
        'ecocash_support_whatsapp',
        'ecocash_merchant_number',
        'ecocash_merchant_name'
      ];
      
      const settings = await db.select()
        .from(systemSettings)
        .where(inArray(systemSettings.key, settingKeys));
      
      const result: Record<string, string | boolean> = {
        enabled: false,
        instructions: 'Send payment to our EcoCash merchant number and share your receipt via WhatsApp for verification.',
        whatsappNumber: '',
        merchantNumber: '',
        merchantName: ''
      };
      
      for (const setting of settings) {
        if (setting.key === 'ecocash_manual_payment_enabled') {
          result.enabled = setting.value === 'true';
        } else if (setting.key === 'ecocash_manual_instructions') {
          result.instructions = setting.value || result.instructions;
        } else if (setting.key === 'ecocash_support_whatsapp') {
          result.whatsappNumber = setting.value || '';
        } else if (setting.key === 'ecocash_merchant_number') {
          result.merchantNumber = setting.value || '';
        } else if (setting.key === 'ecocash_merchant_name') {
          result.merchantName = setting.value || '';
        }
      }
      
      res.json({ success: true, data: result });
    } catch (error: any) {
      console.error('Error fetching EcoCash manual payment settings:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch EcoCash manual payment settings' });
    }
  });
  
  // POST /api/admin/ecocash/manual-payment-settings - Update EcoCash manual payment configuration (admin only)
  app.post("/api/admin/ecocash/manual-payment-settings", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { enabled, instructions, whatsappNumber, merchantNumber, merchantName } = req.body;
      
      const settingsToUpdate = [
        { key: 'ecocash_manual_payment_enabled', value: String(enabled), type: 'boolean', description: 'Enable manual EcoCash payment option' },
        { key: 'ecocash_manual_instructions', value: instructions || '', type: 'string', description: 'Instructions for manual EcoCash payment' },
        { key: 'ecocash_support_whatsapp', value: whatsappNumber || '', type: 'string', description: 'WhatsApp number for EcoCash payment support' },
        { key: 'ecocash_merchant_number', value: merchantNumber || '', type: 'string', description: 'EcoCash merchant number for payments' },
        { key: 'ecocash_merchant_name', value: merchantName || '', type: 'string', description: 'EcoCash merchant name for payments' }
      ];
      
      for (const setting of settingsToUpdate) {
        const existing = await db.select()
          .from(systemSettings)
          .where(eq(systemSettings.key, setting.key))
          .limit(1);
        
        if (existing.length > 0) {
          await db.update(systemSettings)
            .set({ value: setting.value, updatedAt: new Date() })
            .where(eq(systemSettings.key, setting.key));
        } else {
          await db.insert(systemSettings).values({
            key: setting.key,
            value: setting.value,
            type: setting.type,
            description: setting.description,
            category: 'payment'
          });
        }
      }
      
      res.json({ success: true, message: 'EcoCash manual payment settings updated successfully' });
    } catch (error: any) {
      console.error("Error updating EcoCash manual payment settings:", error?.message, error?.stack);
      res.status(500).json({ success: false, error: error?.message || "Failed to update EcoCash manual payment settings" });
    }
  });
  
  // GET /api/ecocash/is-api-configured - Check if EcoCash API is configured
  app.get("/api/ecocash/is-api-configured", async (req, res) => {
    try {
      const gateway = await storage.getPaymentGateway('ecocash');
      const isConfigured = gateway && gateway.isEnabled && gateway.secretKey && gateway.publishableKey;
      res.json({ success: true, isConfigured: !!isConfigured });
    } catch (error: any) {
      console.error('Error checking EcoCash API configuration:', error);
      res.json({ success: true, isConfigured: false });
    }
  });

  // Get custom logo URL by type and size
  app.get("/api/admin/settings/logo/:type?/:size?", async (req, res) => {
    try {
      const { type = 'home', size = 'square' } = req.params;
      const validTypes = ['home', 'student', 'teacher', 'freelancer', 'customer', 'footer', 'auth'];
      const validSizes = ['square', 'wide'];
      
      if (!validTypes.includes(type)) {
        return res.status(400).json({ success: false, error: 'Invalid logo type. Must be: home, student, teacher, freelancer, customer, footer, or auth' });
      }
      
      if (!validSizes.includes(size)) {
        return res.status(400).json({ success: false, error: 'Invalid logo size. Must be: square or wide' });
      }
      
      const logoKey = `${type}_logo_${size}_url`;
      const logoSetting = await db.select()
        .from(systemSettings)
        .where(eq(systemSettings.key, logoKey))
        .limit(1);
      
      res.json({ success: true, logoUrl: logoSetting[0]?.value || null, type, size });
    } catch (error: any) {
      console.error('Error fetching logo setting:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch logo setting' });
    }
  });

  // Get all logo URLs (both square and wide)
  app.get("/api/admin/settings/logos", async (req, res) => {
    try {
      const logoSettings = await db.select()
        .from(systemSettings)
        .where(or(
          eq(systemSettings.key, 'home_logo_square_url'),
          eq(systemSettings.key, 'home_logo_wide_url'),
          eq(systemSettings.key, 'student_logo_square_url'),
          eq(systemSettings.key, 'student_logo_wide_url'),
          eq(systemSettings.key, 'teacher_logo_square_url'),
          eq(systemSettings.key, 'teacher_logo_wide_url'),
          eq(systemSettings.key, 'freelancer_logo_square_url'),
          eq(systemSettings.key, 'freelancer_logo_wide_url'),
          eq(systemSettings.key, 'customer_logo_square_url'),
          eq(systemSettings.key, 'customer_logo_wide_url'),
          eq(systemSettings.key, 'footer_logo_square_url'),
          eq(systemSettings.key, 'footer_logo_wide_url'),
          eq(systemSettings.key, 'auth_logo_square_url'),
          eq(systemSettings.key, 'auth_logo_wide_url')
        ));
      
      const logos = {
        home: { square: null, wide: null },
        student: { square: null, wide: null },
        teacher: { square: null, wide: null },
        freelancer: { square: null, wide: null },
        customer: { square: null, wide: null },
        footer: { square: null, wide: null },
        auth: { square: null, wide: null }
      };
      
      logoSettings.forEach(setting => {
        const match = setting.key.match(/^(\w+)_logo_(square|wide)_url$/);
        if (match) {
          const [, type, size] = match;
          if (logos[type as keyof typeof logos]) {
            logos[type as keyof typeof logos][size as 'square' | 'wide'] = setting.value;
          }
        }
      });
      
      res.json({ success: true, logos });
    } catch (error: any) {
      console.error('Error fetching logo settings:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch logo settings' });
    }
  });

  // Clean dedicated logo upload endpoint with size support
  app.post("/api/admin/settings/logo/:type/:size", requireAuth, requireAdmin, (req, res) => {
    console.log('ðŸŽ¯ Clean logo upload endpoint hit:', req.url);
    console.log('ðŸŽ¯ Content-Type:', req.get('content-type'));
    
    const { type, size } = req.params;
    const validTypes = ['home', 'student', 'teacher', 'freelancer', 'customer', 'footer', 'auth'];
    const validSizes = ['square', 'wide'];
    
    if (!validTypes.includes(type)) {
      return res.status(400).json({ error: 'Invalid logo type. Must be: home, student, teacher, freelancer, customer, footer, or auth' });
    }
    
    if (!validSizes.includes(size)) {
      return res.status(400).json({ error: 'Invalid logo size. Must be: square or wide' });
    }
    
    // Create multer instance for this specific request
    const upload = multer({
      storage: multer.memoryStorage(),
      limits: { fileSize: 10 * 1024 * 1024 }, // 10MB
      fileFilter: (req, file, cb) => {
        const allowedTypes = ["image/jpeg", "image/png", "image/webp", "image/gif"];
        if (allowedTypes.includes(file.mimetype)) {
          cb(null, true);
        } else {
          cb(new Error("Only JPEG, PNG, WebP, and GIF files are allowed"));
        }
      }
    }).single('logo');
    
    upload(req, res, async (err) => {
      if (err) {
        console.log('âŒ Upload error:', err.message);
        return res.status(400).json({ error: err.message });
      }
      
      console.log('ðŸŽ¯ File received:', {
        hasFile: !!req.file,
        filename: req.file?.originalname,
        size: req.file?.size,
        mimetype: req.file?.mimetype
      });
      
      if (!req.file) {
        return res.status(400).json({ error: 'No logo file provided' });
      }

      try {
        console.log('ðŸ”„ Starting Cloudinary upload...');
        const result = await cloudinaryStorage.uploadFile(
          req.file.buffer,
          req.file.originalname,
          req.file.mimetype,
          `logos/${type}/${size}`
        );
        
        console.log('ðŸ“¤ Upload result:', { success: result.success, hasUrl: !!result.url });

        if (!result.success || !result.url) {
          return res.status(500).json({ 
            success: false, 
            error: result.error || 'Upload failed'
          });
        }

        // Save to database
        const logoKey = `${type}_logo_${size}_url`;
        const existingLogo = await db.select()
          .from(systemSettings)
          .where(eq(systemSettings.key, logoKey))
          .limit(1);

        if (existingLogo.length > 0) {
          await db.update(systemSettings)
            .set({ value: result.url, updatedAt: new Date() })
            .where(eq(systemSettings.key, logoKey));
        } else {
          await db.insert(systemSettings).values({
            key: logoKey,
            value: result.url,
            type: 'string',
            description: `${type} ${size} logo URL`,
            category: 'branding',
            isPublic: true
          });
        }

        console.log('âœ… Logo upload successful');
        res.json({ 
          success: true, 
          logoUrl: result.url, 
          type,
          size,
          message: `${type.charAt(0).toUpperCase() + type.slice(1)} ${size} logo uploaded successfully` 
        });
        
      } catch (error: any) {
        console.error('âŒ Upload error:', error);
        res.status(500).json({ success: false, error: 'Upload failed' });
      }
    });
  });

  // Reset to default logo by type and size
  app.delete("/api/admin/settings/logo/:type/:size", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { type, size } = req.params;
      const validTypes = ['home', 'student', 'teacher', 'freelancer', 'customer', 'footer', 'auth'];
      const validSizes = ['square', 'wide'];
      
      if (!validTypes.includes(type)) {
        return res.status(400).json({ error: 'Invalid logo type. Must be: home, student, teacher, freelancer, customer, footer, or auth' });
      }
      
      if (!validSizes.includes(size)) {
        return res.status(400).json({ error: 'Invalid logo size. Must be: square or wide' });
      }
      
      const logoKey = `${type}_logo_${size}_url`;
      await db.delete(systemSettings)
        .where(eq(systemSettings.key, logoKey));
      
      res.json({ success: true, type, size, message: `${type.charAt(0).toUpperCase() + type.slice(1)} ${size} logo reset to default successfully` });
    } catch (error: any) {
      console.error('Error resetting logo:', error);
      res.status(500).json({ success: false, error: 'Failed to reset logo' });
    }
  });

  // GET /api/admin/settings/freelancer-default-cover - Get default freelancer cover (admin)
  app.get("/api/admin/settings/freelancer-default-cover", requireAuth, requireAdmin, async (req, res) => {
    try {
      const setting = await db.select()
        .from(systemSettings)
        .where(eq(systemSettings.key, 'freelancer_default_cover'))
        .limit(1);

      if (setting.length === 0 || !setting[0].value) {
        return res.json({ success: true, url: null });
      }

      res.json({ success: true, url: setting[0].value });
    } catch (error: any) {
      console.error('Error fetching default freelancer cover:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch default cover' });
    }
  });

  // POST /api/admin/settings/freelancer-default-cover - Upload default freelancer cover (admin)
  app.post("/api/admin/settings/freelancer-default-cover", requireAuth, requireAdmin, upload.single('cover'), async (req, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ success: false, error: 'No file uploaded' });
      }

      // Upload to Cloudinary
      const result = await cloudinaryStorage.uploadFile(
        req.file.buffer,
        req.file.originalname,
        req.file.mimetype,
        'general/default-covers'
      );

      const coverUrl = result.url;

      // Save to system settings
      const existingSetting = await db.select()
        .from(systemSettings)
        .where(eq(systemSettings.key, 'freelancer_default_cover'))
        .limit(1);

      if (existingSetting.length > 0) {
        await db.update(systemSettings)
          .set({ value: coverUrl, updatedAt: new Date() })
          .where(eq(systemSettings.key, 'freelancer_default_cover'));
      } else {
        await db.insert(systemSettings).values({
          key: 'freelancer_default_cover',
          value: coverUrl,
        });
      }

      res.json({ success: true, url: coverUrl });
    } catch (error: any) {
      console.error('Error uploading default freelancer cover:', error);
      res.status(500).json({ success: false, error: 'Failed to upload default cover' });
    }
  });

  // DELETE /api/admin/settings/freelancer-default-cover - Delete default freelancer cover (admin)
  app.delete("/api/admin/settings/freelancer-default-cover", requireAuth, requireAdmin, async (req, res) => {
    try {
      await db.update(systemSettings)
        .set({ value: null, updatedAt: new Date() })
        .where(eq(systemSettings.key, 'freelancer_default_cover'));

      res.json({ success: true, message: 'Default cover removed successfully' });
    } catch (error: any) {
      console.error('Error deleting default freelancer cover:', error);
      res.status(500).json({ success: false, error: 'Failed to delete default cover' });
    }
  });

  // GET /api/system-settings/freelancer-default-cover - Get default freelancer cover (public)
  app.get("/api/system-settings/freelancer-default-cover", async (req, res) => {
    try {
      const setting = await db.select()
        .from(systemSettings)
        .where(eq(systemSettings.key, 'freelancer_default_cover'))
        .limit(1);

      if (setting.length === 0 || !setting[0].value) {
        return res.json({ url: null });
      }

      res.json({ url: setting[0].value });
    } catch (error: any) {
      console.error('Error fetching default freelancer cover:', error);
      res.status(500).json({ error: 'Failed to fetch default cover' });
    }
  });

  // ================================
  // Admin Settings & API Keys Routes
  // ================================
  
  // Get all admin settings (optionally filtered by category)
  app.get("/api/admin/settings", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { category } = req.query;
      const settings = await storage.getAdminSettings(category as string);
      res.json({ success: true, data: settings });
    } catch (error: any) {
      console.error('Error fetching admin settings:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch admin settings' });
    }
  });

  // Get a specific admin setting by key
  app.get("/api/admin/settings/:key", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { key } = req.params;
      const setting = await storage.getAdminSetting(key);
      
      if (!setting) {
        return res.status(404).json({ success: false, error: 'Setting not found' });
      }
      
      res.json({ success: true, data: setting });
    } catch (error: any) {
      console.error('Error fetching admin setting:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch admin setting' });
    }
  });

  // Create or update an admin setting
  app.put("/api/admin/settings/:key", requireAuth, requireAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const { key } = req.params;
      const { value, category, description, isEncrypted, isActive } = req.body;
      const adminUserId = req.user!.userId;

      // Check if setting exists
      const existing = await storage.getAdminSetting(key);
      
      if (existing) {
        // Update existing
        const updated = await storage.updateAdminSetting(key, value, adminUserId);
        // Clear cache for this setting
        clearSettingsCache(key);
        res.json({ success: true, data: updated, message: 'Setting updated successfully' });
      } else {
        // Create new
        const newSetting = await storage.createAdminSetting({
          settingKey: key,
          settingValue: value,
          category: category || 'api',
          description,
          isEncrypted: isEncrypted || false,
          isActive: isActive !== undefined ? isActive : true,
          updatedBy: adminUserId
        });
        // Clear cache for this setting
        clearSettingsCache(key);
        res.json({ success: true, data: newSetting, message: 'Setting created successfully' });
      }
    } catch (error: any) {
      console.error('Error creating/updating admin setting:', error);
      res.status(500).json({ success: false, error: 'Failed to save admin setting' });
    }
  });

  // Delete an admin setting
  app.delete("/api/admin/settings/:key", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { key } = req.params;
      const deleted = await storage.deleteAdminSetting(key);
      
      if (!deleted) {
        return res.status(404).json({ success: false, error: 'Setting not found' });
      }
      
      // Clear cache for this setting
      clearSettingsCache(key);
      res.json({ success: true, message: 'Setting deleted successfully' });
    } catch (error: any) {
      console.error('Error deleting admin setting:', error);
      res.status(500).json({ success: false, error: 'Failed to delete admin setting' });
    }
  });

  // ================================
  // =================================
  // Theme Settings Routes
  // =================================

  // Get theme settings (public - no auth required)
  app.get("/api/theme-settings", async (req, res) => {
    try {
      const themeSettings = await storage.getAdminSettings('theme');
      
      const themeData: Record<string, string> = {};
      themeSettings.forEach(setting => {
        themeData[setting.settingKey] = setting.settingValue || '';
      });
      
      res.json({ success: true, data: themeData });
    } catch (error: any) {
      console.error('Error fetching theme settings:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch theme settings' });
    }
  });

  // Update theme settings (admin only)
  app.post("/api/admin/theme-settings", requireAuth, requireAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const { primaryColor, secondaryColor, accentColor, primaryFont, headingFont } = req.body;
      const adminUserId = req.user!.userId;

      const themeSettings = [
        { key: 'theme_primary_color', value: primaryColor },
        { key: 'theme_secondary_color', value: secondaryColor },
        { key: 'theme_accent_color', value: accentColor },
        { key: 'theme_primary_font', value: primaryFont },
        { key: 'theme_heading_font', value: headingFont }
      ];

      for (const { key, value } of themeSettings) {
        if (value) {
          const existing = await storage.getAdminSetting(key);
          if (existing) {
            await storage.updateAdminSetting(key, value, adminUserId);
          } else {
            await storage.createAdminSetting({
              settingKey: key,
              settingValue: value,
              category: 'theme',
              description: `Theme setting for ${key.replace('theme_', '').replace(/_/g, ' ')}`,
              isEncrypted: false,
              isActive: true,
              updatedBy: adminUserId
            });
          }
          clearSettingsCache(key);
        }
      }

      res.json({ success: true, message: 'Theme settings updated successfully' });
    } catch (error: any) {
      console.error('Error updating theme settings:', error);
      res.status(500).json({ success: false, error: 'Failed to update theme settings' });
    }
  });

  // Reset theme to defaults (admin only)
  app.post("/api/admin/theme-settings/reset", requireAuth, requireAdmin, async (req, res) => {
    try {
      const themeKeys = [
        'theme_primary_color',
        'theme_secondary_color',
        'theme_accent_color',
        'theme_primary_font',
        'theme_heading_font'
      ];

      for (const key of themeKeys) {
        await storage.deleteAdminSetting(key);
        clearSettingsCache(key);
      }

      res.json({ success: true, message: 'Theme reset to defaults successfully' });
    } catch (error: any) {
      console.error('Error resetting theme:', error);
      res.status(500).json({ success: false, error: 'Failed to reset theme' });
    }
  });

  // =================================
  // Payment Gateway Configuration Routes
  // ================================
  
  // Public endpoint to get enabled payment gateways (without sensitive data)
  app.get("/api/payment-gateways/enabled", async (req, res) => {
    try {
      const gateways = await storage.getPaymentGateways(true); // Get only enabled
      
      // Return only non-sensitive information
      const publicGateways = gateways.map(gateway => ({
        gatewayId: gateway.gatewayId,
        gatewayName: gateway.gatewayName,
        isPrimary: gateway.isPrimary,
        supportedCurrencies: gateway.supportedCurrencies,
        features: gateway.features,
        testMode: gateway.testMode
      }));
      
      res.json({ success: true, data: publicGateways });
    } catch (error: any) {
      console.error('Error fetching enabled payment gateways:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch payment gateways' });
    }
  });
  
  // Get all payment gateways
  app.get("/api/admin/payment-gateways", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { enabled } = req.query;
      const gateways = await storage.getPaymentGateways(enabled === 'true');
      res.json({ success: true, data: gateways });
    } catch (error: any) {
      console.error('Error fetching payment gateways:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch payment gateways' });
    }
  });

  // Get a specific payment gateway
  app.get("/api/admin/payment-gateways/:gatewayId", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { gatewayId } = req.params;
      const gateway = await storage.getPaymentGateway(gatewayId);
      
      if (!gateway) {
        return res.status(404).json({ success: false, error: 'Payment gateway not found' });
      }
      
      res.json({ success: true, data: gateway });
    } catch (error: any) {
      console.error('Error fetching payment gateway:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch payment gateway' });
    }
  });

  // Create or update a payment gateway
  app.put("/api/admin/payment-gateways/:gatewayId", requireAuth, requireAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const { gatewayId } = req.params;
      const {
        gatewayName,
        publishableKey,
        secretKey,
        webhookSecret,
        isEnabled,
        isPrimary,
        testMode,
        supportedCurrencies,
        features,
        additionalConfig
      } = req.body;
      const adminUserId = req.user!.userId;

      // Check if gateway exists
      const existing = await storage.getPaymentGateway(gatewayId);
      
      if (existing) {
        // Update existing
        const updated = await storage.updatePaymentGateway(gatewayId, {
          gatewayName,
          publishableKey,
          secretKey,
          webhookSecret,
          isEnabled,
          isPrimary,
          testMode,
          supportedCurrencies,
          features,
          additionalConfig
        }, adminUserId);
        
        // Invalidate payment gateway cache
        invalidatePaymentGatewayCache();
        
        res.json({ success: true, data: updated, message: 'Payment gateway updated successfully' });
      } else {
        // Create new
        const newGateway = await storage.createPaymentGateway({
          gatewayId,
          gatewayName,
          publishableKey,
          secretKey,
          webhookSecret,
          isEnabled: isEnabled !== undefined ? isEnabled : false,
          isPrimary: isPrimary !== undefined ? isPrimary : false,
          testMode: testMode !== undefined ? testMode : true,
          supportedCurrencies,
          features,
          additionalConfig,
          updatedBy: adminUserId
        });
        
        // Invalidate payment gateway cache
        invalidatePaymentGatewayCache();
        
        res.json({ success: true, data: newGateway, message: 'Payment gateway created successfully' });
      }
    } catch (error: any) {
      console.error('Error creating/updating payment gateway:', error);
      res.status(500).json({ success: false, error: 'Failed to save payment gateway' });
    }
  });

  // Set a payment gateway as primary
  app.post("/api/admin/payment-gateways/:gatewayId/set-primary", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { gatewayId } = req.params;
      const updated = await storage.setPrimaryPaymentGateway(gatewayId);
      
      if (!updated) {
        return res.status(404).json({ success: false, error: 'Payment gateway not found' });
      }
      
      // Invalidate payment gateway cache
      invalidatePaymentGatewayCache();
      
      res.json({ success: true, data: updated, message: 'Primary payment gateway updated successfully' });
    } catch (error: any) {
      console.error('Error setting primary payment gateway:', error);
      res.status(500).json({ success: false, error: 'Failed to set primary payment gateway' });
    }
  });

  // Delete a payment gateway
  app.delete("/api/admin/payment-gateways/:gatewayId", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { gatewayId } = req.params;
      const deleted = await storage.deletePaymentGateway(gatewayId);
      
      if (!deleted) {
        return res.status(404).json({ success: false, error: 'Payment gateway not found' });
      }
      
      // Invalidate payment gateway cache
      invalidatePaymentGatewayCache();
      
      res.json({ success: true, message: 'Payment gateway deleted successfully' });
    } catch (error: any) {
      console.error('Error deleting payment gateway:', error);
      res.status(500).json({ success: false, error: 'Failed to delete payment gateway' });
    }
  });

  // Get Stripe publishable key (public endpoint for frontend)
  app.get("/api/payment/stripe/publishable-key", async (req, res) => {
    try {
      const publishableKey = await getStripePublishableKey();
      
      if (!publishableKey) {
        return res.status(404).json({ 
          success: false, 
          error: 'Stripe is not configured. Please configure it in admin settings.' 
        });
      }
      
      res.json({ success: true, publishableKey });
    } catch (error: any) {
      console.error('Error fetching Stripe publishable key:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch Stripe publishable key' });
    }
  });

  // Admin Dashboard - Delete All Users
  app.delete("/api/admin/users/all", async (req, res) => {
    try {
      console.log('ðŸ—‘ï¸ Starting deletion of all users...');
      
      // Delete all user-related data in the correct order to avoid foreign key conflicts
      
      // 1. Delete user login sessions
      await db.delete(userLoginSessions);
      console.log('âœ… Deleted user login sessions');
      
      // 2. Delete user notification preferences
      await db.delete(userNotificationPreferences);
      console.log('âœ… Deleted user notification preferences');
      
      // 3. Delete user privacy settings
      await db.delete(userPrivacySettings);
      console.log('âœ… Deleted user privacy settings');
      
      // 4. Delete user other settings
      await db.delete(userOtherSettings);
      console.log('âœ… Deleted user other settings');
      
      // 5. Delete student progress
      await db.delete(studentProgress);
      console.log('âœ… Deleted student progress');
      
      // 6. Delete course enrollments
      await db.delete(courseEnrollments);
      console.log('âœ… Deleted course enrollments');
      
      // 7. Delete payment methods
      await db.delete(paymentMethods);
      console.log('âœ… Deleted payment methods');
      
      // 8. Delete notifications
      await db.delete(notifications);
      console.log('âœ… Deleted notifications');
      
      // 9. Delete teacher applications
      await db.delete(teacherApplications);
      console.log('âœ… Deleted teacher applications');
      
      // 10. Delete password reset tokens
      await db.delete(passwordResetTokens);
      console.log('âœ… Deleted password reset tokens');
      
      // 11. Delete verification codes
      await db.delete(verificationCodes);
      console.log('âœ… Deleted verification codes');
      
      // 12. Delete user profiles
      await db.delete(profiles);
      console.log('âœ… Deleted user profiles');
      
      // 13. Finally, delete users
      const deletedUsers = await db.delete(users);
      console.log('âœ… Deleted all users');
      
      // Clear any in-memory storage
      const paymentMethodsStorage = new Map();
      const profileStorage = new Map();
      paymentMethodsStorage.clear();
      profileStorage.clear();
      
      console.log('ðŸŽ‰ All users and related data deleted successfully');
      
      res.json({ 
        success: true, 
        message: "All users and related data deleted successfully" 
      });

    } catch (error: any) {
      console.error('âŒ Error deleting all users:', error);
      res.status(500).json({ 
        success: false, 
        error: "Failed to delete all users" 
      });
    }
  });

  // ==================== PRICING PLANS MANAGEMENT API ====================
  
  // GET /api/admin/pricing-plans - Get all pricing plans
  app.get("/api/admin/pricing-plans", requireAuth, requireAdmin, async (req, res) => {
    try {
      const plans = await db
        .select()
        .from(pricingPlans)
        .orderBy(asc(pricingPlans.sortOrder), asc(pricingPlans.createdAt));

      res.json({ success: true,
        success: true,
        data: plans
      });
    } catch (error: any) {
      console.error('Error fetching pricing plans:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch pricing plans'
      });
    }
  });

  // POST /api/admin/pricing-plans - Create new pricing plan
  app.post("/api/admin/pricing-plans", requireAuth, requireAdmin, async (req, res) => {
    try {
      // Transform numeric prices to strings if needed
      const bodyData = { ...req.body };
      if (bodyData.priceMonthly !== undefined && typeof bodyData.priceMonthly === 'number') {
        bodyData.priceMonthly = bodyData.priceMonthly.toString();
      }
      if (bodyData.priceYearly !== undefined && typeof bodyData.priceYearly === 'number') {
        bodyData.priceYearly = bodyData.priceYearly.toString();
      }
      
      const validatedData = insertPricingPlanSchema.parse(bodyData);
      
      const [newPlan] = await db
        .insert(pricingPlans)
        .values(validatedData)
        .returning();

      res.json({ success: true,
        success: true,
        data: newPlan,
        message: 'Pricing plan created successfully'
      });
    } catch (error: any) {
      console.error('Error creating pricing plan:', error);
      if (error.name === 'ZodError') {
        return res.status(400).json({
          success: false,
          error: 'Invalid input data',
          details: error.errors
        });
      }
      res.status(500).json({
        success: false,
        error: 'Failed to create pricing plan'
      });
    }
  });

  // PUT /api/admin/pricing-plans/:id - Update existing pricing plan
  app.put("/api/admin/pricing-plans/:id", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      
      // Transform numeric prices to strings if needed
      const bodyData = { ...req.body };
      if (bodyData.priceMonthly !== undefined && typeof bodyData.priceMonthly === 'number') {
        bodyData.priceMonthly = bodyData.priceMonthly.toString();
      }
      if (bodyData.priceYearly !== undefined && typeof bodyData.priceYearly === 'number') {
        bodyData.priceYearly = bodyData.priceYearly.toString();
      }
      
      const validatedData = insertPricingPlanSchema.partial().parse(bodyData);
      
      // Remove undefined values
      const updateData = Object.fromEntries(
        Object.entries(validatedData).filter(([_, value]) => value !== undefined)
      );
      
      if (Object.keys(updateData).length === 0) {
        return res.status(400).json({
          success: false,
          error: 'No valid fields to update'
        });
      }

      updateData.updatedAt = new Date();

      const [updatedPlan] = await db
        .update(pricingPlans)
        .set(updateData)
        .where(eq(pricingPlans.id, id))
        .returning();

      if (!updatedPlan) {
        return res.status(404).json({
          success: false,
          error: 'Pricing plan not found'
        });
      }

      res.json({ success: true,
        success: true,
        data: updatedPlan,
        message: 'Pricing plan updated successfully'
      });
    } catch (error: any) {
      console.error('Error updating pricing plan:', error);
      if (error.name === 'ZodError') {
        return res.status(400).json({
          success: false,
          error: 'Invalid input data',
          details: error.errors
        });
      }
      res.status(500).json({
        success: false,
        error: 'Failed to update pricing plan'
      });
    }
  });

  // DELETE /api/admin/pricing-plans/:id - Delete pricing plan
  app.delete("/api/admin/pricing-plans/:id", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;

      // Check if plan is being used by any active subscriptions
      const activeSubscriptions = await db
        .select({ count: count() })
        .from(userSubscriptions)
        .where(and(
          eq(userSubscriptions.planId, id),
          eq(userSubscriptions.status, 'active')
        ));

      if (activeSubscriptions[0].count > 0) {
        return res.status(400).json({
          success: false,
          error: 'Cannot delete pricing plan with active subscriptions. Please deactivate it instead.'
        });
      }

      const [deletedPlan] = await db
        .delete(pricingPlans)
        .where(eq(pricingPlans.id, id))
        .returning();

      if (!deletedPlan) {
        return res.status(404).json({
          success: false,
          error: 'Pricing plan not found'
        });
      }

      res.json({ success: true,
        success: true,
        message: 'Pricing plan deleted successfully'
      });
    } catch (error: any) {
      console.error('Error deleting pricing plan:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to delete pricing plan'
      });
    }
  });

  // PATCH /api/admin/pricing-plans/:id/toggle - Toggle active status
  app.patch("/api/admin/pricing-plans/:id/toggle", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;

      // Get current plan
      const [currentPlan] = await db
        .select()
        .from(pricingPlans)
        .where(eq(pricingPlans.id, id))
        .limit(1);

      if (!currentPlan) {
        return res.status(404).json({
          success: false,
          error: 'Pricing plan not found'
        });
      }

      const [updatedPlan] = await db
        .update(pricingPlans)
        .set({ 
          isActive: !currentPlan.isActive,
          updatedAt: new Date()
        })
        .where(eq(pricingPlans.id, id))
        .returning();

      res.json({ success: true,
        success: true,
        data: updatedPlan,
        message: `Pricing plan ${updatedPlan.isActive ? 'activated' : 'deactivated'} successfully`
      });
    } catch (error: any) {
      console.error('Error toggling pricing plan status:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to toggle pricing plan status'
      });
    }
  });

  // PATCH /api/admin/pricing-plans/:id/popular - Toggle popular status
  app.patch("/api/admin/pricing-plans/:id/popular", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;

      // Get current plan
      const [currentPlan] = await db
        .select()
        .from(pricingPlans)
        .where(eq(pricingPlans.id, id))
        .limit(1);

      if (!currentPlan) {
        return res.status(404).json({
          success: false,
          error: 'Pricing plan not found'
        });
      }

      const [updatedPlan] = await db
        .update(pricingPlans)
        .set({ 
          isPopular: !currentPlan.isPopular,
          updatedAt: new Date()
        })
        .where(eq(pricingPlans.id, id))
        .returning();

      res.json({ success: true,
        success: true,
        data: updatedPlan,
        message: `Pricing plan marked as ${updatedPlan.isPopular ? 'popular' : 'not popular'} successfully`
      });
    } catch (error: any) {
      console.error('Error toggling pricing plan popular status:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to toggle pricing plan popular status'
      });
    }
  });

  // GET /api/pricing-plans - Get active pricing plans (public endpoint)
  app.get("/api/pricing-plans", async (req, res) => {
    try {
      const plans = await db
        .select()
        .from(pricingPlans)
        .where(eq(pricingPlans.isActive, true))
        .orderBy(asc(pricingPlans.sortOrder), asc(pricingPlans.createdAt));

      res.json({ success: true,
        success: true,
        data: plans
      });
    } catch (error: any) {
      console.error('Error fetching active pricing plans:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch pricing plans'
      });
    }
  });

  // Teacher Verification System
  
  // Submit Teacher Application
  app.post("/api/teacher/apply", async (req, res) => {
    try {
      const {
        fullName,
        email,
        phoneNumber,
        qualifications,
        experience,
        portfolioLinks,
        certifications,
        country,
        city,
        availableHours,
        hourlyRate,
        bio
      } = req.body;

      // Validation
      if (!fullName || !email || !qualifications || !experience || !country) {
        return res.status(400).json({ 
          success: false, 
          error: "Missing required fields: Full Name, Email, Qualifications, Experience, and Country are required" 
        });
      }

      if (!isValidEmail(email)) {
        return res.status(400).json({ success: false, error: "Invalid email format" });
      }

      // Check if application already exists for this email
      const existingApplication = await db
        .select()
        .from(teacherApplications)
        .where(eq(teacherApplications.email, email))
        .limit(1);

      if (existingApplication.length > 0) {
        return res.status(400).json({ 
          success: false, 
          error: "Application already submitted for this email address" 
        });
      }

      // Generate verification code
      const verificationCode = Math.random().toString(36).substring(2, 8).toUpperCase();

      // Insert teacher application
      const [newApplication] = await db
        .insert(teacherApplications)
        .values({
          fullName,
          email,
          phoneNumber: phoneNumber || null,
          qualifications,
          experience,
          portfolioLinks: portfolioLinks ? JSON.parse(JSON.stringify(portfolioLinks)) : null,
          certifications: certifications ? JSON.parse(JSON.stringify(certifications)) : null,
          country,
          city: city || null,
          availableHours: availableHours || null,
          hourlyRate: hourlyRate ? hourlyRate.toString() : null,
          bio: bio || null,
          verificationCode,
          status: 'pending'
        })
        .returning();

      // Send verification email
      const emailResult = await sendEmail(
        email,
        'Verify Your EduFiliova Teacher Application',
        getEmailTemplate('teacher-verification', { 
          code: verificationCode,
          fullName 
        })
      );

      res.json({ 
        success: true, 
        message: "Teacher application submitted successfully. Please check your email for verification code.",
        applicationId: newApplication.id
      });

    } catch (error: any) {
      console.error('Teacher application error:', error);
      res.status(500).json({ success: false, error: "Failed to submit teacher application" });
    }
  });

  // Verify Teacher Application
  app.post("/api/teacher/verify", async (req, res) => {
    try {
      const { email, code } = req.body;

      if (!email || !code) {
        return res.status(400).json({ success: false, error: "Email and verification code are required" });
      }

      // Find application with matching email and code
      const application = await db
        .select()
        .from(teacherApplications)
        .where(and(
          eq(teacherApplications.email, email),
          eq(teacherApplications.verificationCode, code),
          eq(teacherApplications.status, 'pending')
        ))
        .limit(1);

      if (application.length === 0) {
        return res.status(400).json({ success: false, error: "Invalid verification code or application not found" });
      }

      // Update application status to verified
      await db
        .update(teacherApplications)
        .set({ 
          status: 'verified',
          verifiedAt: new Date()
        })
        .where(eq(teacherApplications.id, application[0].id));

      res.json({ 
        success: true, 
        message: "Teacher application verified successfully. Your application is now under review."
      });

    } catch (error: any) {
      console.error('Teacher verification error:', error);
      res.status(500).json({ success: false, error: "Failed to verify teacher application" });
    }
  });

  // Create Verified Teacher Login
  app.post("/api/teacher/login", async (req, res) => {
    try {
      const { email, password } = req.body;

      if (!email || !password) {
        return res.status(400).json({ success: false, error: "Email and password are required" });
      }

      // Find verified teacher application
      const teacherApp = await db
        .select()
        .from(teacherApplications)
        .where(and(
          eq(teacherApplications.email, email),
          or(
            eq(teacherApplications.status, 'verified'),
            eq(teacherApplications.status, 'approved')
          )
        ))
        .limit(1);

      if (teacherApp.length === 0) {
        return res.status(401).json({ 
          success: false, 
          error: "No verified teacher account found for this email. Please apply as a teacher first." 
        });
      }

      // Find user account
      const user = await db
        .select()
        .from(users)
        .where(eq(users.email, email))
        .limit(1);

      let userId;
      let profile;

      if (user.length === 0) {
        // Create new user account for verified teacher
        const hashedPassword = await bcrypt.hash(password, 10);
        const newUserId = `T${Date.now().toString().slice(-7)}${Math.random().toString(36).substring(2, 4).toUpperCase()}`;

        const [newUser] = await db
          .insert(users)
          .values({
            userId: newUserId,
            email,
            passwordHash: hashedPassword
          })
          .returning();

        // Create teacher profile
        const [newProfile] = await db
          .insert(profiles)
          .values({
            userId: newUser.id,
            name: teacherApp[0].fullName,
            age: 25, // Default age for teachers
            grade: 12, // Default grade for teachers
            educationLevel: 'university',
            country: teacherApp[0].country,
            role: 'teacher'
          })
          .returning();

        // Link teacher application to user
        await db
          .update(teacherApplications)
          .set({ userId: newUser.id })
          .where(eq(teacherApplications.id, teacherApp[0].id));

        userId = newUser.id;
        profile = newProfile;
      } else {
        // Verify existing password
        const isValidPassword = await bcrypt.compare(password, user[0].passwordHash);
        if (!isValidPassword) {
          return res.status(401).json({ success: false, error: "Invalid password" });
        }

        // Get profile
        const existingProfile = await db
          .select()
          .from(profiles)
          .where(eq(profiles.userId, user[0].id))
          .limit(1);

        if (existingProfile.length === 0 || existingProfile[0].role !== 'teacher') {
          return res.status(401).json({ success: false, error: "Account is not verified as a teacher" });
        }

        userId = user[0].id;
        profile = existingProfile[0];
      }

      // Create session
      const sessionId = uuidv4();
      await db.insert(userLoginSessions).values({
        userId,
        sessionId,
        userAgent: req.headers['user-agent'] || 'Unknown',
        ipAddress: req.ip || 'Unknown',
        expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 days
      });

      res.json({ success: true,
        success: true,
        message: "Teacher login successful",
        user: {
          id: userId,
          email,
          role: 'teacher'
        },
        profile,
        sessionId,
        teacherApplication: teacherApp[0]
      });

    } catch (error: any) {
      console.error('Teacher login error:', error);
      res.status(500).json({ success: false, error: "Failed to login as teacher" });
    }
  });

  // Get Teacher Application Status
  app.get("/api/teacher/status/:email", async (req, res) => {
    try {
      const { email } = req.params;

      const application = await db
        .select()
        .from(teacherApplications)
        .where(eq(teacherApplications.email, email))
        .limit(1);

      if (application.length === 0) {
        return res.status(404).json({ success: false, error: "No teacher application found" });
      }

      res.json({ 
        success: true, 
        status: application[0].status,
        application: {
          id: application[0].id,
          fullName: application[0].fullName,
          email: application[0].email,
          status: application[0].status,
          submittedAt: application[0].submittedAt,
          verifiedAt: application[0].verifiedAt,
          reviewedAt: application[0].reviewedAt
        }
      });

    } catch (error: any) {
      console.error('Teacher status check error:', error);
      res.status(500).json({ success: false, error: "Failed to check teacher status" });
    }
  });

  // Admin: Approve/Reject Teacher Application
  app.put("/api/admin/teacher/:id/status", async (req, res) => {
    try {
      const { id } = req.params;
      const { status, notes } = req.body;

      if (!['approved', 'rejected'].includes(status)) {
        return res.status(400).json({ success: false, error: "Status must be 'approved' or 'rejected'" });
      }

      await db
        .update(teacherApplications)
        .set({ 
          status,
          notes: notes || null,
          reviewedAt: new Date()
        })
        .where(eq(teacherApplications.id, id));

      res.json({ success: true, message: `Teacher application ${status} successfully` });

    } catch (error: any) {
      console.error('Teacher status update error:', error);
      res.status(500).json({ success: false, error: "Failed to update teacher status" });
    }
  });


  // Get curricula for a specific country with fallback logic
  app.get("/api/curricula/for-country/:countryId", async (req, res) => {
    try {
      const { countryId } = req.params;
      
      // First try to find country-specific curricula
      let curriculaData = await db
        .select({
          id: curricula.id,
          name: curricula.name,
          displayName: curricula.displayName,
          description: curricula.description,
          systemType: curricula.systemType,
          countryCode: curricula.countryCode,
          isPrimary: countryCurricula.isPrimary,
          isActive: curricula.isActive
        })
        .from(curricula)
        .innerJoin(countryCurricula, eq(curricula.id, countryCurricula.curriculumId))
        .where(and(
          eq(countryCurricula.countryId, parseInt(countryId)),
          eq(curricula.isActive, true)
        ))
        .orderBy(desc(countryCurricula.isPrimary));
      
      // If no country-specific curricula found, include "All Systems" as fallback
      if (curriculaData.length === 0) {
        const allSystemsCurriculum = await db
          .select({
            id: curricula.id,
            name: curricula.name,
            displayName: curricula.displayName,
            description: curricula.description,
            systemType: curricula.systemType,
            countryCode: curricula.countryCode,
            isPrimary: sql<boolean>`true`.as('isPrimary'), // Set as primary since it's the fallback
            isActive: curricula.isActive
          })
          .from(curricula)
          .where(and(
            eq(curricula.systemType, 'all_systems'),
            eq(curricula.isActive, true)
          ))
          .limit(1);
        
        curriculaData = allSystemsCurriculum;
      }
      
      // Get country info for context
      const countryInfo = await db
        .select()
        .from(countries)
        .where(eq(countries.id, parseInt(countryId)))
        .limit(1);
      
      res.json({ 
        success: true, 
        data: curriculaData,
        country: countryInfo[0] || null,
        hasFallback: curriculaData.length > 0 && curriculaData[0].systemType === 'all_systems'
      });
    } catch (error: any) {
      console.error('Curricula fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch curricula" });
    }
  });

  // Get curricula by country (legacy endpoint)
  app.get("/api/curricula/by-country/:countryId", async (req, res) => {
    try {
      const { countryId } = req.params;
      
      const curriculaData = await db
        .select({
          id: curricula.id,
          name: curricula.name,
          displayName: curricula.displayName,
          description: curricula.description,
          systemType: curricula.systemType,
          isPrimary: countryCurricula.isPrimary
        })
        .from(curricula)
        .innerJoin(countryCurricula, eq(curricula.id, countryCurricula.curriculumId))
        .where(eq(countryCurricula.countryId, parseInt(countryId)))
        .orderBy(desc(countryCurricula.isPrimary));
      
      res.json({ success: true, data: curriculaData });
    } catch (error: any) {
      console.error('Curricula fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch curricula" });
    }
  });

  // Get all available curricula
  app.get("/api/curricula", async (req, res) => {
    try {
      const curriculaData = await db
        .select()
        .from(curricula)
        .where(eq(curricula.isActive, true))
        .orderBy(curricula.displayName);
      
      res.json({ success: true, data: curriculaData });
    } catch (error: any) {
      console.error('Curricula fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch curricula" });
    }
  });

  // ============================================
  // SUBJECT-BASED EDUCATION API (Primary/Secondary)
  // ============================================

  // Get subjects filtered by grade level and system (for primary/secondary students)
  app.get("/api/subjects", async (req, res) => {
    try {
      const { gradeLevel, gradeSystem, creatorOnly } = req.query;
      const user = req.user as any;
      const isAdmin = user?.role === "admin";
      
      let conditions: any[] = [eq(subjects.isActive, true)];

      if (creatorOnly === "true" && req.isAuthenticated()) {
        conditions = [eq(subjects.createdBy, user.id)];
      } else if (isAdmin && creatorOnly === "false") {
        conditions = [];
      } else {
        if (gradeLevel) {
          const parsedGrade = parseInt(gradeLevel as string);
          conditions.push(eq(subjects.gradeLevel, parsedGrade));
        }
        
        if (gradeSystem && gradeSystem !== "undefined" && gradeSystem !== "null") {
          conditions.push(or(
            eq(subjects.gradeSystem, gradeSystem as string),
            eq(subjects.gradeSystem, "all")
          ));
        } else {
          conditions.push(eq(subjects.gradeSystem, "all"));
        }
      }
      
      const subjectsData = await db
        .select()
        .from(subjects)
        .where(conditions.length > 0 ? and(...conditions) : undefined)
        .orderBy(subjects.name);
      
      res.json({ success: true, data: subjectsData });
    } catch (error: any) {
      console.error("Subjects fetch error:", error);
      res.status(500).json({ success: false, error: "Failed to fetch subjects" });
    }
  });

  // Get lessons for a specific chapter
  app.get("/api/chapters/:chapterId/lessons", async (req, res) => {
    try {
      const { chapterId } = req.params;
      
      const lessonsData = await db
        .select()
        .from(subjectLessons)
        .where(and(
          eq(subjectLessons.chapterId, chapterId),
          eq(subjectLessons.isActive, true)
        ))
        .orderBy(subjectLessons.order);
      
      res.json({ success: true, data: lessonsData });
    } catch (error: any) {
      console.error('Lessons fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch lessons" });
    }
  });

  // Get a specific lesson with full content
  app.get("/api/lessons/:lessonId", async (req, res) => {
    try {
      const { lessonId } = req.params;
      
      const lessonData = await db
        .select()
        .from(subjectLessons)
        .where(eq(subjectLessons.id, lessonId))
        .limit(1);
      
      if (lessonData.length === 0) {
        return res.status(404).json({ success: false, error: "Lesson not found" });
      }
      
      res.json({ success: true, data: lessonData[0] });
    } catch (error: any) {
      console.error('Lesson fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch lesson" });
    }
  });

  // Get quiz exercises for a specific lesson
  app.get("/api/lessons/:lessonId/exercises", async (req, res) => {
    try {
      const { lessonId } = req.params;
      
      const exercisesData = await db
        .select()
        .from(subjectExercises)
        .where(and(
          eq(subjectExercises.lessonId, lessonId),
          eq(subjectExercises.isActive, true)
        ))
        .orderBy(subjectExercises.order);
      
      res.json({ success: true, data: exercisesData });
    } catch (error: any) {
      console.error('Exercises fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch exercises" });
    }
  });

  // Save or update lesson progress and quiz score
  app.post("/api/lessons/:lessonId/progress", async (req, res) => {
    try {
      const { lessonId } = req.params;
      const { userId, status, score, correctAnswers, totalQuestions, timeSpent } = req.body;
      
      if (!userId) {
        return res.status(400).json({ success: false, error: "User ID is required" });
      }
      
      // Check if progress already exists
      const existingProgress = await db
        .select()
        .from(subjectProgress)
        .where(and(
          eq(subjectProgress.userId, userId),
          eq(subjectProgress.lessonId, lessonId)
        ))
        .limit(1);
      
      const progressData = {
        userId,
        lessonId,
        status: status || 'in_progress',
        score: score || null,
        correctAnswers: correctAnswers || 0,
        totalQuestions: totalQuestions || 15,
        timeSpent: timeSpent || 0,
        completedAt: status === 'completed' ? new Date() : null,
        updatedAt: new Date()
      };
      
      if (existingProgress.length > 0) {
        // Update existing progress
        await db
          .update(subjectProgress)
          .set(progressData)
          .where(eq(subjectProgress.id, existingProgress[0].id));
        
        res.json({ success: true, message: "Progress updated successfully" });
      } else {
        // Create new progress record
        await db.insert(subjectProgress).values(progressData);
        res.json({ success: true, message: "Progress saved successfully" });
      }
    } catch (error: any) {
      console.error('Progress save error:', error);
      res.status(500).json({ success: false, error: "Failed to save progress" });
    }
  });

  // Get student's progress across all subjects
  app.get("/api/subjects/progress/:userId", async (req, res) => {
    try {
      const { userId } = req.params;
      
      const progressData = await db
        .select({
          lessonId: subjectProgress.lessonId,
          status: subjectProgress.status,
          score: subjectProgress.score,
          correctAnswers: subjectProgress.correctAnswers,
          totalQuestions: subjectProgress.totalQuestions,
          completedAt: subjectProgress.completedAt,
          timeSpent: subjectProgress.timeSpent,
          lessonTitle: subjectLessons.title,
          chapterTitle: subjectChapters.title,
          subjectName: subjects.name
        })
        .from(subjectProgress)
        .innerJoin(subjectLessons, eq(subjectProgress.lessonId, subjectLessons.id))
        .innerJoin(subjectChapters, eq(subjectLessons.chapterId, subjectChapters.id))
        .innerJoin(subjects, eq(subjectChapters.subjectId, subjects.id))
        .where(eq(subjectProgress.userId, userId))
        .orderBy(subjects.name, subjectChapters.order, subjectLessons.order);
      
      res.json({ success: true, data: progressData });
    } catch (error: any) {
      console.error('Progress fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch progress" });
    }
  });

  // Get student's in-progress lessons for continue reading cards
  app.get("/api/users/:userId/in-progress-lessons", async (req, res) => {
    try {
      const { userId } = req.params;
      
      const inProgressLessons = await db
        .select({
          lessonId: subjectProgress.lessonId,
          progressPercent: sql<number>`COALESCE(
            CASE 
              WHEN ${subjectProgress.status} = 'completed' THEN 100
              WHEN ${subjectProgress.totalQuestions} > 0 THEN 
                ROUND((${subjectProgress.correctAnswers}::float / ${subjectProgress.totalQuestions}::float) * 100)
              ELSE 0
            END, 
            0
          )`.as('progressPercent'),
          status: subjectProgress.status,
          updatedAt: subjectProgress.updatedAt,
          lessonTitle: subjectLessons.title,
          lessonOrder: subjectLessons.order,
          chapterTitle: subjectChapters.title,
          chapterOrder: subjectChapters.order,
          subjectName: subjects.name,
          subjectId: subjects.id,
          chapterId: subjectChapters.id
        })
        .from(subjectProgress)
        .innerJoin(subjectLessons, eq(subjectProgress.lessonId, subjectLessons.id))
        .innerJoin(subjectChapters, eq(subjectLessons.chapterId, subjectChapters.id))
        .innerJoin(subjects, eq(subjectChapters.subjectId, subjects.id))
        .where(
          and(
            eq(subjectProgress.userId, userId),
            ne(subjectProgress.status, 'completed')
          )
        )
        .orderBy(desc(subjectProgress.updatedAt))
        .limit(10);
      
      res.json({ success: true, data: inProgressLessons });
    } catch (error: any) {
      console.error('In-progress lessons fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch in-progress lessons" });
    }
  });

  // ============================================
  // POST ENDPOINTS FOR SUBJECT-BASED EDUCATION
  // ============================================

  // Create a new subject
  app.post("/api/subjects", async (req, res) => {
    try {
      const { name, gradeSystem, gradeLevel, description, iconUrl } = req.body;
      
      if (!name || !gradeSystem || !gradeLevel) {
        return res.status(400).json({ 
          success: false, 
          error: "Missing required fields" 
        });
      }
      
      const newSubject = await db
        .insert(subjects)
        .values({
          name,
          gradeSystem,
          gradeLevel: parseInt(gradeLevel),
          description: description || null,
          iconUrl: iconUrl || null,
          createdBy: (req.user as any).id,
          isActive: true
        })
        .returning();
      
      res.json({ success: true, data: newSubject[0] });
    } catch (error: any) {
      console.error("Subject creation error:", error);
      res.status(500).json({ success: false, error: "Failed to create subject" });
    }
  });

  // Delete a subject and all its related data
  app.delete("/api/subjects/:subjectId", async (req, res) => {
    try {
      const { subjectId } = req.params;
      
      // Get all chapters for this subject
      const chaptersToDelete = await db
        .select({ id: subjectChapters.id })
        .from(subjectChapters)
        .where(eq(subjectChapters.subjectId, subjectId));
      
      const chapterIds = chaptersToDelete.map(c => c.id);
      
      if (chapterIds.length > 0) {
        // Get all lessons for these chapters
        const lessonsToDelete = await db
          .select({ id: subjectLessons.id })
          .from(subjectLessons)
          .where(inArray(subjectLessons.chapterId, chapterIds));
        
        const lessonIds = lessonsToDelete.map(l => l.id);
        
        // Delete exercises for these lessons
        if (lessonIds.length > 0) {
          await db
            .delete(subjectExercises)
            .where(inArray(subjectExercises.lessonId, lessonIds));
        }
        
        // Delete lessons for these chapters
        await db
          .delete(subjectLessons)
          .where(inArray(subjectLessons.chapterId, chapterIds));
      }
      
      // Delete chapters for this subject
      await db
        .delete(subjectChapters)
        .where(eq(subjectChapters.subjectId, subjectId));
      
      // Delete the subject itself
      await db
        .delete(subjects)
        .where(eq(subjects.id, subjectId));
      
      console.log('Subject deleted:', subjectId);
      res.json({ success: true, message: "Subject deleted successfully" });
    } catch (error: any) {
      console.error('Subject deletion error:', error);
      res.status(500).json({ success: false, error: "Failed to delete subject" });
    }
  });
  // Create a new chapter
  app.post("/api/subjects/:subjectId/chapters", async (req, res) => {
    try {
      const { subjectId } = req.params;
      const { title, description, order } = req.body;
      
      if (!title) {
        return res.status(400).json({ 
          success: false, 
          error: "Missing required field: title" 
        });
      }
      
      const newChapter = await db
        .insert(subjectChapters)
        .values({
          subjectId,
          title,
          description: description || null,
          order: order || 1,
          isActive: true
        })
        .returning();
      
      res.json({ success: true, data: newChapter[0] });
    } catch (error: any) {
      console.error('Chapter creation error:', error);
      res.status(500).json({ success: false, error: "Failed to create chapter" });
    }
  });

  // Create a new lesson
  app.post("/api/chapters/:chapterId/lessons", async (req, res) => {
    try {
      const { chapterId } = req.params;
      const { title, notes, examples, cloudinaryImages, order, durationMinutes } = req.body;
      
      if (!title || !notes) {
        return res.status(400).json({ 
          success: false, 
          error: "Missing required fields: title, notes" 
        });
      }
      
      const newLesson = await db
        .insert(subjectLessons)
        .values({
          chapterId,
          title,
          notes,
          examples: examples || [],
          cloudinaryImages: cloudinaryImages || [],
          order: order || 1,
          durationMinutes: durationMinutes || 30,
          isActive: true
        })
        .returning();
      
      res.json({ success: true, data: newLesson[0] });
    } catch (error: any) {
      console.error('Lesson creation error:', error);
      res.status(500).json({ success: false, error: "Failed to create lesson" });
    }
  });

  // Update a lesson
  app.put("/api/lessons/:lessonId", async (req, res) => {
    try {
      const { lessonId } = req.params;
      const { title, notes, examples, cloudinaryImages, order, durationMinutes } = req.body;
      
      // Build update object with only provided fields
      const updateData: any = { updatedAt: new Date() };
      if (title !== undefined) updateData.title = title;
      if (notes !== undefined) updateData.notes = notes;
      if (examples !== undefined) updateData.examples = examples;
      if (cloudinaryImages !== undefined) updateData.cloudinaryImages = cloudinaryImages;
      if (order !== undefined) updateData.order = order;
      if (durationMinutes !== undefined) updateData.durationMinutes = durationMinutes;
      
      const updatedLesson = await db
        .update(subjectLessons)
        .set(updateData)
        .where(eq(subjectLessons.id, lessonId))
        .returning();
      
      if (updatedLesson.length === 0) {
        return res.status(404).json({ 
          success: false, 
          error: "Lesson not found" 
        });
      }
      
      res.json({ success: true, data: updatedLesson[0] });
    } catch (error: any) {
      console.error('Lesson update error:', error);
      res.status(500).json({ success: false, error: "Failed to update lesson" });
    }
  });

  // Create quiz exercises for a lesson
  app.post("/api/lessons/:lessonId/exercises", async (req, res) => {
    try {
      const { lessonId } = req.params;
      const { exercises } = req.body;
      
      if (!exercises || !Array.isArray(exercises)) {
        return res.status(400).json({ 
          success: false, 
          error: "Missing required field: exercises (must be an array)" 
        });
      }
      
      // Prepare exercises with lessonId and order
      const exercisesToInsert = exercises.map((exercise, index) => ({
        lessonId,
        question: exercise.question,
        options: exercise.options,
        correctAnswer: exercise.correctAnswer,
        explanation: exercise.explanation || null,
        order: index + 1,
        isActive: true
      }));
      
      const newExercises = await db
        .insert(subjectExercises)
        .values(exercisesToInsert)
        .returning();
      
      res.json({ success: true, data: newExercises });
    } catch (error: any) {
      console.error('Exercises creation error:', error);
      res.status(500).json({ success: false, error: "Failed to create exercises" });
    }
  });

  // ============================================
  // COURSES API (College/University/Other)
  // ============================================

  // Courses API endpoints for college/university students
  
  // Get courses (for college/university/other education levels)
  app.get("/api/courses", async (req, res) => {
    try {
      const { difficulty, category } = req.query;
      
      try {
        // Try database first
        let conditions = [eq(courses.isActive, true), eq(courses.approvalStatus, "approved")]; // Only show approved courses
        
        if (difficulty) {
          conditions.push(eq(courses.difficulty, difficulty as string));
        }
        
        if (category) {
          conditions.push(eq(courses.categoryId, category as string));
        }
        
        const coursesData = await db
          .select()
          .from(courses)
          .where(and(...conditions))
          .orderBy(courses.title);
        
        res.json({ success: true, data: coursesData, totalCount: coursesData.length });
      } catch (dbError) {
        console.error('Database error fetching courses:', dbError);
        throw dbError;
      }
    } catch (error: any) {
      console.error('Courses fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch courses" });
    }
  });

  // Get featured courses for landing page
  app.get("/api/courses/featured", async (req, res) => {
    try {
      const limit = parseInt(req.query.limit as string) || 8;
      const featuredCourses = await storage.getFeaturedCourses(limit);
      
      res.json({ success: true, data: featuredCourses });
    } catch (error: any) {
      console.error('Featured courses fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch featured courses" });
    }
  });

  // Admin: Feature/unfeature a course
  app.patch("/api/courses/:id/feature", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { isFeatured } = req.body;

      if (typeof isFeatured !== 'boolean') {
        return res.status(400).json({ success: false, error: "isFeatured must be a boolean" });
      }

      const updatedCourse = await storage.setCourseFeatured(id, isFeatured);

      if (!updatedCourse) {
        return res.status(404).json({ success: false, error: "Course not found" });
      }

      res.json({ success: true, data: updatedCourse });
    } catch (error: any) {
      console.error('Course feature update error:', error);
      res.status(500).json({ success: false, error: "Failed to update course featured status" });
    }
  });

  // Get Mathematics content (special endpoint for Grade 7 Mathematics)
  app.get("/api/mathematics/content", async (req, res) => {
    try {
      const fs = await import('fs/promises');
      const path = await import('path');
      const filePath = path.join(process.cwd(), 'grade7_mathematics.json');
      
      const data = await fs.readFile(filePath, 'utf8');
      const mathBook = JSON.parse(data);
      
      res.json({ success: true, data: mathBook });
    } catch (error: any) {
      console.error('Mathematics content fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch mathematics content" });
    }
  });

  // Get English content (special endpoint for Grade 7 English)
  app.get("/api/english/content", async (req, res) => {
    try {
      const fs = await import('fs/promises');
      const path = await import('path');
      const filePath = path.join(process.cwd(), 'grade7_english.json');
      
      const data = await fs.readFile(filePath, 'utf8');
      const englishBook = JSON.parse(data);
      
      res.json({ success: true, data: englishBook });
    } catch (error: any) {
      console.error('English content fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch english content" });
    }
  });

  // Get Science content (special endpoint for Grade 7 Science)
  app.get("/api/science/content", async (req, res) => {
    try {
      const fs = await import('fs/promises');
      const path = await import('path');
      const filePath = path.join(process.cwd(), 'grade7_science.json');
      
      const data = await fs.readFile(filePath, 'utf8');
      const scienceBook = JSON.parse(data);
      
      res.json({ success: true, data: scienceBook });
    } catch (error: any) {
      console.error('Science content fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch science content" });
    }
  });

  // Get Social Studies content (special endpoint for Grade 7 Social Studies)
  app.get("/api/social-studies/content", async (req, res) => {
    try {
      const fs = await import('fs/promises');
      const path = await import('path');
      const filePath = path.join(process.cwd(), 'grade7_social_studies.json');
      
      const data = await fs.readFile(filePath, 'utf8');
      const socialStudiesBook = JSON.parse(data);
      
      res.json({ success: true, data: socialStudiesBook });
    } catch (error: any) {
      console.error('Social Studies content fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch social studies content" });
    }
  });

  // Save quiz result for Mathematics
  app.post("/api/mathematics/quiz-result", async (req, res) => {
    try {
      const { lessonId, score, totalQuestions, answers } = req.body;
      
      const authHeader = req.headers.authorization;
      if (!authHeader) {
        return res.status(401).json({ success: false, error: "Authorization required" });
      }

      const session = await db
        .select()
        .from(userLoginSessions)
        .where(and(
          eq(userLoginSessions.sessionId, authHeader.replace('Bearer ', '')),
          eq(userLoginSessions.isActive, true),
          gt(userLoginSessions.expiresAt, new Date())
        ))
        .limit(1);

      if (session.length === 0) {
        return res.status(401).json({ success: false, error: "Invalid session" });
      }

      const userId = session[0].userId;
      
      // Store the result in localStorage on client side for now
      // Could be enhanced to store in database later
      res.json({ success: true, message: "Quiz result processed" });
    } catch (error: any) {
      console.error('Quiz result save error:', error);
      res.status(500).json({ success: false, error: "Failed to save quiz result" });
    }
  });


  // Get lessons for a course
  app.get("/api/courses/:courseId/lessons", async (req, res) => {
    try {
      const { courseId } = req.params;
      
      // Direct PostgreSQL query bypassing Drizzle schema
      const { Client } = await import('pg');
      const client = new Client({
        connectionString: process.env.DATABASE_URL
      });
      
      await client.connect();
      
      const result = await client.query(`
        SELECT id, title, description, course_id, level as "chapterNumber", level as "lessonNumber", 
               content, duration_minutes as duration, 'text' as "contentType", "order" as "orderIndex",
               free_preview_flag as "isPublished"
        FROM lessons 
        WHERE course_id = $1 AND free_preview_flag = true
        ORDER BY "order"
      `, [courseId]);
      
      await client.end();
      
      res.json({ success: true, data: result.rows, totalCount: result.rows.length });
    } catch (error: any) {
      console.error('Course lessons fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch course lessons" });
    }
  });

  // Get specific lesson with progress tracking
  app.get("/api/lessons/:lessonId", async (req, res) => {
    try {
      const { lessonId } = req.params;
      const { userId } = req.query;
      
      // Get lesson details using direct query
      const { Client } = await import('pg');
      const client = new Client({
        connectionString: process.env.DATABASE_URL
      });
      
      await client.connect();
      const lessonResult = await client.query(`
        SELECT id, title, description, subject_id, course_id, level, content, duration_minutes as duration, 'text' as content_type
        FROM lessons WHERE id = $1 LIMIT 1
      `, [lessonId]);
      await client.end();
      
      const lessonData = lessonResult.rows;
      
      if (lessonData.length === 0) {
        return res.status(404).json({ success: false, error: "Lesson not found" });
      }
      
      let userProgress = null;
      if (userId) {
        // Get user's progress for this lesson
        const progressData = await db
          .select()
          .from(studentProgress)
          .where(and(
            eq(studentProgress.userId, userId as string),
            eq(studentProgress.lessonId, lessonId)
          ))
          .limit(1);
        
        userProgress = progressData[0] || null;
      }
      
      res.json({ 
        success: true, 
        data: {
          lesson: lessonData[0],
          progress: userProgress
        }
      });
    } catch (error: any) {
      console.error('Lesson fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch lesson" });
    }
  });

  // TOPICS API ENDPOINTS
  // ====================

  // Get topics for a lesson
  app.get("/api/lessons/:lessonId/topics", async (req, res) => {
    try {
      const { lessonId } = req.params;
      
      const topicsData = await db
        .select()
        .from(topics)
        .where(eq(topics.lessonId, parseInt(lessonId)))
        .orderBy(topics.order, topics.createdAt);
      
      res.json({ 
        success: true, 
        data: topicsData 
      });
    } catch (error: any) {
      console.error('Topics fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch topics" });
    }
  });

  // Get a single topic
  app.get("/api/topics/:topicId", async (req, res) => {
    try {
      const { topicId } = req.params;
      
      const topicData = await db
        .select()
        .from(topics)
        .where(eq(topics.id, parseInt(topicId)))
        .limit(1);
      
      if (topicData.length === 0) {
        return res.status(404).json({ success: false, error: "Topic not found" });
      }
      
      res.json({ 
        success: true, 
        data: topicData[0] 
      });
    } catch (error: any) {
      console.error('Topic fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch topic" });
    }
  });

  // Create a new topic (admin only)
  app.post("/api/topics", requireAuth, async (req, res) => {
    try {
      const { lessonId, title, content, mediaType, mediaUrl, order } = req.body;
      
      if (!lessonId || !title || !content) {
        return res.status(400).json({
          success: false,
          error: 'Missing required fields: lessonId, title, content'
        });
      }

      // Validate media type if provided
      if (mediaType && !['image', 'video'].includes(mediaType)) {
        return res.status(400).json({
          success: false,
          error: 'Invalid media type. Must be "image" or "video"'
        });
      }

      // Validate media URL format if provided
      if (mediaUrl) {
        try {
          new URL(mediaUrl);
        } catch {
          return res.status(400).json({
            success: false,
            error: 'Invalid media URL format'
          });
        }
      }

      // Check if lesson exists
      const lessonExists = await db
        .select()
        .from(lessons)
        .where(eq(lessons.id, lessonId))
        .limit(1);

      if (lessonExists.length === 0) {
        return res.status(404).json({
          success: false,
          error: 'Lesson not found'
        });
      }

      const newTopic = await db
        .insert(topics)
        .values({
          lessonId,
          title,
          content,
          mediaType: mediaType || null,
          mediaUrl: mediaUrl || null,
          order: order || 0
        })
        .returning();
      
      res.status(201).json({ 
        success: true, 
        data: newTopic[0],
        message: 'Topic created successfully'
      });
    } catch (error: any) {
      console.error('Topic creation error:', error);
      res.status(500).json({ 
        success: false, 
        error: "Failed to create topic" 
      });
    }
  });

  // Update a topic (admin only)
  app.put("/api/topics/:topicId", requireAuth, async (req, res) => {
    try {
      const { topicId } = req.params;
      const { title, content, mediaType, mediaUrl, order } = req.body;

      // Validate media type if provided
      if (mediaType && !['image', 'video'].includes(mediaType)) {
        return res.status(400).json({
          success: false,
          error: 'Invalid media type. Must be "image" or "video"'
        });
      }

      // Validate media URL format if provided
      if (mediaUrl) {
        try {
          new URL(mediaUrl);
        } catch {
          return res.status(400).json({
            success: false,
            error: 'Invalid media URL format'
          });
        }
      }

      const updateData: any = { updatedAt: new Date() };
      if (title !== undefined) updateData.title = title;
      if (content !== undefined) updateData.content = content;
      if (mediaType !== undefined) updateData.mediaType = mediaType;
      if (mediaUrl !== undefined) updateData.mediaUrl = mediaUrl;
      if (order !== undefined) updateData.order = order;

      const updatedTopic = await db
        .update(topics)
        .set(updateData)
        .where(eq(topics.id, parseInt(topicId)))
        .returning();

      if (updatedTopic.length === 0) {
        return res.status(404).json({ 
          success: false, 
          error: 'Topic not found' 
        });
      }

      res.json({ 
        success: true, 
        data: updatedTopic[0],
        message: 'Topic updated successfully'
      });
    } catch (error: any) {
      console.error('Topic update error:', error);
      res.status(500).json({ 
        success: false, 
        error: "Failed to update topic" 
      });
    }
  });

  // Delete a topic (admin only)
  app.delete("/api/topics/:topicId", requireAuth, async (req, res) => {
    try {
      const { topicId } = req.params;

      const deletedTopic = await db
        .delete(topics)
        .where(eq(topics.id, parseInt(topicId)))
        .returning();

      if (deletedTopic.length === 0) {
        return res.status(404).json({ 
          success: false, 
          error: 'Topic not found' 
        });
      }

      res.json({ 
        success: true, 
        message: 'Topic deleted successfully'
      });
    } catch (error: any) {
      console.error('Topic deletion error:', error);
      res.status(500).json({ 
        success: false, 
        error: "Failed to delete topic" 
      });
    }
  });

  // SCHEDULING SYSTEM API ENDPOINTS
  // ===============================

  // Get teacher availability
  app.get("/api/teachers/:teacherId/availability", async (req, res) => {
    try {
      const { teacherId } = req.params;
      
      const availability = await db
        .select()
        .from(teacherAvailability)
        .where(and(
          eq(teacherAvailability.teacherId, teacherId),
          eq(teacherAvailability.isActive, true)
        ))
        .orderBy(teacherAvailability.dayOfWeek, teacherAvailability.startTime);
      
      res.json({ 
        success: true, 
        data: availability 
      });
    } catch (error: any) {
      console.error('Fetch teacher availability error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch teacher availability" });
    }
  });

  // Set/Update teacher availability (teacher only)
  app.post("/api/teachers/:teacherId/availability", requireAuth, async (req, res) => {
    try {
      const { teacherId } = req.params;
      const { dayOfWeek, startTime, endTime, timeZone, isRecurring, specificDate, subjectId } = req.body;
      
      if (dayOfWeek === undefined || !startTime || !endTime) {
        return res.status(400).json({
          success: false,
          error: 'Missing required fields: dayOfWeek, startTime, endTime'
        });
      }

      const newAvailability = await db
        .insert(teacherAvailability)
        .values({
          teacherId,
          dayOfWeek,
          startTime,
          endTime,
          timeZone: timeZone || 'UTC',
          isRecurring: isRecurring !== false,
          specificDate: specificDate ? new Date(specificDate) : null
        })
        .returning();
      
      res.status(201).json({ 
        success: true, 
        data: newAvailability[0],
        message: 'Availability slot created successfully'
      });
    } catch (error: any) {
      console.error('Create teacher availability error:', error);
      res.status(500).json({ 
        success: false, 
        error: "Failed to create availability slot" 
      });
    }
  });

  // Delete teacher availability slot
  app.delete("/api/teachers/availability/:slotId", requireAuth, async (req, res) => {
    try {
      const { slotId } = req.params;

      const deletedSlot = await db
        .delete(teacherAvailability)
        .where(eq(teacherAvailability.id, slotId))
        .returning();

      if (deletedSlot.length === 0) {
        return res.status(404).json({ 
          success: false, 
          error: 'Availability slot not found' 
        });
      }

      res.json({ 
        success: true, 
        message: 'Availability slot deleted successfully'
      });
    } catch (error: any) {
      console.error('Delete availability slot error:', error);
      res.status(500).json({ 
        success: false, 
        error: "Failed to delete availability slot" 
      });
    }
  });

  // Teacher availability settings (complete form)
  app.get("/api/teacher/availability/:userId", requireAuth, async (req, res) => {
    try {
      const { userId } = req.params;

      // Get teacher's availability settings from profile
      const profile = await db.select()
        .from(profiles)
        .where(eq(profiles.userId, userId))
        .limit(1);

      if (profile.length === 0) {
        return res.status(404).json({ success: false, error: 'Profile not found' });
      }

      // Parse availability settings or return default values
      const availabilityData = profile[0].availabilitySettings ? 
        JSON.parse(profile[0].availabilitySettings) : {
          timezone: '',
          weeklyAvailability: {
            Monday: false,
            Tuesday: false,
            Wednesday: false,
            Thursday: false,
            Friday: false,
            Saturday: false,
            Sunday: false
          },
          startTime: '09:00',
          endTime: '17:00'
        };

      res.json({ 
        success: true, 
        availability: availabilityData 
      });
    } catch (error: any) {
      console.error('Get teacher availability settings error:', error);
      res.status(500).json({ success: false, error: "Failed to get availability settings" });
    }
  });

  // Save teacher availability settings (complete form)
  app.post("/api/teacher/availability/:userId", requireAuth, async (req, res) => {
    try {
      const { userId } = req.params;
      const availabilityData = req.body;

      // Validate the data structure
      if (!availabilityData.timezone || !availabilityData.weeklyAvailability || 
          !availabilityData.startTime || !availabilityData.endTime) {
        return res.status(400).json({ 
          success: false, 
          error: 'Missing required availability data' 
        });
      }

      // Update the profile with the availability settings
      await db.update(profiles)
        .set({ 
          availabilitySettings: JSON.stringify(availabilityData),
          updatedAt: new Date()
        })
        .where(eq(profiles.userId, userId));

      res.json({ 
        success: true, 
        message: 'Availability settings updated successfully'
      });
    } catch (error: any) {
      console.error('Save teacher availability settings error:', error);
      res.status(500).json({ success: false, error: "Failed to save availability settings" });
    }
  });

  // Get all appointments for a user (teacher or student)
  app.get("/api/appointments/:userId", requireAuth, async (req, res) => {
    try {
      const { userId } = req.params;
      const { status, from, to } = req.query;
      
      // Use raw SQL to match actual database structure
      let baseQuery = sql`
        SELECT 
          a.id,
          a.title,
          a.description,
          a.start_date as "scheduledAt",
          a.end_date,
          a.teacher_id as "teacherId",
          a.student_id as "studentId",
          a.status,
          a.subject,
          a.meeting_url as "meetingLink",
          a.notes,
          a.created_at as "createdAt",
          EXTRACT(EPOCH FROM (a.end_date - a.start_date)) / 60 as duration,
          'paid' as "paymentStatus",
          t.name as "teacherName",
          s.name as "studentName"
        FROM appointments a
        LEFT JOIN profiles t ON a.teacher_id = t.user_id
        LEFT JOIN profiles s ON a.student_id = s.user_id
        WHERE (a.teacher_id = ${userId} OR a.student_id = ${userId})
      `;

      let conditions = [];
      let params = [userId];
      
      if (status) {
        conditions.push(`a.status = '${status}'`);
      }

      if (from && to) {
        conditions.push(`a.start_date BETWEEN '${from}' AND '${to}'`);
      }

      if (conditions.length > 0) {
        baseQuery = sql`${baseQuery} AND ${sql.raw(conditions.join(' AND '))}`;
      }

      baseQuery = sql`${baseQuery} ORDER BY a.start_date DESC`;

      const result = await db.execute(baseQuery);
      
      // Handle different result structures
      const appointmentsData = result.rows || result || [];
      
      res.json({ 
        success: true, 
        data: appointmentsData 
      });
    } catch (error: any) {
      console.error('Fetch appointments error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch appointments" });
    }
  });

  // Book an appointment (student books with teacher)
  app.post("/api/appointments", requireAuth, async (req, res) => {
    try {
      const { teacherId, studentId, subject, description, scheduledAt, duration, price } = req.body;
      
      if (!teacherId || !studentId || !scheduledAt) {
        return res.status(400).json({
          success: false,
          error: 'Missing required fields: teacherId, studentId, scheduledAt'
        });
      }

      const startDate = new Date(scheduledAt);
      const endDate = new Date(startDate.getTime() + (duration || 60) * 60000); // Add duration in milliseconds

      // Check if the slot is available (no existing appointment at this time)
      const existingAppointment = await db.execute(
        sql`
          SELECT * FROM appointments 
          WHERE teacher_id = ${teacherId} 
          AND start_date = ${startDate.toISOString()}
          AND status != 'cancelled'
          LIMIT 1
        `
      );

      if (existingAppointment && existingAppointment.length > 0) {
        return res.status(409).json({
          success: false,
          error: 'This time slot is already booked'
        });
      }
      
      const newAppointment = await db.execute(
        sql`
          INSERT INTO appointments (
            title, 
            start_date, 
            end_date, 
            teacher_id, 
            student_id, 
            requester_id,
            status, 
            type,
            subject,
            description
          ) VALUES (
            ${`Tutoring Session`},
            ${startDate.toISOString()},
            ${endDate.toISOString()},
            ${teacherId},
            ${studentId},
            ${studentId},
            ${'pending'},
            ${'virtual'},
            ${subject || 'General'},
            ${description || ''}
          )
          RETURNING *
        `
      );
      
      res.status(201).json({ 
        success: true, 
        data: newAppointment && newAppointment.length > 0 ? newAppointment[0] : {},
        message: 'Appointment booked successfully'
      });
    } catch (error: any) {
      console.error('Book appointment error:', error);
      res.status(500).json({ 
        success: false, 
        error: "Failed to book appointment" 
      });
    }
  });

  // Update appointment status
  app.put("/api/appointments/:appointmentId", requireAuth, async (req, res) => {
    try {
      const { appointmentId } = req.params;
      const { status, notes, meetingLink } = req.body;

      const updateData: any = { updatedAt: new Date() };
      if (status !== undefined) updateData.status = status;
      if (notes !== undefined) updateData.notes = notes;
      if (meetingLink !== undefined) updateData.meetingLink = meetingLink;

      const updatedAppointment = await db
        .update(appointments)
        .set(updateData)
        .where(eq(appointments.id, appointmentId))
        .returning();

      if (updatedAppointment.length === 0) {
        return res.status(404).json({ 
          success: false, 
          error: 'Appointment not found' 
        });
      }

      res.json({ 
        success: true, 
        data: updatedAppointment[0],
        message: 'Appointment updated successfully'
      });
    } catch (error: any) {
      console.error('Update appointment error:', error);
      res.status(500).json({ 
        success: false, 
        error: "Failed to update appointment" 
      });
    }
  });

  // Cancel appointment
  app.delete("/api/appointments/:appointmentId", requireAuth, async (req, res) => {
    try {
      const { appointmentId } = req.params;

      const updatedAppointment = await db
        .update(appointments)
        .set({ 
          status: 'cancelled',
          updatedAt: new Date()
        })
        .where(eq(appointments.id, appointmentId))
        .returning();

      if (updatedAppointment.length === 0) {
        return res.status(404).json({ 
          success: false, 
          error: 'Appointment not found' 
        });
      }

      res.json({ 
        success: true, 
        data: updatedAppointment[0],
        message: 'Appointment cancelled successfully'
      });
    } catch (error: any) {
      console.error('Cancel appointment error:', error);
      res.status(500).json({ 
        success: false, 
        error: "Failed to cancel appointment" 
      });
    }
  });

  // Approve or decline appointment (teacher action)
  app.patch("/api/appointments/:appointmentId/status", requireAuth, async (req, res) => {
    try {
      const { appointmentId } = req.params;
      const { action, meetingLink } = req.body; // action: 'approve' or 'decline'
      
      if (!action || !['approve', 'decline'].includes(action)) {
        return res.status(400).json({
          success: false,
          error: 'Invalid action. Must be "approve" or "decline"'
        });
      }

      const newStatus = action === 'approve' ? 'confirmed' : 'cancelled';
      
      // Get appointment details first
      const appointment = await db.select()
        .from(appointments)
        .where(eq(appointments.id, appointmentId))
        .limit(1);

      if (appointment.length === 0) {
        return res.status(404).json({
          success: false,
          error: 'Appointment not found'
        });
      }

      // Update appointment with new status and optional meeting link
      const updateData: any = { 
        status: newStatus,
        updatedAt: new Date()
      };
      
      if (meetingLink && action === 'approve') {
        updateData.meetingUrl = meetingLink;
      }

      const updatedAppointment = await db
        .update(appointments)
        .set(updateData)
        .where(eq(appointments.id, appointmentId))
        .returning();

      // If appointment is approved, automatically create chat thread
      if (action === 'approve') {
        try {
          const teacherId = appointment[0].teacherId;
          const studentId = appointment[0].studentId;
          
          // Get teacher and student profile UUIDs for message creation
          const teacherProfile = await db.select({ id: profiles.id, name: profiles.name })
            .from(profiles)
            .where(eq(profiles.userId, teacherId))
            .limit(1);

          const studentProfile = await db.select({ id: profiles.id, name: profiles.name })
            .from(profiles)
            .where(eq(profiles.userId, studentId))
            .limit(1);

          if (teacherProfile.length > 0 && studentProfile.length > 0) {
            // Create initial chat message from teacher
            const initialMessage = `Hi ${studentProfile[0].name}! Your appointment request has been approved. This chat thread has been created for our lesson. Looking forward to working with you!`;
            
            await db.insert(messages).values({
              senderId: teacherProfile[0].id,
              receiverId: studentProfile[0].id,
              content: initialMessage,
              messageType: 'text',
              isRead: false,
              deliveredAt: new Date(),
              createdAt: new Date()
            });

            console.log(`ðŸ’¬ Auto-created chat thread for approved appointment ${appointmentId}`);

            // Send real-time notification to student via WebSocket if connected
            const wss = (global as any).wss;
            const studentTextId = await getTextIdByProfileUuid(studentProfile[0].id);
            if (wss && studentTextId) {
              const studentWs = wss.userConnections?.get(studentTextId);
              if (studentWs && studentWs.readyState === 1) { // WebSocket.OPEN = 1
                studentWs.send(JSON.stringify({
                  type: 'appointment_approved',
                  data: {
                    appointmentId,
                    message: 'Your appointment has been approved and a chat thread has been created!',
                    chatEnabled: true
                  }
                }));
              }
            }
          }
        } catch (chatError) {
          console.error('Error creating chat thread for approved appointment:', chatError);
          // Don't fail the appointment approval if chat creation fails
        }
      }

      // Send notification to student about appointment status change
      try {
        const wss = (global as any).wss;
        // Get student profile UUID first, then convert to text ID
        const studentProfile = await db.select({ id: profiles.id })
          .from(profiles)
          .where(eq(profiles.userId, appointment[0].studentId))
          .limit(1);
        
        if (studentProfile.length > 0) {
          const studentTextId = await getTextIdByProfileUuid(studentProfile[0].id);
          if (wss && studentTextId) {
            const studentWs = wss.userConnections?.get(studentTextId);
            if (studentWs && studentWs.readyState === 1) {
              studentWs.send(JSON.stringify({
                type: 'appointment_status_update',
                data: {
                  appointmentId,
                  status: newStatus,
                  message: `Your appointment has been ${action}d by the teacher`
                }
              }));
            }
          }
        }
      } catch (notificationError) {
        console.error('Error sending appointment notification:', notificationError);
      }
      
      res.json({ 
        success: true, 
        message: `Appointment ${action}d successfully${action === 'approve' ? ' and chat thread created' : ''}`,
        appointment: updatedAppointment[0]
      });
    } catch (error: any) {
      console.error('Update appointment status error:', error);
      res.status(500).json({ success: false, error: "Failed to update appointment status" });
    }
  });

  // Get all teachers with their availability settings (for students to book)
  app.get("/api/teachers/available-with-settings", async (req, res) => {
    try {
      // Simple query first to check basic functionality
      const allTeachers = await db
        .select()
        .from(profiles)
        .where(eq(profiles.role, 'teacher'));

      console.log('Found teachers:', allTeachers.length);

      // Filter for teachers with availability settings
      const teachers = allTeachers.filter(teacher => 
        teacher.status === 'active' && teacher.availabilitySettings
      );

      console.log('Teachers with availability:', teachers.length);

      // Parse availability settings for each teacher
      const teachersWithAvailability = teachers.map(teacher => {
        let availability = null;
        try {
          availability = teacher.availabilitySettings ? JSON.parse(teacher.availabilitySettings) : null;
        } catch (error: any) {
          console.error('Error parsing availability settings for teacher:', teacher.id, error);
        }
        
        return {
          id: teacher.userId, // Use userId (which references users.id) instead of profile id
          name: teacher.name,
          email: teacher.email,
          avatarUrl: teacher.avatarUrl,
          availability: availability
        };
      }).filter(teacher => teacher.availability !== null);

      console.log('Final teachers with parsed availability:', teachersWithAvailability.length);

      res.json({ success: true,
        success: true,
        data: teachersWithAvailability
      });
    } catch (error: any) {
      console.error('Get available teachers with settings error:', error);
      res.status(500).json({ success: false, error: "Failed to get available teachers" });
    }
  });

  // Get available teachers for booking (legacy)
  app.get("/api/teachers/available", async (req, res) => {
    try {
      const { subject, day, time } = req.query;
      
      // Get teachers with availability
      let query = db
        .select({
          teacherId: teacherAvailability.teacherId,
          teacherName: profiles.name,
          teacherEmail: profiles.email,
          avatarUrl: profiles.avatarUrl,
          dayOfWeek: teacherAvailability.dayOfWeek,
          startTime: teacherAvailability.startTime,
          endTime: teacherAvailability.endTime,
          timeZone: teacherAvailability.timeZone
        })
        .from(teacherAvailability)
        .innerJoin(profiles, eq(teacherAvailability.teacherId, profiles.userId))
        .where(and(
          eq(teacherAvailability.isActive, true),
          eq(profiles.role, 'teacher'),
          eq(profiles.status, 'active')
        ));

      if (day !== undefined) {
        query = query.where(and(
          eq(teacherAvailability.isActive, true),
          eq(teacherAvailability.dayOfWeek, parseInt(day as string))
        ));
      }

      const availableTeachers = await query;
      
      res.json({ 
        success: true, 
        data: availableTeachers 
      });
    } catch (error: any) {
      console.error('Fetch available teachers error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch available teachers" });
    }
  });

  // Update lesson progress (more specific than general subject progress)
  app.post("/api/lessons/:lessonId/progress", async (req, res) => {
    try {
      const { lessonId } = req.params;
      const { progressPercentage, timeSpent, completed } = req.body;
      
      const authHeader = req.headers.authorization;
      if (!authHeader) {
        return res.status(401).json({ success: false, error: "Authorization required" });
      }

      const session = await db
        .select()
        .from(userLoginSessions)
        .where(and(
          eq(userLoginSessions.sessionId, authHeader.replace('Bearer ', '')),
          eq(userLoginSessions.isActive, true),
          gt(userLoginSessions.expiresAt, new Date())
        ))
        .limit(1);

      if (session.length === 0) {
        return res.status(401).json({ success: false, error: "Invalid session" });
      }

      const userId = session[0].userId;

      // Get lesson using direct query
      const { Client } = await import('pg');
      const client2 = new Client({
        connectionString: process.env.DATABASE_URL
      });
      
      await client2.connect();
      const lessonResult2 = await client2.query(`
        SELECT id, subject_id, course_id FROM lessons WHERE id = $1 LIMIT 1
      `, [lessonId]);
      await client2.end();
      
      const lesson = lessonResult2.rows;

      if (lesson.length === 0) {
        return res.status(404).json({ success: false, error: "Lesson not found" });
      }

      // Check if progress already exists
      const existing = await db
        .select()
        .from(studentProgress)
        .where(and(
          eq(studentProgress.userId, userId),
          eq(studentProgress.lessonId, lessonId)
        ))
        .limit(1);

      const updateData = {
        progressPercentage: progressPercentage ?? (existing[0]?.progressPercentage || 0),
        timeSpent: (existing[0]?.timeSpent || 0) + (timeSpent || 0),
        completedAt: completed || progressPercentage === 100 ? new Date() : existing[0]?.completedAt,
        lastAccessedAt: new Date(),
        updatedAt: new Date()
      };

      if (existing.length > 0) {
        // Update existing progress
        await db
          .update(studentProgress)
          .set(updateData)
          .where(eq(studentProgress.id, existing[0].id));
      } else {
        // Create new progress
        await db.insert(studentProgress).values({
          userId,
          lessonId,
          subjectId: lesson[0].subjectId || null,
          courseId: lesson[0].courseId || null,
          ...updateData
        });
      }

      res.json({ success: true, message: "Lesson progress updated successfully" });
    } catch (error: any) {
      console.error('Lesson progress update error:', error);
      res.status(500).json({ success: false, error: "Failed to update lesson progress" });
    }
  });

  // Check user's lesson access limits (for free users)
  app.get("/api/users/:userId/lesson-access", async (req, res) => {
    try {
      const { userId } = req.params;
      const { subjectId, courseId } = req.query;
      
      // Get user's subscription info
      const userProfile = await db
        .select()
        .from(profiles)
        .where(eq(profiles.userId, userId))
        .limit(1);
      
      if (userProfile.length === 0) {
        return res.status(404).json({ success: false, error: "User not found" });
      }
      
      const profile = userProfile[0];
      const currentTime = new Date();
      
      // Check if user has active premium subscription
      const hasActivePremium = profile.plan && 
        profile.plan !== '' && 
        profile.planExpiry && 
        profile.planExpiry > currentTime;
      
      if (hasActivePremium) {
        return res.json({ 
          success: true, 
          hasAccess: true, 
          isPremium: true,
          message: "Full access with premium subscription"
        });
      }
      
      // For free users, check lesson limits
      const educationLevel = profile.educationLevel?.toLowerCase();
      
      if (educationLevel === 'college' || educationLevel === 'university') {
        // College/University: preview-only
        return res.json({ 
          success: true, 
          hasAccess: false,
          isPremium: false,
          limitType: 'preview',
          message: "College/University courses require premium subscription"
        });
      }
      
      // Primary/High School: 2 lessons per subject
      if (subjectId) {
        const accessedLessons = await db
          .select({ count: count() })
          .from(studentProgress)
          .where(and(
            eq(studentProgress.userId, userId),
            eq(studentProgress.subjectId, subjectId),
            isNotNull(studentProgress.lessonId)
          ));
        
        const accessCount = accessedLessons[0]?.count || 0;
        const hasAccess = accessCount < 2;
        
        return res.json({ 
          success: true, 
          hasAccess,
          isPremium: false,
          limitType: 'lesson_count',
          accessedCount: accessCount,
          maxLessons: 2,
          message: hasAccess 
            ? `You have ${2 - accessCount} free lessons remaining for this subject`
            : "You've used all free lessons for this subject. Upgrade to premium for unlimited access."
        });
      }
      
      res.json({ 
        success: true, 
        hasAccess: true,
        isPremium: false,
        message: "Free access available"
      });
      
    } catch (error: any) {
      console.error('Lesson access check error:', error);
      res.status(500).json({ success: false, error: "Failed to check lesson access" });
    }
  });


  // LMS Dashboard API Endpoints


  // Get enrolled courses for university students
  app.get("/api/courses/enrolled/:userId", async (req, res) => {
    try {
      const { userId } = req.params;

      const enrolledCourses = await db
        .select({
          id: courses.id,
          title: courses.title,
          description: courses.description,
          courseCode: courses.courseCode,
          credits: courses.credits,
          duration: courses.duration,
          thumbnailUrl: courses.thumbnailUrl,
          progress: courseEnrollments.progress,
          instructor: sql`'Dr. Smith'`.as('instructor') // Placeholder for now
        })
        .from(courseEnrollments)
        .innerJoin(courses, eq(courseEnrollments.courseId, courses.id))
        .where(
          and(
            eq(courseEnrollments.userId, userId),
            eq(courseEnrollments.isActive, true)
          )
        )
        .orderBy(desc(courseEnrollments.enrolledAt));

      res.json({ success: true, data: enrolledCourses });
    } catch (error: any) {
      console.error('Enrolled courses fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch enrolled courses" });
    }
  });

  // Get continue watching lessons
  app.get("/api/lessons/continue-watching/:userId", async (req, res) => {
    try {
      const { userId } = req.params;

      const continueLessons = await db
        .select({
          id: lessons.id,
          title: lessons.title,
          description: lessons.description,
          duration: lessons.durationMinutes,
          contentType: lessons.contentType,
          progress: studentProgress.progressPercentage,
          isCompleted: sql`${studentProgress.progressPercentage} = 100`.as('isCompleted'),
          lastAccessedAt: studentProgress.lastAccessedAt
        })
        .from(studentProgress)
        .innerJoin(lessons, eq(studentProgress.lessonId, lessons.id))
        .where(
          and(
            eq(studentProgress.userId, userId),
            gt(studentProgress.progressPercentage, 0),
            lt(studentProgress.progressPercentage, 100)
          )
        )
        .orderBy(desc(studentProgress.lastAccessedAt))
        .limit(6);

      res.json({ success: true, data: continueLessons });
    } catch (error: any) {
      console.error('Continue watching fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch continue watching lessons" });
    }
  });

  // Get available teachers/mentors
  app.get("/api/teachers/available", async (req, res) => {
    try {
      const teachers = await db
        .select({
          id: profiles.id,
          name: profiles.name,
          subject: sql`'Mathematics'`.as('subject'), // Placeholder
          avatarUrl: profiles.avatarUrl,
          rating: sql`4.5`.as('rating'), // Placeholder
          isOnline: sql`true`.as('isOnline') // Placeholder
        })
        .from(profiles)
        .where(eq(profiles.role, 'teacher'))
        .limit(10);

      res.json({ success: true, data: teachers });
    } catch (error: any) {
      console.error('Teachers fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch teachers" });
    }
  });

  // Get student statistics
  app.get("/api/student/statistics/:userId", async (req, res) => {
    try {
      const { userId } = req.params;

      const stats = await db
        .select({
          totalLessons: count(studentProgress.id),
          completedLessons: sql`COUNT(CASE WHEN ${studentProgress.progressPercentage} = 100 THEN 1 END)`.as('completedLessons'),
          timeSpent: sum(studentProgress.timeSpent),
          averageScore: avg(studentProgress.score)
        })
        .from(studentProgress)
        .where(eq(studentProgress.userId, userId));

      const result = stats[0] || {
        totalLessons: 0,
        completedLessons: 0,
        timeSpent: 0,
        averageScore: 0
      };

      res.json({ success: true, data: result });
    } catch (error: any) {
      console.error('Student statistics fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch student statistics" });
    }
  });


  // Create sample lessons and courses for demo
  app.post("/api/demo/seed", async (req, res) => {
    try {
      // Create sample lessons
      const sampleLessons = [
        {
          title: "Introduction to Algebra",
          description: "Learn the basics of algebraic expressions and equations",
          subjectId: null,
          courseId: null,
          chapterNumber: 1,
          lessonNumber: 1,
          contentType: "text",
          content: "Algebra is a branch of mathematics dealing with symbols and the rules for manipulating those symbols.",
          duration: 45,
          isPublished: true,
          orderIndex: 1
        },
        {
          title: "Linear Equations",
          description: "Solve linear equations with one variable",
          subjectId: null,
          courseId: null,
          chapterNumber: 1,
          lessonNumber: 2,
          contentType: "video",
          content: "A linear equation is an equation that makes a straight line when it is graphed.",
          videoUrl: "https://example.com/linear-equations.mp4",
          duration: 30,
          isPublished: true,
          orderIndex: 2
        },
        {
          title: "Quadratic Functions",
          description: "Understanding parabolas and quadratic equations",
          subjectId: null,
          courseId: null,
          chapterNumber: 2,
          lessonNumber: 1,
          contentType: "interactive",
          content: "Quadratic functions form parabolas when graphed and have the form y = axÂ² + bx + c.",
          duration: 60,
          isPublished: true,
          orderIndex: 3
        }
      ];

      await db.insert(lessons).values(sampleLessons);

      // Create sample courses
      const sampleCourses = [
        {
          title: "Advanced Mathematics",
          description: "Comprehensive course covering algebra, geometry, and calculus",
          courseCode: "MATH301",
          credits: 4,
          duration: 16,
          difficulty: "advanced",
          prerequisites: ["MATH201", "MATH202"],
          learningObjectives: ["Master advanced algebraic concepts", "Understand geometric proofs", "Apply calculus to real-world problems"],
          price: "299.99"
        },
        {
          title: "Computer Science Fundamentals",
          description: "Introduction to programming, algorithms, and data structures",
          courseCode: "CS101",
          credits: 3,
          duration: 12,
          difficulty: "beginner",
          prerequisites: [],
          learningObjectives: ["Learn basic programming concepts", "Understand algorithms", "Work with data structures"],
          price: "199.99"
        }
      ];

      await db.insert(courses).values(sampleCourses);

      // Create a sample banner
      const sampleBanner = {
        title: "Welcome to EduFiliova LMS",
        content: "Start your learning journey today with our comprehensive courses and expert instructors!",
        bannerType: "announcement",
        backgroundColor: "#3b82f6",
        textColor: "#ffffff",
        targetAudience: "all",
        createdBy: "system",
        isActive: true
      };

      await db.insert(banners).values(sampleBanner);

      res.json({ success: true, message: "Demo data seeded successfully" });
    } catch (error: any) {
      console.error('Demo seed error:', error);
      res.status(500).json({ success: false, error: "Failed to seed demo data" });
    }
  });

  // Subscription status endpoint
  app.get('/api/subscription-status', async (req, res) => {
    try {
      // Check if user is logged in via session
      const sessionId = req.headers['x-session-id'] || req.cookies.sessionId;
      if (!sessionId) {
        return res.status(401).json({ success: false, error: 'Not authenticated' });
      }

      // Get user from session
      const userSession = await db.select()
        .from(userLoginSessions)
        .where(and(
          eq(userLoginSessions.sessionId, sessionId),
          eq(userLoginSessions.isActive, true),
          gt(userLoginSessions.expiresAt, new Date())
        ))
        .limit(1);

      if (userSession.length === 0) {
        return res.status(401).json({ success: false, error: 'Invalid session' });
      }

      // Get user profile
      const userProfile = await db.select()
        .from(profiles)
        .where(eq(profiles.userId, userSession[0].userId))
        .limit(1);

      if (userProfile.length === 0) {
        return res.status(404).json({ success: false, error: 'Profile not found' });
      }

      const profile = userProfile[0];
      const hasActiveSubscription = profile.stripeSubscriptionId !== null;

      if (!hasActiveSubscription) {
        return res.json({ success: true,
          success: true,
          hasActiveSubscription: false,
          subscriptionStatus: 'inactive',
          message: 'No active subscription found'
        });
      }

      // If Stripe is configured, get subscription details
      if (stripe && profile.stripeSubscriptionId) {
        try {
          const subscription = await stripe.subscriptions.retrieve(profile.stripeSubscriptionId);
          return res.json({ success: true,
            success: true,
            hasActiveSubscription: subscription.status === 'active',
            subscriptionStatus: subscription.status,
            currentPeriodEnd: subscription.current_period_end,
            cancelAtPeriodEnd: subscription.cancel_at_period_end,
            priceId: subscription.items.data[0]?.price.id
          });
        } catch (stripeError) {
          console.error('Stripe subscription fetch error:', stripeError);
          return res.json({ success: true,
            success: true,
            hasActiveSubscription: false,
            subscriptionStatus: 'error',
            message: 'Could not verify subscription status'
          });
        }
      }

      return res.json({ success: true,
        success: true,
        hasActiveSubscription: true,
        subscriptionStatus: 'active',
        message: 'Subscription active (Stripe not configured)'
      });

    } catch (error: any) {
      console.error('Subscription status error:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to fetch subscription status' 
      });
    }
  });

  // Cancel subscription endpoint
  app.post('/api/cancel-subscription', async (req, res) => {
    try {
      // Check if user is logged in via session
      const sessionId = req.headers['x-session-id'] || req.cookies.sessionId;
      if (!sessionId) {
        return res.status(401).json({ success: false, error: 'Not authenticated' });
      }

      // Get user from session
      const userSession = await db.select()
        .from(userLoginSessions)
        .where(and(
          eq(userLoginSessions.sessionId, sessionId),
          eq(userLoginSessions.isActive, true),
          gt(userLoginSessions.expiresAt, new Date())
        ))
        .limit(1);

      if (userSession.length === 0) {
        return res.status(401).json({ success: false, error: 'Invalid session' });
      }

      // Get user profile
      const userProfile = await db.select()
        .from(profiles)
        .where(eq(profiles.userId, userSession[0].userId))
        .limit(1);

      if (userProfile.length === 0) {
        return res.status(404).json({ success: false, error: 'Profile not found' });
      }

      const profile = userProfile[0];

      // Get user email for notification
      const userRecord = await db.select()
        .from(users)
        .where(eq(users.id, userSession[0].userId))
        .limit(1);
      const userEmail = userRecord[0]?.email;
      const userName = profile.fullName || profile.username || 'User';

      // Get plan name based on subscription tier
      const planNameMap: Record<string, string> = {
        'elementary': 'Elementary Plan',
        'high_school': 'High School Plan',
        'college_university': 'College/University Plan'
      };
      const planName = planNameMap[profile.subscriptionTier || ''] || 'Premium Plan';

      // Check if user has any active subscription (either Stripe or tier-based)
      const hasStripeSubscription = !!profile.stripeSubscriptionId;
      const hasTierSubscription = ['elementary', 'high_school', 'college_university'].includes(profile.subscriptionTier || '');

      if (!hasStripeSubscription && !hasTierSubscription) {
        return res.status(400).json({ 
          success: false, 
          error: 'No active subscription to cancel' 
        });
      }

      // If user has a Stripe subscription, cancel it via Stripe
      if (hasStripeSubscription && stripe) {
        try {
          const subscription = await stripe.subscriptions.update(
            profile.stripeSubscriptionId!,
            { cancel_at_period_end: true }
          );

          // Send cancellation email
          if (userEmail) {
            try {
              const { sendSubscriptionCancellationEmail } = await import('./email.js');
              const expiryDate = subscription.current_period_end 
                ? new Date(subscription.current_period_end * 1000).toISOString()
                : profile.planExpiry;
              await sendSubscriptionCancellationEmail(userEmail, userName, planName, expiryDate);
            } catch (emailError) {
              console.error('Failed to send cancellation email:', emailError);
            }
          }

          return res.json({ success: true,
            success: true,
            message: 'Subscription will be cancelled at the end of your current billing period',
            cancelAtPeriodEnd: subscription.cancel_at_period_end,
            currentPeriodEnd: subscription.current_period_end
          });
        } catch (stripeError) {
          console.error('Stripe cancellation error:', stripeError);
          return res.status(500).json({
            success: false,
            error: 'Failed to cancel subscription with payment provider'
          });
        }
      }

      // Handle tier-based subscriptions without Stripe (e.g., PayPal, voucher-based, or manual)
      if (hasTierSubscription && !hasStripeSubscription) {
        try {
          const expiryDate = profile.planExpiry ? new Date(profile.planExpiry).toLocaleDateString() : 'the end of your billing period';
          
          // Mark subscription as cancelled but keep tier active until planExpiry
          // User retains benefits until the end of their billing period
          await db.update(profiles)
            .set({ 
              subscriptionCancelledAt: new Date(),
              updatedAt: new Date()
            })
            .where(eq(profiles.userId, userSession[0].userId));

          // Send cancellation email
          if (userEmail) {
            try {
              const { sendSubscriptionCancellationEmail } = await import('./email.js');
              await sendSubscriptionCancellationEmail(userEmail, userName, planName, profile.planExpiry);
            } catch (emailError) {
              console.error('Failed to send cancellation email:', emailError);
            }
          }

          return res.json({ success: true,
            success: true,
            message: 'Your subscription has been cancelled successfully.',
            cancelAtPeriodEnd: true,
            currentPeriodEnd: profile.planExpiry ? Math.floor(new Date(profile.planExpiry).getTime() / 1000) : null
          });
        } catch (error) {
          console.error('Tier subscription cancellation error:', error);
          return res.status(500).json({
            success: false,
            error: 'Failed to cancel subscription'
          });
        }
      }

      return res.status(500).json({
        success: false,
        error: 'Payment provider not configured'
      });

    } catch (error: any) {
      console.error('Cancel subscription error:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to cancel subscription' 
      });
    }
  });

  // Update profile endpoint
  app.put('/api/profile/update', async (req, res) => {
    try {
      const { name, age, grade, country, educationLevel } = req.body;

      // Check if user is logged in via session
      const sessionId = req.headers['x-session-id'] || req.cookies.sessionId;
      if (!sessionId) {
        return res.status(401).json({ success: false, error: 'Not authenticated' });
      }

      // Get user from session
      const userSession = await db.select()
        .from(userLoginSessions)
        .where(and(
          eq(userLoginSessions.sessionId, sessionId),
          eq(userLoginSessions.isActive, true),
          gt(userLoginSessions.expiresAt, new Date())
        ))
        .limit(1);

      if (userSession.length === 0) {
        return res.status(401).json({ success: false, error: 'Invalid session' });
      }

      // Validate input
      if (!name || !age || !grade || !country) {
        return res.status(400).json({ 
          success: false, 
          error: 'Missing required fields' 
        });
      }

      // Update profile
      const updatedProfile = await db.update(profiles)
        .set({
          name,
          age: parseInt(age),
          grade: parseInt(grade),
          country,
          educationLevel: educationLevel || 'grade',
          updatedAt: new Date()
        })
        .where(eq(profiles.userId, userSession[0].userId))
        .returning();

      if (updatedProfile.length === 0) {
        return res.status(404).json({ 
          success: false, 
          error: 'Profile not found' 
        });
      }

      res.json({ success: true,
        success: true,
        message: 'Profile updated successfully',
        profile: updatedProfile[0]
      });

    } catch (error: any) {
      console.error('Profile update error:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to update profile' 
      });
    }
  });

  // Complete survey endpoint - first-time profile completion
  app.post('/api/profile/complete-survey', async (req, res) => {
    try {
      const { userId, country, countryId, educationLevel, grade, pronouns, avatarUrl } = req.body;

      // Validate required fields
      if (!userId || !country || !educationLevel) {
        return res.status(400).json({ 
          success: false, 
          error: 'Missing required fields' 
        });
      }

      // Update the profile with survey data
      const updatedProfile = await db.update(profiles)
        .set({
          country,
          countryId: countryId || null,
          educationLevel,
          grade: grade && !isNaN(parseInt(grade)) ? parseInt(grade) : 0,
          pronouns: pronouns || null,
          avatarUrl: avatarUrl || null,
          updatedAt: new Date()
        })
        .where(eq(profiles.userId, userId))
        .returning();

      if (updatedProfile.length === 0) {
        return res.status(404).json({ 
          success: false, 
          error: 'Profile not found' 
        });
      }

      res.json({ success: true,
        success: true,
        message: 'Survey completed successfully',
        profile: updatedProfile[0]
      });

    } catch (error: any) {
      console.error('Survey completion error:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to complete survey' 
      });
    }
  });

  // Update user grade/education level (with premium restriction)
  app.post('/api/profile/update-grade', async (req, res) => {
    try {
      const { userId, grade, educationLevel } = req.body;

      // Validate required fields
      if (!userId || (!grade && !educationLevel)) {
        return res.status(400).json({ 
          success: false, 
          error: 'Missing required fields' 
        });
      }

      // Get current user profile to check premium status
      const profile = await db.select()
        .from(profiles)
        .where(eq(profiles.userId, userId))
        .limit(1);

      if (profile.length === 0) {
        return res.status(404).json({ 
          success: false, 
          error: 'Profile not found' 
        });
      }

      const userProfile = profile[0];
      const currentTime = new Date();

      // Check if user has active premium subscription
      const hasActivePremium = userProfile.plan && 
        userProfile.plan !== '' && 
        userProfile.planExpiry && 
        userProfile.planExpiry > currentTime;

      // Only premium users can change grade/education level
      if (!hasActivePremium) {
        return res.status(403).json({
          success: false,
          error: 'Premium subscription required',
          message: 'Only users with an active premium subscription can change their grade or education level. Please upgrade to continue.',
          requiredAction: 'upgrade',
          restrictions: [
            'Change grade level',
            'Switch education systems', 
            'Access advanced courses',
            'Download course materials'
          ]
        });
      }

      // Update the user's grade/education level
      const updateData: any = { updatedAt: new Date() };
      if (grade !== undefined) updateData.grade = parseInt(grade);
      if (educationLevel !== undefined) updateData.educationLevel = educationLevel;

      const updatedProfile = await db.update(profiles)
        .set(updateData)
        .where(eq(profiles.userId, userId))
        .returning();

      res.json({ success: true,
        success: true,
        message: 'Grade/education level updated successfully',
        profile: updatedProfile[0]
      });

    } catch (error: any) {
      console.error('Grade update error:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to update grade/education level' 
      });
    }
  });

  // Update profile cover image
  app.post('/api/profile/cover-image', requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const { coverImageUrl } = req.body;
      const userId = req.user!.id;

      // Validate cover image URL
      if (!coverImageUrl || typeof coverImageUrl !== 'string') {
        return res.status(400).json({ 
          success: false, 
          error: 'Valid cover image URL is required' 
        });
      }

      // Update the profile with new cover image
      const updatedProfile = await db.update(profiles)
        .set({
          coverImageUrl,
          updatedAt: new Date()
        })
        .where(eq(profiles.userId, userId))
        .returning();

      if (updatedProfile.length === 0) {
        return res.status(404).json({ 
          success: false, 
          error: 'Profile not found' 
        });
      }

      res.json({ success: true,
        success: true,
        message: 'Cover image updated successfully',
        coverImageUrl: updatedProfile[0].coverImageUrl
      });

    } catch (error: any) {
      console.error('Cover image update error:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to update cover image' 
      });
    }
  });

  // Remove profile cover image
  app.delete('/api/profile/cover-image', requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;

      // Remove cover image from profile
      const updatedProfile = await db.update(profiles)
        .set({
          coverImageUrl: null,
          updatedAt: new Date()
        })
        .where(eq(profiles.userId, userId))
        .returning();

      if (updatedProfile.length === 0) {
        return res.status(404).json({ 
          success: false, 
          error: 'Profile not found' 
        });
      }

      res.json({ success: true,
        success: true,
        message: 'Cover image removed successfully'
      });

    } catch (error: any) {
      console.error('Cover image removal error:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to remove cover image' 
      });
    }
  });

  // Upgrade to Student Account
  app.post('/api/profile/upgrade-to-student', requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const { gradeLevel, school, educationLevel, country, interests } = req.body;

      // Validate required fields
      if (!gradeLevel || !school || !country) {
        return res.status(400).json({ 
          success: false, 
          error: 'Grade level, school, and country are required' 
        });
      }

      // Update profile to student role with student-specific fields
      const updateData: any = {
        role: 'student',
        gradeLevel,
        educationLevel: educationLevel || 'grade',
        country,
        updatedAt: new Date()
      };

      // Parse grade number from grade level
      const gradeNum = parseInt(gradeLevel);
      if (!isNaN(gradeNum)) {
        updateData.grade = gradeNum;
      } else if (gradeLevel === 'college') {
        updateData.grade = 13;
      } else if (gradeLevel === 'university') {
        updateData.grade = 14;
      }

      // Add interests to bio if provided
      if (interests) {
        updateData.bio = interests;
      }

      const updatedProfile = await db.update(profiles)
        .set(updateData)
        .where(eq(profiles.userId, userId))
        .returning();

      if (updatedProfile.length === 0) {
        return res.status(404).json({ 
          success: false, 
          error: 'Profile not found' 
        });
      }

      res.json({ success: true,
        success: true,
        message: 'Successfully upgraded to student account',
        profile: updatedProfile[0]
      });

    } catch (error: any) {
      console.error('Upgrade to student error:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to upgrade to student account' 
      });
    }
  });

  // Upgrade to Freelancer Account
  app.post('/api/profile/upgrade-to-freelancer', requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const { professionalTitle, skills, experience, portfolio, bio, country } = req.body;

      // Validate required fields
      if (!professionalTitle || !skills || !bio || !country) {
        return res.status(400).json({ 
          success: false, 
          error: 'Professional title, skills, bio, and country are required' 
        });
      }

      // Parse portfolio links if provided (comma-separated)
      let portfolioLinks: string[] = [];
      if (portfolio && portfolio.trim()) {
        portfolioLinks = portfolio.split(',').map((link: string) => link.trim()).filter((link: string) => link);
      }

      // Parse skills (comma-separated or newline-separated)
      let skillsArray: string[] = [];
      if (skills && skills.trim()) {
        skillsArray = skills.split(/[,\n]/).map((skill: string) => skill.trim()).filter((skill: string) => skill);
      }

      // Update profile to freelancer role with freelancer-specific fields
      const updateData: any = {
        role: 'freelancer',
        professionalTitle,
        skills: skillsArray,
        bio,
        location: country,
        country,
        updatedAt: new Date(),
        approvalStatus: 'pending' // Freelancers may need approval
      };

      if (portfolioLinks.length > 0) {
        updateData.portfolioLinks = portfolioLinks;
      }

      if (experience) {
        const yearsExp = parseInt(experience);
        if (!isNaN(yearsExp)) {
          updateData.yearsOfExperience = yearsExp;
          updateData.experience = `${yearsExp} years of experience`;
        }
      }

      const updatedProfile = await db.update(profiles)
        .set(updateData)
        .where(eq(profiles.userId, userId))
        .returning();

      if (updatedProfile.length === 0) {
        return res.status(404).json({ 
          success: false, 
          error: 'Profile not found' 
        });
      }

      res.json({ success: true,
        success: true,
        message: 'Successfully upgraded to freelancer account',
        profile: updatedProfile[0]
      });

    } catch (error: any) {
      console.error('Upgrade to freelancer error:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to upgrade to freelancer account' 
      });
    }
  });

  // Update user plan endpoint
  app.post('/api/profile/update-plan', async (req, res) => {
    try {
      const { userId, plan, planName, billingCycle, lastPricingShown } = req.body;

      // Validate required fields
      if (!userId || !plan) {
        return res.status(400).json({ 
          success: false, 
          error: 'Missing required fields' 
        });
      }

      // Build update object
      const updateData: any = {
        plan,
        updatedAt: new Date()
      };

      // Add lastPricingShown if provided
      if (lastPricingShown) {
        updateData.lastPricingShown = new Date(lastPricingShown);
      }

      // Update the user's plan
      const updatedProfile = await db.update(profiles)
        .set(updateData)
        .where(eq(profiles.userId, userId))
        .returning();

      if (updatedProfile.length === 0) {
        return res.status(404).json({ 
          success: false, 
          error: 'Profile not found' 
        });
      }

      res.json({ success: true,
        success: true,
        message: 'Plan updated successfully',
        profile: updatedProfile[0]
      });

    } catch (error: any) {
      console.error('Plan update error:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to update plan' 
      });
    }
  });

  // ======================= STRIPE PAYMENT ROUTES =======================
  
  // Create subscription for education levels
  app.post('/api/create-subscription', requireAuth, async (req, res) => {
    const stripe = await getPrimaryPaymentClient();
    if (!stripe) {
      return res.status(500).json({ error: 'Stripe not configured' });
    }

    try {
      const { planType, courseId, billingCycle = 'monthly' } = req.body;
      
      // SECURITY: Use authenticated user ID from session, never trust client
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ error: 'Authentication required' });
      }
      
      // Validate billing cycle
      if (!['monthly', 'yearly'].includes(billingCycle)) {
        return res.status(400).json({ error: 'Invalid billing cycle' });
      }

      // Get user profile
      const userProfile = await db.select()
        .from(profiles)
        .where(eq(profiles.userId, userId))
        .limit(1);

      if (userProfile.length === 0) {
        return res.status(404).json({ error: 'User profile not found' });
      }

      const profile = userProfile[0];

      // Grade-based subscription pricing (gateway-agnostic - uses amounts, not Stripe price IDs)
      const gradePriceMap: { [key: string]: { pricing: { monthly: number, yearly: number }, type: string, name: string } } = {
        "elementary": { 
          pricing: { monthly: 5.99, yearly: 54.99 }, 
          type: "subscription",
          name: "Elementary Plan"
        },
        "high_school": { 
          pricing: { monthly: 9.99, yearly: 99.90 }, 
          type: "subscription",
          name: "High School Plan"
        },
        "college_university": { 
          pricing: { monthly: 39.00, yearly: 399.00 }, 
          type: "subscription",
          name: "College & University Plan"
        }
      };

      const planDetails = gradePriceMap[planType];
      if (!planDetails) {
        return res.status(400).json({ error: 'Invalid subscription tier selected' });
      }

      // Get the price amount based on billing cycle (gateway-agnostic)
      const planAmount = planDetails.pricing[billingCycle as keyof typeof planDetails.pricing];

      let customer;
      
      // Check if customer exists
      if (profile.stripeCustomerId) {
        customer = await stripe.customers.retrieve(profile.stripeCustomerId);
      } else {
        // Create new customer
        const user = await db.select()
          .from(users)
          .where(eq(users.id, userId))
          .limit(1);

        customer = await stripe.customers.create({
          email: user[0].email,
          name: profile.name,
        });

        // Update profile with customer ID
        await db.update(profiles)
          .set({ stripeCustomerId: customer.id })
          .where(eq(profiles.userId, userId));
      }

      // Create payment intent (gateway-agnostic approach - uses amount, not Stripe price IDs)
      const paymentIntent = await stripe.paymentIntents.create({
        amount: Math.round(planAmount * 100), // Convert to cents
        currency: 'usd',
        customer: customer.id,
        metadata: {
          plan_type: planType,
          billing_cycle: billingCycle,
          user_id: userId,
          subscription: 'true',
          plan_name: planDetails.name
        },
        description: `${planDetails.name} - ${billingCycle}`
      });

      res.json({ success: true,
        success: true,
        clientSecret: paymentIntent.client_secret,
        type: 'subscription',
        amount: planAmount,
        planName: planDetails.name
      });
    } catch (error: any) {
      console.error('Subscription creation error:', error);
      return res.status(500).json({ error: error.message || 'Failed to create subscription' });
    }
  });

  // Confirm subscription payment and update user access
  app.post('/api/confirm-subscription', requireAuth, async (req, res) => {
    const stripe = await getPrimaryPaymentClient();
    if (!stripe) {
      return res.status(500).json({ error: 'Stripe not configured' });
    }

    try {
      const { paymentIntentId, planType, amount } = req.body;
      
      // SECURITY: Use authenticated user ID from session
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ error: 'Authentication required' });
      }

      // Grade-based subscription config
      const gradePriceMap: { [key: string]: { name: string } } = {
        "elementary": { name: "Elementary Plan" },
        "high_school": { name: "High School Plan" },
        "college_university": { name: "College & University Plan" }
      };

      const planConfig = gradePriceMap[planType];
      if (!planConfig) {
        return res.status(400).json({ error: 'Invalid subscription tier' });
      }

      // Check for existing transaction (idempotency)
      const existingPayment = await db.select()
        .from(payments)
        .where(eq(payments.stripePaymentIntentId, paymentIntentId))
        .limit(1);

      if (existingPayment.length > 0) {
        // Already processed, return success
        const profile = await db.select()
          .from(profiles)
          .where(eq(profiles.userId, userId))
          .limit(1);
        
        return res.json({ 
          success: true, 
          message: 'Subscription already confirmed',
          profile: profile[0]
        });
      }

      // Retrieve and verify payment intent from Stripe
      const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
      
      if (paymentIntent.status !== 'succeeded') {
        return res.status(400).json({ error: 'Payment has not succeeded' });
      }

      // Verify the payment intent belongs to this user
      if (paymentIntent.metadata?.user_id !== userId) {
        return res.status(403).json({ error: 'Payment intent does not belong to this user' });
      }

      // Calculate subscription end date (1 month or 1 year from now)
      const billingCycle = paymentIntent.metadata?.billing_cycle || 'monthly';
      const currentPeriodEnd = new Date();
      if (billingCycle === 'yearly') {
        currentPeriodEnd.setFullYear(currentPeriodEnd.getFullYear() + 1);
      } else {
        currentPeriodEnd.setMonth(currentPeriodEnd.getMonth() + 1);
      }

      // 1. Insert payment record
      await db.insert(payments).values({
        userId: userId,
        planType: planType,
        provider: 'stripe',
        providerId: paymentIntent.id,
        amount: (paymentIntent.amount / 100).toString(),
        currency: paymentIntent.currency.toUpperCase(),
        status: 'succeeded',
        stripePaymentIntentId: paymentIntent.id,
        stripeChargeId: paymentIntent.latest_charge as string,
        description: `Subscription: ${planConfig.name}`,
        paymentMethod: 'card',
        receiptUrl: null,
        metadata: {
          planType,
          billingCycle
        }
      });

      // 2. Update profile with new subscription tier
      await db.update(profiles)
        .set({
          subscriptionTier: planType,
          planExpiry: currentPeriodEnd,
          plan: planType,
          updatedAt: new Date()
        })
        .where(eq(profiles.userId, userId));

      // 3. Fetch and return updated profile
      const updatedProfile = await db.select()
        .from(profiles)
        .where(eq(profiles.userId, userId))
        .limit(1);

      res.json({ success: true,
        success: true,
        message: 'Subscription confirmed successfully',
        profile: updatedProfile[0]
      });

    } catch (error: any) {
      console.error('Subscription confirmation error:', error);
      res.status(500).json({ error: error.message || 'Failed to confirm subscription' });
    }
  });

  // Placeholder for future gateway support
  app.post("/api/create-subscription-wallet", requireAuth, async (req, res) => {
    try {
      const { planType, billingCycle = 'monthly' } = req.body;
      const userId = req.user?.id;
      
      if (!userId) {
        return res.status(401).json({ error: 'Authentication required' });
      }

      // Grade-based pricing
      const gradePriceMap: { [key: string]: { pricing: { monthly: number, yearly: number }, name: string } } = {
        "elementary": { pricing: { monthly: 5.99, yearly: 54.99 }, name: "Elementary Plan" },
        "high_school": { pricing: { monthly: 9.99, yearly: 99.90 }, name: "High School Plan" },
        "college_university": { pricing: { monthly: 39.00, yearly: 399.00 }, name: "College & University Plan" }
      };

      const planDetails = gradePriceMap[planType];
      if (!planDetails) {
        return res.status(400).json({ error: 'Invalid subscription tier' });
      }

      const planAmount = planDetails.pricing[billingCycle as keyof typeof planDetails.pricing];

      // Check user's wallet balance
      const [profile] = await db.select()
        .from(profiles)
        .where(eq(profiles.userId, userId))
        .limit(1);

      if (!profile) {
        return res.status(404).json({ error: 'Profile not found' });
      }

      const walletBalance = parseFloat(profile.walletBalance?.toString() || '0');
      
      if (walletBalance < planAmount) {
        return res.status(400).json({ 
          error: 'Insufficient wallet balance',
          required: planAmount,
          available: walletBalance
        });
      }

      // Deduct from wallet and activate subscription
      const newBalance = walletBalance - planAmount;
      const planExpiry = new Date();
      if (billingCycle === 'yearly') {
        planExpiry.setFullYear(planExpiry.getFullYear() + 1);
      } else {
        planExpiry.setMonth(planExpiry.getMonth() + 1);
      }

      await db.update(profiles)
        .set({
          walletBalance: newBalance.toFixed(2),
          plan: planType,
          subscriptionTier: 'premium',
          planExpiry: planExpiry
        })
        .where(eq(profiles.userId, userId));

      res.json({ success: true,
        success: true,
        message: 'Subscription activated via wallet',
        planExpiry,
        newWalletBalance: newBalance
      });
    } catch (error: any) {
      console.error('Wallet subscription error:', error);
      return res.status(500).json({ error: error.message || 'Failed to process wallet payment' });
    }
  });

  // End of subscription routes

  // Get pricing plans based on education level
  app.get('/api/pricing-plans/:educationLevel', async (req, res) => {
    try {
      const { educationLevel } = req.params;
      const { grade } = req.query;

      // Get appropriate pricing plan
      let planName = '';
      if (educationLevel === 'primary' || (grade && parseInt(grade as string) <= 7)) {
        planName = 'primary_basic';
      } else if (educationLevel === 'secondary' || (grade && parseInt(grade as string) > 7 && parseInt(grade as string) <= 12)) {
        planName = 'high_school_basic';
      } else if (educationLevel === 'college' || educationLevel === 'university') {
        planName = 'college_course';
      }

      const plan = await db.select()
        .from(pricingPlans)
        .where(eq(pricingPlans.name, planName))
        .limit(1);

      if (plan.length === 0) {
        return res.status(404).json({ error: 'No pricing plan found for this education level' });
      }

      res.json({ success: true,
        success: true,
        plan: plan[0]
      });
    } catch (error: any) {
      console.error('Pricing plans error:', error);
      res.status(500).json({ error: 'Failed to fetch pricing plans' });
    }
  });

  // Check lesson access for user (REMOVED ALL RESTRICTIONS - OPEN ACCESS)
  app.get('/api/check-lesson-access/:userId/:subjectId/:lessonId', async (req, res) => {
    try {
      // Always return full access - no restrictions
      return res.json({ success: true,
        success: true,
        hasAccess: true,
        reason: 'unrestricted_access'
      });
    } catch (error: any) {
      console.error('Lesson access check error:', error);
      res.status(500).json({ error: 'Failed to check lesson access' });
    }
  });

  // Stripe webhook for payment confirmation
  app.post('/api/stripe/webhook', express.raw({type: 'application/json'}), async (req, res) => {
    const stripe = await getPrimaryPaymentClient();
    if (!stripe) {
      return res.status(500).json({ error: 'Stripe not configured' });
    }

    try {
      const sig = req.headers['stripe-signature'];
      let event;

      // Verify webhook signature (add your endpoint secret)
      // event = stripe.webhooks.constructEvent(req.body, sig, process.env.STRIPE_WEBHOOK_SECRET);

      // For now, parse the event directly (in production, always verify signature)
      event = JSON.parse(req.body);

      switch (event.type) {
        case 'customer.subscription.created':
        case 'customer.subscription.updated':
        case 'invoice.payment_succeeded':
          const invoice = event.data.object;
          const customerId = invoice.customer;
          const subscriptionId = invoice.subscription;

          // Find user by Stripe customer ID
          const userProfile = await db.select()
            .from(profiles)
            .where(eq(profiles.stripeCustomerId, customerId))
            .limit(1);

          if (userProfile.length > 0) {
            const profile = userProfile[0];
            
            // Get subscription details from Stripe
            const subscription = await stripe.subscriptions.retrieve(subscriptionId);
            
            // Determine plan type based on subscription price
            let planType = 'primary_basic';
            if (subscription.items.data[0]?.price?.id === 'price_highschool_999') {
              planType = 'high_school_basic';
            } else if (subscription.items.data[0]?.price?.id === 'price_primary_5') {
              planType = 'primary_basic';
            }

            // Update subscription status with proper expiry date
            const planExpiry = new Date(subscription.current_period_end * 1000);

            await db.update(profiles)
              .set({ 
                plan: planType,
                subscriptionTier: 'premium',
                planExpiry: planExpiry,
                stripeSubscriptionId: subscription.id
              })
              .where(eq(profiles.userId, profile.userId));
          }
          break;

        case 'customer.subscription.deleted':
          const deletedSubscription = event.data.object;
          const deletedCustomerId = deletedSubscription.customer;

          // Cancel user's subscription
          const deletedUserProfile = await db.select()
            .from(profiles)
            .where(eq(profiles.stripeCustomerId, deletedCustomerId))
            .limit(1);

          if (deletedUserProfile.length > 0) {
            await db.update(profiles)
              .set({ 
                plan: '',
                subscriptionTier: 'free',
                planExpiry: null,
                stripeSubscriptionId: null
              })
              .where(eq(profiles.userId, deletedUserProfile[0].userId));
          }
          break;

        case 'payment_intent.succeeded':
          const paymentIntent = event.data.object;
          const planType = paymentIntent.metadata?.plan_type;
          const userId = paymentIntent.metadata?.user_id;

          if (planType === 'college_course' && userId) {
            // For one-time college course payments, give lifetime access to that course
            const courseExpiry = new Date();
            courseExpiry.setFullYear(courseExpiry.getFullYear() + 10); // 10 years access

            await db.update(profiles)
              .set({ 
                plan: 'college_course',
                subscriptionTier: 'premium',
                planExpiry: courseExpiry
              })
              .where(eq(profiles.userId, userId));
          }
          break;
      }

      res.json({received: true});
    } catch (error: any) {
      console.error('Webhook error:', error);
      res.status(500).json({ error: 'Webhook failed' });
    }
  });

  // ======================= DASHBOARD ROUTES =======================
  
  // Check lesson access based on subscription and education level (UNRESTRICTED ACCESS)
  app.get("/api/check-lesson-access/:userId/:subjectId/:lessonId", async (req, res) => {
    try {
      // Always return full access - no restrictions
      return res.json({ success: true,
        success: true,
        hasAccess: true,
        reason: 'unrestricted_access'
      });
    } catch (error: any) {
      console.error('Lesson access check error:', error);
      res.status(500).json({ error: 'Failed to check lesson access' });
    }
  });

  // Check subject progress (for dashboard)
  app.get("/api/check-lesson-access/:userId/:subjectId/check", async (req, res) => {
    try {
      const { userId, subjectId } = req.params;

      // Count lessons accessed in this subject
      const accessedLessons = await db.select({ count: sql<number>`count(*)` })
        .from(studentProgress)
        .where(and(
