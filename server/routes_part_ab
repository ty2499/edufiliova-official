      console.error('Calculate upgrade cost error:', error);
      res.status(500).json({ error: "Failed to calculate upgrade cost" });
    }
  });

  // Upgrade membership with payment (wallet or card) - now supports pro-rated upgrades
  app.post("/api/shop/membership/upgrade", requireAuth, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;
      const customer = await storage.getShopCustomerByUserId(userId);
      
      if (!customer) {
        return res.status(404).json({ error: "Customer profile not found" });
      }

      const { planId, billingCycle, paymentMethod } = req.body;

      if (!planId || !billingCycle || !paymentMethod) {
        return res.status(400).json({ error: "Missing required fields" });
      }

      // Get plan details
      const planDetails = await db
        .select()
        .from(shopMembershipPlans)
        .where(eq(shopMembershipPlans.planId, planId))
        .limit(1);

      if (!planDetails || planDetails.length === 0) {
        return res.status(404).json({ error: "Plan not found" });
      }

      const plan = planDetails[0];
      
      // Get current membership to calculate pro-rated price
      const membership = await storage.getShopMembershipByCustomerId(customer.id);
      let price = parseFloat(billingCycle === 'monthly' ? plan.monthlyPrice : plan.yearlyPrice);
      let isProrated = false;
      
      // Calculate pro-rated price if upgrading from an active membership
      if (membership && membership.renewalDate && membership.plan !== 'free') {
        const currentPlanDetails = await db
          .select()
          .from(shopMembershipPlans)
          .where(eq(shopMembershipPlans.planId, membership.plan))
          .limit(1);

        if (currentPlanDetails && currentPlanDetails.length > 0) {
          const currentPlan = currentPlanDetails[0];
          const now = new Date();
          const renewalDate = new Date(membership.renewalDate);
          const daysRemaining = Math.max(0, Math.ceil((renewalDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)));
          
          const daysInPeriod = billingCycle === 'monthly' ? 30 : 365;
          const currentPlanPrice = parseFloat(billingCycle === 'monthly' ? currentPlan.monthlyPrice : currentPlan.yearlyPrice);
          const dailyRate = currentPlanPrice / daysInPeriod;
          const credit = dailyRate * daysRemaining;
          
          price = Math.max(0, price - credit);
          isProrated = true;
          
          console.log(`ðŸ’° Pro-rated upgrade: ${membership.plan} â†’ ${planId}, ${daysRemaining} days credit = $${credit.toFixed(2)}, final price = $${price.toFixed(2)}`);
        }
      }

      // Free plan doesn't require payment
      if (planId === 'free' || price === 0) {
        const membership = await storage.getShopMembershipByCustomerId(customer.id);
        
        if (!membership) {
          return res.status(404).json({ error: "Membership not found" });
        }

        // Check if current plan is not free (i.e., downgrade to free)
        if (membership.plan !== 'free') {
          // DOWNGRADE to free: Schedule plan change for renewal date
          const renewalDate = membership.renewalDate || new Date(Date.now() + 30 * 24 * 60 * 60 * 1000);
          
          const updated = await storage.updateShopMembership(membership.id, { 
            scheduledPlan: planId,
            scheduledPlanDate: renewalDate,
            billingCycle: membership.billingCycle
          });

          if (!updated) {
            return res.status(500).json({ error: "Failed to schedule plan change" });
          }

          console.log(`ðŸ“… Scheduled downgrade from ${membership.plan} to ${planId} on ${renewalDate}`);
          
          return res.json({ 
            success: true, 
            membership: updated,
            scheduled: true,
            scheduledDate: renewalDate,
            message: `Your plan will change to Free on ${renewalDate.toLocaleDateString()}. You will continue to enjoy your current plan benefits until then.`
          });
        }

        // Already on free plan - reset credits for consistency
        const updated = await storage.updateShopMembership(membership.id, { 
          plan: planId, 
          status: 'active',
          billingCycle,
          adsCreatedThisMonth: 0,
          dailyDownloadsUsed: 0,
          monthlyPaidDownloadsUsed: 0,
          lastDailyResetDate: new Date(),
          lastMonthlyResetDate: new Date()
        });
        
        await storage.updateShopCustomer(customer.id, { accountType: planId });
        
        return res.json({ success: true, membership: updated });
      }

      // Handle wallet payment
      if (paymentMethod === 'wallet') {
        const walletBalance = parseFloat(customer.walletBalance || '0');
        
        if (walletBalance < price) {
          return res.status(400).json({ 
            error: "Insufficient wallet balance",
            required: price,
            available: walletBalance 
          });
        }

        try {
          // Get current membership
          const membership = await storage.getShopMembershipByCustomerId(customer.id);
          let updated: any = null;
          let isDowngrade = false;
          
          if (!membership) {
            // Create new membership if doesn't exist - reset all credits for new plan
            const newMembership = await storage.createShopMembership({
              customerId: customer.id,
              plan: planId,
              status: 'active',
              billingCycle,
              adsCreatedThisMonth: 0,
              dailyDownloadsUsed: 0,
              monthlyPaidDownloadsUsed: 0,
              lastDailyResetDate: new Date(),
              lastMonthlyResetDate: new Date()
            });

            if (!newMembership) {
              throw new Error("Failed to create membership");
            }

            updated = newMembership;

            // Update customer account type
            await storage.updateShopCustomer(customer.id, { accountType: planId });
          } else {
            // Determine if this is an upgrade or downgrade
            const currentPlanDetails = await db
              .select()
              .from(shopMembershipPlans)
              .where(eq(shopMembershipPlans.planId, membership.plan))
              .limit(1);

            const currentPrice = currentPlanDetails.length > 0 
              ? parseFloat(membership.billingCycle === 'monthly' ? currentPlanDetails[0].monthlyPrice : currentPlanDetails[0].yearlyPrice)
              : 0;

            isDowngrade = price < currentPrice;

            if (isDowngrade) {
              // DOWNGRADE: Schedule plan change for renewal date
              const renewalDate = membership.renewalDate || new Date(Date.now() + 30 * 24 * 60 * 60 * 1000);
              
              updated = await storage.updateShopMembership(membership.id, { 
                scheduledPlan: planId,
                scheduledPlanDate: renewalDate,
                billingCycle: membership.billingCycle // Keep current billing cycle
              });

              if (!updated) {
                throw new Error("Failed to schedule plan change");
              }

              console.log(`ðŸ“… Scheduled downgrade from ${membership.plan} to ${planId} on ${renewalDate}`);
            } else {
              // UPGRADE: Apply immediately and reset all credits for new plan
              updated = await storage.updateShopMembership(membership.id, { 
                plan: planId, 
                status: 'active',
                billingCycle,
                scheduledPlan: null, // Clear any scheduled changes
                scheduledPlanDate: null,
                adsCreatedThisMonth: 0, // Reset ad credits
                dailyDownloadsUsed: 0, // Reset daily download counter
                monthlyPaidDownloadsUsed: 0, // Reset monthly download counter
                lastDailyResetDate: new Date(), // Reset daily reset date
                lastMonthlyResetDate: new Date() // Reset monthly reset date
              });

              if (!updated) {
                throw new Error("Failed to update membership");
              }

              // Update customer account type
              await storage.updateShopCustomer(customer.id, { accountType: planId });

              console.log(`âœ… Immediately upgraded from ${membership.plan} to ${planId} - Credits reset to 0`);
            }
          }

          // Deduct from wallet after successful membership update
          await storage.updateWalletBalance(customer.id, -price);

          // Create transaction record
          await storage.createShopTransaction({
            customerId: customer.id,
            amount: price.toFixed(2),
            type: 'membership_upgrade',
            description: `${isDowngrade ? 'Scheduled downgrade' : 'Upgraded'} to ${plan.name} (${billingCycle})`,
            status: 'paid',
            paymentMethod: 'wallet'
          });
        } catch (updateError) {
          console.error('Wallet payment error:', updateError);
          return res.status(500).json({ error: "Failed to process wallet payment. Your balance has not been deducted." });
        }
        // Send confirmation email
        try {
          const { sendPlanUpgradeEmail } = await import('./utils/email-templates.js');
          const userProfile = await db.select().from(profiles).where(eq(profiles.userId, userId)).limit(1);
          const userEmail = userProfile[0]?.email || customer.email;
          const userName = customer.fullName || userProfile[0]?.name || 'Student';
          
          const membership = await storage.getShopMembershipByCustomerId(customer.id);
          const expiryDate = new Date(membership?.endDate || Date.now() + 30*24*60*60*1000).toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
          
          if (userEmail) {
            await sendPlanUpgradeEmail(userEmail, userName, {
              planName: plan.name,
              previousPlan: membership?.plan || 'Free',
              price: price.toFixed(2),
              billingCycle: billingCycle === 'monthly' ? 'Monthly' : 'Yearly',
              expiryDate: expiryDate,
              upgradeDate: new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })
            });
          }
        } catch (emailError) {
          console.error('Failed to send membership email:', emailError);
        }

        return res.json({ 
          success: true, 
          membership: await storage.getShopMembershipByCustomerId(customer.id),
          paymentMethod: 'wallet' 
        });
      }

      // Handle card payment
      if (paymentMethod === 'card') {
        const stripe = await getPrimaryPaymentClient();
        if (!stripe) {
          return res.status(500).json({ error: "Payment processing is not configured" });
        }

        // Create Stripe payment intent
        const paymentIntent = await stripe.paymentIntents.create({
          amount: Math.round(price * 100), // Convert to cents
          currency: 'usd',
          automatic_payment_methods: {
            enabled: true,
          },
          metadata: {
            customerId: customer.id,
            userId: userId,
            planId: planId,
            billingCycle: billingCycle,
            type: 'membership_upgrade',
          },
        });

        // Store pending transaction
        try {
          const createdTransaction = await storage.createShopTransaction({
            customerId: customer.id,
            amount: price.toFixed(2),
            type: 'membership_upgrade',
            description: `Upgrade to ${plan.name} (${billingCycle})`,
            status: 'pending',
            referenceId: paymentIntent.id
          });
          console.log('âœ… Transaction created:', { id: createdTransaction.id, referenceId: createdTransaction.referenceId });
        } catch (txError) {
          console.error('âŒ Failed to create transaction:', txError);
          throw txError;
        }

        return res.json({ 
          success: true,
          paymentMethod: 'card',
          clientSecret: paymentIntent.client_secret,
          amount: price,
          planId: planId,
          billingCycle: billingCycle
        });
      }

      return res.status(400).json({ error: "Invalid payment method" });

    } catch (error: any) {
      console.error('Membership upgrade error:', error);
      res.status(500).json({ error: "Failed to process membership upgrade" });
    }
  });

  // Confirm membership upgrade payment (for card payments)
  app.post("/api/shop/membership/confirm-upgrade", requireAuth, async (req, res) => {
    try {
      const stripe = await getPrimaryPaymentClient();
      const userId = (req as AuthenticatedRequest).user?.id;
      const customer = await storage.getShopCustomerByUserId(userId);
      
      if (!customer) {
        return res.status(404).json({ error: "Customer profile not found" });
      }

      const { paymentIntentId } = req.body;

      if (!paymentIntentId) {
        return res.status(400).json({ error: "Payment intent ID is required" });
      }

      // Get transaction by payment intent ID
      const transactions = await storage.getShopTransactionsByCustomerId(customer.id);
      console.log('ðŸ” Looking for transaction with paymentIntentId:', paymentIntentId);
      console.log('ðŸ” Found transactions:', transactions.map((t: any) => ({ id: t.id, referenceId: t.referenceId, status: t.status, type: t.type })));
      const transaction = transactions.find((t: any) => t.referenceId === paymentIntentId);

      if (!transaction) {
        console.error('âŒ Transaction not found! PaymentIntentId:', paymentIntentId, 'Transactions count:', transactions.length);
        return res.status(404).json({ error: "Transaction not found" });
      }

      if (transaction.status === 'completed') {
        return res.status(409).json({ error: "Payment already processed", alreadyProcessed: true });
      }

      // Verify payment intent with Stripe
      if (stripe) {
        const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
        
        if (paymentIntent.status !== 'succeeded') {
          return res.status(400).json({ error: "Payment not successful. Status: " + paymentIntent.status });
        }

        // Verify amount matches transaction
        const expectedAmount = Math.round(parseFloat(transaction.amount) * 100);
        if (paymentIntent.amount !== expectedAmount) {
          console.error('Payment amount mismatch:', { expected: expectedAmount, received: paymentIntent.amount });
          return res.status(400).json({ error: "Payment amount mismatch" });
        }

        // Verify metadata matches
        const planId = paymentIntent.metadata.planId;
        const billingCycle = paymentIntent.metadata.billingCycle;

        if (!planId || !billingCycle) {
          return res.status(400).json({ error: "Invalid payment metadata" });
        }

        // Get plan details to verify
        const planDetails = await db
          .select()
          .from(shopMembershipPlans)
          .where(eq(shopMembershipPlans.planId, planId))
          .limit(1);

        if (!planDetails || planDetails.length === 0) {
          return res.status(404).json({ error: "Plan not found" });
        }

        // Update membership
        const membership = await storage.getShopMembershipByCustomerId(customer.id);
        const newPlanPrice = parseFloat(billingCycle === 'monthly' ? planDetails[0].monthlyPrice : planDetails[0].yearlyPrice);
        
        if (!membership) {
          // Create membership if it doesn't exist - reset all credits for new plan
          const newMembership = await storage.createShopMembership({
            customerId: customer.id,
            plan: planId,
            status: 'active',
            billingCycle,
            adsCreatedThisMonth: 0,
            dailyDownloadsUsed: 0,
            monthlyPaidDownloadsUsed: 0,
            lastDailyResetDate: new Date(),
            lastMonthlyResetDate: new Date()
          });

          if (!newMembership) {
            return res.status(500).json({ error: "Failed to create membership" });
          }

          await storage.updateShopCustomer(customer.id, { accountType: planId });
        } else {
          // Determine if this is an upgrade or downgrade
          const currentPlanDetails = await db
            .select()
            .from(shopMembershipPlans)
            .where(eq(shopMembershipPlans.planId, membership.plan))
            .limit(1);

          const currentPrice = currentPlanDetails.length > 0 
            ? parseFloat(membership.billingCycle === 'monthly' ? currentPlanDetails[0].monthlyPrice : currentPlanDetails[0].yearlyPrice)
            : 0;

          const isDowngrade = newPlanPrice < currentPrice;

          if (isDowngrade) {
            // DOWNGRADE: Schedule plan change for renewal date
            const renewalDate = membership.renewalDate || new Date(Date.now() + 30 * 24 * 60 * 60 * 1000);
            
            const updated = await storage.updateShopMembership(membership.id, { 
              scheduledPlan: planId,
              scheduledPlanDate: renewalDate,
              billingCycle: membership.billingCycle
            });

            if (!updated) {
              return res.status(500).json({ error: "Failed to schedule plan change" });
            }

            console.log(`ðŸ“… Scheduled downgrade from ${membership.plan} to ${planId} on ${renewalDate} (Card payment)`);
          } else {
            // UPGRADE: Apply immediately and reset all credits for new plan
            const updated = await storage.updateShopMembership(membership.id, { 
              plan: planId, 
              status: 'active',
              billingCycle,
              scheduledPlan: null,
              scheduledPlanDate: null,
              adsCreatedThisMonth: 0, // Reset ad credits
              dailyDownloadsUsed: 0, // Reset daily download counter
              monthlyPaidDownloadsUsed: 0, // Reset monthly download counter
              lastDailyResetDate: new Date(), // Reset daily reset date
              lastMonthlyResetDate: new Date() // Reset monthly reset date
            });

            if (!updated) {
              return res.status(500).json({ error: "Failed to update membership" });
            }

            await storage.updateShopCustomer(customer.id, { accountType: planId });

            console.log(`âœ… Immediately upgraded from ${membership.plan} to ${planId} (Card payment) - Credits reset to 0`);
          }
        }

        // Update transaction
        await db.update(shopTransactions)
          .set({ status: 'paid', updatedAt: new Date() })
          .where(eq(shopTransactions.id, transaction.id));

        // Create payment record for revenue tracking
        await db.insert(payments).values({
          userId,
          amount: transaction.amount,
          currency: 'USD',
          status: 'succeeded',
          planType: `Shop ${planId} (${billingCycle})`,
          stripePaymentIntentId: paymentIntentId,
          description: `Shop membership upgrade to ${planId}`,
          paymentMethod: 'card',
          processedAt: new Date()
        });

        // Send confirmation email
        try {
          const { emailService } = await import('./utils/email.js');
          const planDetails = await db
            .select()
            .from(shopMembershipPlans)
            .where(eq(shopMembershipPlans.planId, planId))
            .limit(1);
          
          const userProfile = await db.select().from(profiles).where(eq(profiles.userId, userId)).limit(1);
          const userEmail = userProfile[0]?.email || customer.email;
          
          if (userEmail && planDetails[0]) {
            await emailService.sendSubscriptionEmail(userEmail, {
              planName: planDetails[0].name,
              price: parseFloat(transaction.amount),
              billingCycle: billingCycle === 'monthly' ? 'Monthly' : 'Yearly',
              orderId: membership.id,
              customerName: customer.fullName || userProfile[0]?.name || undefined,
              features: planDetails[0].features || []
            });
          }
        } catch (emailError) {
          console.error('Failed to send membership email:', emailError);
        }

        // Fetch the updated membership to return
        const updatedMembership = await storage.getShopMembershipByCustomerId(customer.id);
        return res.json({ success: true, membership: updatedMembership });
      }

      return res.status(500).json({ error: "Payment verification failed" });

    } catch (error: any) {
      console.error('Confirm upgrade error:', error);
      res.status(500).json({ error: "Failed to confirm upgrade" });
    }
  });

  // Get wallet balance and info
  app.get("/api/shop/wallet", requireAuth, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;
      const customer = await storage.getShopCustomerByUserId(userId);
      
      if (!customer) {
        return res.json({ balance: '0.00' });
      }

      res.json({ balance: customer.walletBalance });
    } catch (error: any) {
      console.error('Get wallet error:', error);
      res.status(500).json({ error: "Failed to fetch wallet details" });
    }
  });

  // Get wallet transactions
  app.get("/api/shop/wallet/transactions", requireAuth, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;
      const customer = await storage.getShopCustomerByUserId(userId);
      
      if (!customer) {
        return res.json([]);
      }

      const transactions = await storage.getShopTransactionsByCustomerId(customer.id);
      res.json(transactions);
    } catch (error: any) {
      console.error('Get transactions error:', error);
      res.status(500).json({ error: "Failed to fetch transactions" });
    }
  });

  // Create Stripe Payment Intent for embedded wallet top-up
  app.post("/api/shop/wallet/create-payment-intent", requireAuth, async (req, res) => {
    try {
      const stripe = await getPrimaryPaymentClient();
      if (!stripe) {
        return res.status(500).json({ error: "Payment processing is not configured" });
      }

      const userId = (req as AuthenticatedRequest).user?.id;
      
      // Get or create shop customer
      let customer = await storage.getShopCustomerByUserId(userId);
      if (!customer) {
        const profile = await db.select().from(profiles).where(eq(profiles.userId, userId)).limit(1);
        customer = await storage.createShopCustomer({
          userId,
          fullName: profile[0]?.name || 'Customer',
          email: (req as AuthenticatedRequest).user?.email || ''
        });
      }

      const { amount } = req.body;
      
      if (!amount || amount <= 0) {
        return res.status(400).json({ error: "Invalid amount" });
      }

      // Create Stripe payment intent
      const paymentIntent = await stripe.paymentIntents.create({
        amount: Math.round(parseFloat(amount) * 100), // Convert to cents
        currency: 'usd',
        automatic_payment_methods: {
          enabled: true,
        },
        metadata: {
          customerId: customer.id,
          userId: userId,
          amount: amount,
          type: 'wallet_topup',
        },
      });

      // Store payment intent for later verification
      await storage.createShopTransaction({
        customerId: customer.id,
        amount: amount,
        type: 'add_funds',
        status: 'pending',
        description: `Wallet top-up $${amount}`,
        referenceId: paymentIntent.id,
      });

      res.json({ success: true, clientSecret: paymentIntent.client_secret });
    } catch (error: any) {
      console.error('Create payment intent error:', error);
      res.status(500).json({ error: "Failed to create payment intent" });
    }
  });

  // Confirm payment intent and update wallet balance
  app.post("/api/shop/wallet/confirm-payment", requireAuth, async (req, res) => {
    try {
      const stripe = await getPrimaryPaymentClient();
      if (!stripe) {
        return res.status(500).json({ error: "Payment processing is not configured" });
      }

      const userId = (req as AuthenticatedRequest).user?.id;
      const { paymentIntentId } = req.body;
      
      if (!paymentIntentId) {
        return res.status(400).json({ error: "Payment intent ID is required" });
      }

      // Retrieve the payment intent from Stripe
      const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
      
      // Verify the payment intent belongs to this user
      if (paymentIntent.metadata?.userId !== userId) {
        return res.status(403).json({ error: "Unauthorized" });
      }

      // Check if payment was successful
      if (paymentIntent.status !== 'succeeded') {
        return res.status(400).json({ error: "Payment not successful" });
      }

      // Check if already processed
      const existingTransaction = await db
        .select()
        .from(shopTransactions)
        .where(eq(shopTransactions.referenceId, paymentIntentId))
        .limit(1);

      if (existingTransaction.length > 0 && existingTransaction[0].status === 'completed') {
        const customer = await storage.getShopCustomerByUserId(userId);
        return res.status(409).json({ 
          error: "Payment already processed",
          alreadyProcessed: true,
          balance: customer?.walletBalance || '0.00'
        });
      }

      const customer = await storage.getShopCustomerByUserId(userId);
      if (!customer) {
        return res.status(404).json({ error: "Customer not found" });
      }

      const amount = paymentIntent.metadata?.amount;
      if (!amount) {
        return res.status(400).json({ error: "Invalid payment amount" });
      }

      // Update transaction status
      await db.update(shopTransactions)
        .set({ status: 'completed' })
        .where(eq(shopTransactions.referenceId, paymentIntentId));

      // Update wallet balance
      const newBalance = (parseFloat(customer.walletBalance) + parseFloat(amount)).toFixed(2);
      await storage.updateShopCustomer(customer.id, {
        walletBalance: newBalance
      });

      res.json({ success: true, newBalance });
    } catch (error: any) {
      console.error('Confirm payment error:', error);
      res.status(500).json({ error: "Failed to confirm payment" });
    }
  });

  // Create Stripe Checkout Session for wallet top-up (legacy)
  app.post("/api/shop/wallet/create-checkout-session", requireAuth, async (req, res) => {
    try {
      const stripe = await getPrimaryPaymentClient();
      if (!stripe) {
        return res.status(500).json({ error: "Payment processing is not configured" });
      }

      const userId = (req as AuthenticatedRequest).user?.id;
      const customer = await storage.getShopCustomerByUserId(userId);
      
      if (!customer) {
        return res.status(404).json({ error: "Customer profile not found" });
      }

      const { amount } = req.body;
      
      if (!amount || amount <= 0) {
        return res.status(400).json({ error: "Invalid amount" });
      }

      // Create Stripe checkout session
      const baseUrl = process.env.REPLIT_DEV_DOMAIN 
        ? `https://${process.env.REPLIT_DEV_DOMAIN}` 
        : process.env.BASE_URL || process.env.APP_URL || 'http://localhost:5000';
      
      const session = await stripe.checkout.sessions.create({
        payment_method_types: ['card'],
        line_items: [
          {
            price_data: {
              currency: 'usd',
              product_data: {
                name: 'Wallet Top-Up',
                description: `Add $${amount} to your wallet balance`,
              },
              unit_amount: Math.round(parseFloat(amount) * 100), // Convert to cents
            },
            quantity: 1,
          },
        ],
        mode: 'payment',
        success_url: `${baseUrl}/customer-dashboard?payment=success&session_id={CHECKOUT_SESSION_ID}`,
        cancel_url: `${baseUrl}/customer-dashboard?payment=cancelled`,
        metadata: {
          customerId: customer.id,
          userId: userId,
          amount: amount,
          type: 'wallet_topup',
        },
      });

      res.json({ success: true, sessionId: session.id, url: session.url });
    } catch (error: any) {
      console.error('Create checkout session error:', error);
      res.status(500).json({ error: "Failed to create checkout session" });
    }
  });


  // DodoPay wallet top-up confirmation
  app.post("/api/shop/wallet/confirm-dodopay", requireAuth, async (req: AuthenticatedRequest, res: Response) => {
    try {
      const userId = req.user?.id;
      const { amount, paymentId, sessionId } = req.body;

      if (!userId) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      if (!amount || amount <= 0) {
        return res.status(400).json({ success: false, error: 'Invalid amount' });
      }

      // Get or create shop customer
      let customer = await storage.getShopCustomerByUserId(userId);
      if (!customer) {
        // Create shop customer if doesn't exist
        const userProfile = await storage.getProfile(userId);
        const authUser = await storage.getAuthUser(userId);
        customer = await storage.createShopCustomer({
          userId,
          email: authUser?.email || '',
          firstName: userProfile?.name?.split(' ')[0] || '',
          lastName: userProfile?.name?.split(' ').slice(1).join(' ') || '',
          walletBalance: '0.00',
        });
      }

      // Check for duplicate transaction
      const referenceId = paymentId || sessionId || `dodo_wallet_${Date.now()}`;
      const existingTransaction = await db
        .select()
        .from(shopTransactions)
        .where(eq(shopTransactions.referenceId, referenceId))
        .limit(1);

      if (existingTransaction.length > 0) {
        // Already processed
        return res.json({ 
          success: true, 
          alreadyProcessed: true,
          newBalance: customer.walletBalance 
        });
      }

      // Record the transaction
      await db.insert(shopTransactions).values({
        customerId: customer.id,
        type: 'credit',
        amount: amount.toString(),
        description: 'Wallet Top-Up (Card)',
        referenceId: referenceId,
        status: 'paid',
        createdAt: new Date(),
      });

      // Update wallet balance
      const newBalance = (parseFloat(customer.walletBalance || '0') + parseFloat(amount)).toFixed(2);
      await storage.updateShopCustomer(customer.id, {
        walletBalance: newBalance
      });

      // Also record in payments table for admin visibility
      try {
        await db.insert(payments).values({
          userId,
          amount: amount.toString(),
          currency: 'USD',
          status: 'succeeded',
          gateway: 'dodopay',
          paymentIntentId: referenceId,
          description: 'Wallet Top-Up (Card)',
          metadata: { type: 'wallet_topup', sessionId },
          createdAt: new Date()
        });
      } catch (paymentLogError) {
        console.warn('Could not log wallet payment:', paymentLogError);
      }

      console.log(`âœ… Card wallet top-up confirmed: $${amount} for user ${userId}, new balance: $${newBalance}`);

      res.json({ 
        success: true, 
        newBalance,
        message: 'Wallet topped up successfully'
      });
    } catch (error: any) {
      console.error('Card wallet confirmation error:', error);
      res.status(500).json({ success: false, error: 'Failed to confirm wallet payment' });
    }
  });
  // Verify and process successful payment
  app.post("/api/shop/wallet/verify-payment", requireAuth, async (req, res) => {
    try {
      const stripe = await getPrimaryPaymentClient();
      if (!stripe) {
        return res.status(500).json({ error: "Payment processing is not configured" });
      }

      const userId = (req as AuthenticatedRequest).user?.id;
      const { sessionId } = req.body;
      
      if (!sessionId) {
        return res.status(400).json({ error: "Session ID is required" });
      }

      // CRITICAL: Check for duplicate processing FIRST, before calling Stripe
      const existingTransaction = await db
        .select()
        .from(shopTransactions)
        .where(eq(shopTransactions.referenceId, sessionId))
        .limit(1);

      if (existingTransaction.length > 0) {
        // Payment already processed - return current balance
        const customer = await storage.getShopCustomerByUserId(userId);
        return res.status(409).json({ 
          error: "Payment already processed",
          alreadyProcessed: true,
          balance: customer?.walletBalance || '0.00'
        });
      }

      // Retrieve the session from Stripe
      const session = await stripe.checkout.sessions.retrieve(sessionId);
      
      // Verify the session belongs to this user
      if (session.metadata?.userId !== userId) {
        return res.status(403).json({ error: "Unauthorized" });
      }

      // Check if payment was successful
      if (session.payment_status !== 'paid') {
        return res.status(400).json({ error: "Payment not completed" });
      }

      const customer = await storage.getShopCustomerByUserId(userId);
      if (!customer) {
        return res.status(404).json({ error: "Customer profile not found" });
      }

      const amount = session.metadata?.amount;
      if (!amount) {
        return res.status(400).json({ error: "Invalid payment data" });
      }

      // Create transaction record (this serves as our idempotency lock)
      try {
        await storage.createShopTransaction({
          customerId: customer.id,
          amount: amount,
          type: 'add_funds',
          description: `Added $${amount} to wallet via Stripe`,
          status: 'paid',
          referenceId: sessionId
        });
      } catch (dbError: any) {
        // Handle unique constraint violation (duplicate payment attempt)
        if (dbError.code === '23505' || dbError.message?.includes('unique')) {
          console.log(`Duplicate payment attempt blocked by database constraint: ${sessionId}`);
          return res.status(409).json({ 
            error: "Payment already processed",
            alreadyProcessed: true,
            balance: customer.walletBalance
          });
        }
        throw dbError; // Re-throw other database errors
      }

      // Update wallet balance
      const updated = await storage.updateWalletBalance(customer.id, parseFloat(amount));

      res.json({ success: true, newBalance: updated.walletBalance });
    } catch (error: any) {
      console.error('Verify payment error:', error);
      res.status(500).json({ error: "Failed to verify payment" });
    }
  });

  // Get support tickets (customer)
  app.get("/api/shop/support/tickets", requireAuth, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;
      const customer = await storage.getShopCustomerByUserId(userId);
      
      if (!customer) {
        return res.json({ success: true, data: [] });
      }

      const tickets = await storage.getShopSupportTicketsByCustomerId(customer.id);
      res.json({ success: true, data: tickets });
    } catch (error: any) {
      console.error('Get tickets error:', error);
      res.status(500).json({ error: "Failed to fetch support tickets" });
    }
  });

  // Get all support tickets (admin only)
  app.get("/api/shop/support/tickets/all", requireAuth, requireAdmin, async (req, res) => {
    try {
      const tickets = await storage.getAllShopSupportTickets();
      
      const ticketsWithCustomerInfo = await Promise.all(
        tickets.map(async (ticket) => {
          const [customer] = await db.select().from(shopCustomers)
            .where(eq(shopCustomers.id, ticket.customerId))
            .limit(1);
          
          return {
            ...ticket,
            customerName: customer?.fullName || 'Unknown',
            customerEmail: customer?.email || 'Unknown'
          };
        })
      );
      
      res.json({ success: true, data: ticketsWithCustomerInfo });
    } catch (error: any) {
      console.error('Get all tickets error:', error);
      res.status(500).json({ error: "Failed to fetch all support tickets" });
    }
  });

  // Create support ticket
  app.post("/api/shop/support/tickets", requireAuth, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;
      const customer = await storage.getShopCustomerByUserId(userId);
      
      if (!customer) {
        return res.status(404).json({ error: "Customer profile not found" });
      }

      // Extract only allowed fields, never trust customerId from client
      const { subject, message, category, priority } = req.body;

      // Validate required fields
      if (!subject || !message) {
        return res.status(400).json({ error: "Subject and message are required" });
      }

      const newTicket = await storage.createShopSupportTicket({
        customerId: customer.id, // Always use authenticated customer's ID
        subject,
        message,
        category: category || 'general',
        priority: priority || 'medium',
        status: 'open' // Always start as open
      });

      // Import email service for notifications
      try {
        const { emailService } = await import('./utils/email.js');
        
        // Send email notification to admin
        try {
          await emailService.sendEmail({
            to: 'support@edufiliova.com',
            subject: `New Support Ticket: ${subject}`,
            html: `
              <h2>New Support Ticket Submitted</h2>
              <p><strong>Customer:</strong> ${customer.fullName || customer.email}</p>
              <p><strong>Email:</strong> ${customer.email}</p>
              <p><strong>Subject:</strong> ${subject}</p>
              <p><strong>Category:</strong> ${category || 'general'}</p>
              <p><strong>Priority:</strong> ${priority || 'medium'}</p>
              <p><strong>Message:</strong></p>
              <p>${message}</p>
              <p><a href="${process.env.REPLIT_DEV_DOMAIN ? `https://${process.env.REPLIT_DEV_DOMAIN}` : 'http://localhost:5000'}/admin">View in Admin Panel</a></p>
            `
          });
        } catch (emailError) {
          console.error('Failed to send admin notification email:', emailError);
        }

        // Send confirmation email to customer
        if (customer.email) {
          try {
            await emailService.sendEmail({
              to: customer.email,
              subject: `Support Ticket Received: ${subject}`,
              html: `
                <h2>Your Support Ticket Has Been Received</h2>
                <p>Hi ${customer.fullName || 'there'},</p>
                <p>We've received your support ticket and our team will respond within 24 hours.</p>
                <p><strong>Subject:</strong> ${subject}</p>
                <p><strong>Your Message:</strong></p>
                <p>${message}</p>
                <p>You can track your ticket status in your customer dashboard.</p>
                <br>
                <p>Best regards,<br>Support Team</p>
              `
            });
          } catch (emailError) {
            console.error('Failed to send customer confirmation email:', emailError);
          }
        }
      } catch (importError) {
        console.error('Failed to import email service:', importError);
      }

      res.json({ success: true, data: newTicket });
    } catch (error: any) {
      console.error('Create ticket error:', error);
      res.status(500).json({ error: "Failed to create support ticket" });
    }
  });

  // Update support ticket
  app.put("/api/shop/support/tickets/:id", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const userId = (req as AuthenticatedRequest).user?.id;
      const customer = await storage.getShopCustomerByUserId(userId);
      
      if (!customer) {
        return res.status(404).json({ error: "Customer profile not found" });
      }

      // Verify ownership - check if ticket belongs to this customer
      const existingTicket = await storage.getShopSupportTicketById(id);
      if (!existingTicket) {
        return res.status(404).json({ error: "Ticket not found" });
      }

      if (existingTicket.customerId !== customer.id) {
        return res.status(403).json({ error: "Unauthorized to modify this ticket" });
      }

      // Customers can only update message field (to add more info)
      // Admin updates status/priority through admin panel
      const { message } = req.body;

      const updated = await storage.updateShopSupportTicket(id, {
        message
      });

      // If admin has replied to this ticket, send them a notification about customer's update
      if (existingTicket.adminEmail && existingTicket.adminReply) {
        try {
          const { emailService } = await import('./utils/email.js');
          await emailService.sendEmail({
            to: existingTicket.adminEmail,
            subject: `Customer Reply to Ticket: ${existingTicket.subject}`,
            html: `
              <h2>Customer Has Replied to Support Ticket</h2>
              <p>Hi ${existingTicket.adminName || 'there'},</p>
              <p>A customer has added a reply to a support ticket you responded to.</p>
              <br>
              <p><strong>Ticket Subject:</strong> ${existingTicket.subject}</p>
              <p><strong>Customer Name:</strong> ${customer.fullName || 'Unknown'}</p>
              <p><strong>Customer Email:</strong> ${customer.email || 'Unknown'}</p>
              <br>
              <p><strong>Your Previous Response:</strong></p>
              <p>${existingTicket.adminReply}</p>
              <br>
              <p><strong>Customer's New Message:</strong></p>
              <p>${message}</p>
              <br>
              <p>You can view and respond to this ticket in the admin dashboard.</p>
              <br>
              <p>Best regards,<br>EduFiliova Support System</p>
            `
          });
        } catch (emailError) {
          console.error('Failed to send admin notification email:', emailError);
        }
      }

      res.json({ success: true, data: updated });
    } catch (error: any) {
      console.error('Update ticket error:', error);
      res.status(500).json({ error: "Failed to update support ticket" });
    }
  });

  // Admin reply to support ticket (admin only)
  app.post("/api/shop/support/tickets/:id/reply", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const { reply, adminName, adminEmail } = req.body;
      const userId = (req as AuthenticatedRequest).user?.id;
      const userEmail = (req as AuthenticatedRequest).user?.email;
      
      if (!reply) {
        return res.status(400).json({ error: "Reply message is required" });
      }

      // Get ticket
      const ticket = await storage.getShopSupportTicketById(id);
      if (!ticket) {
        return res.status(404).json({ error: "Ticket not found" });
      }

      // Get customer info
      const customer = await db.select().from(shopCustomers).where(eq(shopCustomers.id, ticket.customerId)).limit(1);
      if (!customer[0]) {
        return res.status(404).json({ error: "Customer not found" });
      }

      // Update ticket with admin reply and store admin info
      const updatedTicket = await storage.updateShopSupportTicket(id, {
        adminReply: reply,
        adminName: adminName || 'Support Team',
        adminEmail: adminEmail || userEmail || 'support@edufiliova.com',
        status: 'responded'
      });

      // Send email notification to customer
      if (customer[0].email) {
        try {
          const { emailService } = await import('./utils/email.js');
          await emailService.sendEmail({
            to: customer[0].email,
            subject: `Support Team Response: ${ticket.subject}`,
            html: `
              <h2>Support Team Has Responded to Your Ticket</h2>
              <p>Hi ${customer[0].fullName || 'there'},</p>
              <p><strong>Your Original Message:</strong></p>
              <p>${ticket.message}</p>
              <br>
              <p><strong>Support Team Response:</strong></p>
              <p>${reply}</p>
              <br>
              <p>You can reply to this ticket in your customer dashboard or by replying to this email.</p>
              <br>
              <p>Best regards,<br>${adminName || 'Support Team'}</p>
            `
          });
        } catch (emailError) {
          console.error('Failed to send customer reply email:', emailError);
        }
      }

      res.json({ success: true, data: updatedTicket });
    } catch (error: any) {
      console.error('Reply to ticket error:', error);
      res.status(500).json({ error: "Failed to reply to support ticket" });
    }
  });

  // Close/Resolve support ticket (admin only)
  app.put("/api/shop/support/tickets/:id/close", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      
      const ticket = await storage.getShopSupportTicketById(id);
      if (!ticket) {
        return res.status(404).json({ error: "Ticket not found" });
      }

      const updatedTicket = await storage.updateShopSupportTicket(id, {
        status: 'resolved'
      });

      res.json({ success: true, data: updatedTicket });
    } catch (error: any) {
      console.error('Close ticket error:', error);
      res.status(500).json({ error: "Failed to close support ticket" });
    }
  });

  // Delete support ticket (admin only)
  app.delete("/api/shop/support/tickets/:id", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      
      const ticket = await storage.getShopSupportTicketById(id);
      if (!ticket) {
        return res.status(404).json({ error: "Ticket not found" });
      }

      await storage.deleteShopSupportTicket(id);

      res.json({ success: true, message: "Ticket deleted successfully" });
    } catch (error: any) {
      console.error('Delete ticket error:', error);
      res.status(500).json({ error: "Failed to delete support ticket" });
    }
  });

  // Voucher Management Routes

  // Create voucher (admin only)
  app.post("/api/admin/vouchers", requireAuth, requireAdmin, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;
      const { code, amount, description, maxRedemptions, expiresAt } = req.body;

      if (!code || !amount) {
        return res.status(400).json({ error: "Code and amount are required" });
      }

      const existingVoucher = await storage.getVoucherByCode(code.toUpperCase());
      if (existingVoucher) {
        return res.status(400).json({ error: "A voucher with this code already exists" });
      }

      const voucher = await storage.createVoucher({
        code: code.toUpperCase(),
        amount: amount.toString(),
        description,
        maxRedemptions: maxRedemptions || null,
        expiresAt: expiresAt ? new Date(expiresAt) : null,
        isActive: true,
        createdBy: userId,
      });

      res.json(voucher);
    } catch (error: any) {
      console.error('Create voucher error:', error);
      res.status(500).json({ error: "Failed to create voucher" });
    }
  });

  // Get all vouchers (admin only)
  app.get("/api/admin/vouchers", requireAuth, requireAdmin, async (req, res) => {
    try {
      const vouchers = await storage.getVouchers();
      res.json(vouchers);
    } catch (error: any) {
      console.error('Get vouchers error:', error);
      res.status(500).json({ error: "Failed to fetch vouchers" });
    }
  });

  // Delete voucher (admin only)
  app.delete("/api/admin/vouchers/:id", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const deleted = await storage.deleteVoucher(id);
      
      if (!deleted) {
        return res.status(404).json({ error: "Voucher not found" });
      }

      res.json({ success: true, message: "Voucher deleted successfully" });
    } catch (error: any) {
      console.error('Delete voucher error:', error);
      res.status(500).json({ error: "Failed to delete voucher" });
    }
  });

  // Get voucher redemptions (admin only)
  app.get("/api/admin/vouchers/:id/redemptions", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const redemptions = await storage.getVoucherRedemptions(id);
      res.json(redemptions);
    } catch (error: any) {
      console.error('Get redemptions error:', error);
      res.status(500).json({ error: "Failed to fetch redemptions" });
    }
  });

  // Redeem voucher (authenticated users)
  app.post("/api/shop/vouchers/redeem", requireAuth, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;
      const { code } = req.body;

      if (!code) {
        return res.status(400).json({ error: "Voucher code is required" });
      }

      const customer = await storage.getShopCustomerByUserId(userId);
      if (!customer) {
        return res.status(404).json({ error: "Customer profile not found" });
      }

      const normalizedCode = code.toUpperCase();
      
      // First check shop_vouchers table
      const voucher = await storage.getVoucherByCode(normalizedCode);
      
      if (voucher) {
        // Handle shop voucher redemption
        if (!voucher.isActive) {
          return res.status(400).json({ error: "This voucher is no longer active" });
        }

        if (voucher.expiresAt && new Date(voucher.expiresAt) < new Date()) {
          return res.status(400).json({ error: "This voucher has expired" });
        }

        if (voucher.maxRedemptions && voucher.currentRedemptions >= voucher.maxRedemptions) {
          return res.status(400).json({ error: "This voucher has reached its redemption limit" });
        }

        const existingRedemptions = await storage.getVoucherRedemptions(voucher.id);
        const alreadyRedeemed = existingRedemptions.some(r => r.customerId === customer.id);
        if (alreadyRedeemed) {
          return res.status(400).json({ error: "You have already redeemed this voucher" });
        }

        await storage.redeemVoucher(voucher.id, customer.id, voucher.amount);

        const currentBalance = parseFloat(customer.walletBalance || '0');
        const voucherAmount = parseFloat(voucher.amount);
        const newBalance = currentBalance + voucherAmount;
        await storage.updateWalletBalance(customer.id, newBalance);

        await storage.createShopTransaction({
          customerId: customer.id,
          amount: voucher.amount,
          type: 'add_funds',
          description: `Voucher redeemed: ${normalizedCode}`,
          status: 'paid',
          referenceId: `voucher_${voucher.id}`,
        });

        return res.json({ 
          success: true, 
          message: `Voucher redeemed! $${voucher.amount} added to your wallet`,
          newBalance: newBalance.toFixed(2)
        });
      }
      
      // Check gift_voucher_purchases table for wallet-purchased vouchers
      const [giftVoucher] = await db.select()
        .from(giftVoucherPurchases)
        .where(eq(giftVoucherPurchases.code, normalizedCode))
        .limit(1);
      
      if (giftVoucher) {
        // Check if payment was completed
        if (giftVoucher.paymentStatus !== 'completed') {
          return res.status(400).json({ error: "This voucher payment has not been completed" });
        }
        
        // Check if already redeemed
        if (giftVoucher.isRedeemed) {
          return res.status(400).json({ error: "This voucher has already been redeemed" });
        }
        
        // Check if expired
        if (giftVoucher.expiresAt && new Date(giftVoucher.expiresAt) < new Date()) {
          return res.status(400).json({ error: "This voucher has expired" });
        }
        
        // Mark as redeemed
        await db.update(giftVoucherPurchases)
          .set({ 
            isRedeemed: true, 
            redeemedAt: new Date(),
            redeemedBy: userId
          })
          .where(eq(giftVoucherPurchases.id, giftVoucher.id));
        
        // Add to wallet
        const currentBalance = parseFloat(customer.walletBalance || '0');
        const voucherAmount = parseFloat(giftVoucher.amount);
        const newBalance = currentBalance + voucherAmount;
        await storage.updateWalletBalance(customer.id, newBalance);
        
        // Create transaction record
        await storage.createShopTransaction({
          customerId: customer.id,
          amount: giftVoucher.amount,
          type: 'add_funds',
          description: `Gift voucher redeemed: ${normalizedCode}`,
          status: 'paid',
          referenceId: `gift_voucher_${giftVoucher.id}`,
        });
        
        return res.json({ 
          success: true, 
          message: `Gift voucher redeemed! $${giftVoucher.amount} added to your wallet`,
          newBalance: newBalance.toFixed(2)
        });
      }
      
      // No voucher found in either table
      return res.status(404).json({ error: "Invalid voucher code" });
      
    } catch (error: any) {
      console.error('Redeem voucher error:', error);
      if (error.message && error.message.includes('unique')) {
        return res.status(400).json({ error: "You have already redeemed this voucher" });
      }
      res.status(500).json({ error: "Failed to redeem voucher" });
    }
  });



  // ============ GIFT VOUCHER PURCHASE ROUTES ============

  // Create payment intent for gift voucher purchase
  app.post("/api/gift-vouchers/create-payment-intent", optionalAuth, async (req, res) => {
    try {
      const { amount, recipientEmail, recipientName, personalMessage, sendToSelf, buyerEmail, buyerName } = req.body;
      const userId = (req as AuthenticatedRequest).user?.id;

      if (!amount || amount < 5) {
        return res.status(400).json({ error: "Minimum voucher amount is $5" });
      }

      if (amount > 500) {
        return res.status(400).json({ error: "Maximum voucher amount is $500" });
      }

      if (!recipientEmail) {
        return res.status(400).json({ error: "Recipient email is required" });
      }

      // Get Stripe instance
      const stripe = await getPrimaryPaymentClient();
      if (!stripe) {
        return res.status(500).json({ error: "Payment service not configured" });
      }

      // Create payment intent
      const paymentIntent = await stripe.paymentIntents.create({
        amount: Math.round(amount * 100), // Convert to cents
        currency: 'usd',
        metadata: {
          type: 'gift_voucher',
          buyerId: userId || 'guest',
          buyerEmail: buyerEmail || '',
          buyerName: buyerName || '',
          recipientEmail,
          recipientName: recipientName || '',
          personalMessage: personalMessage || '',
          sendToSelf: sendToSelf ? 'true' : 'false',
          amount: amount.toString()
        }
      });

      // Create pending purchase record
      const [purchase] = await db.insert(giftVoucherPurchases).values({
        buyerId: userId || null,
        buyerEmail: buyerEmail || 'guest@edufiliova.com',
        buyerName: buyerName || null,
        recipientEmail,
        recipientName: recipientName || null,
        amount: amount.toString(),
        personalMessage: personalMessage || null,
        sendToSelf: sendToSelf || false,
        paymentIntentId: paymentIntent.id,
        paymentStatus: 'pending'
      }).returning();

      res.json({ success: true,
        clientSecret: paymentIntent.client_secret,
        purchaseId: purchase.id
      });
    } catch (error: any) {
      console.error('Gift voucher payment intent error:', error);
      res.status(500).json({ error: error.message || "Failed to create payment" });
    }
  });

  // Confirm gift voucher purchase after payment
  app.post("/api/gift-vouchers/confirm-purchase", async (req, res) => {
    try {
      const { paymentIntentId, purchaseId, paymentMethod } = req.body;

      if (!paymentIntentId || !purchaseId) {
        return res.status(400).json({ error: "Payment intent ID and purchase ID required" });
      }

      // For Stripe payments, verify with Stripe API
      // For PayPal/Paystack, the payment is already verified in the callback handler
      if (!paymentMethod || paymentMethod === 'stripe' || paymentMethod === 'card') {
        const stripe = await getPrimaryPaymentClient();
        if (!stripe) {
          return res.status(500).json({ error: "Payment service not configured" });
        }

        const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
        if (paymentIntent.status !== 'succeeded') {
          return res.status(400).json({ error: "Payment not completed" });
        }
      }

      // Get the purchase record
      const [purchase] = await db.select().from(giftVoucherPurchases).where(eq(giftVoucherPurchases.id, purchaseId));
      if (!purchase) {
        return res.status(404).json({ error: "Purchase not found" });
      }

      if (purchase.paymentStatus === 'completed') {
        return res.status(400).json({ error: "Purchase already completed" });
      }

      // Generate voucher code (14 characters)
      const generateCode = () => {
        const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
        let code = 'GIFT-';
        for (let i = 0; i < 10; i++) {
          code += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return code;
      };

      let voucherCode = generateCode();
      
      // Make sure code is unique
      let attempts = 0;
      while (attempts < 10) {
        const existing = await db.select().from(shopVouchers).where(eq(shopVouchers.code, voucherCode));
        if (existing.length === 0) break;
        voucherCode = generateCode();
        attempts++;
      }

      // Calculate expiry (1 year from now)
      const expiresAt = new Date();
      expiresAt.setFullYear(expiresAt.getFullYear() + 1);

      // Create the voucher
      const [voucher] = await db.insert(shopVouchers).values({
        code: voucherCode,
        amount: purchase.amount,
        description: purchase.personalMessage ? `Gift Voucher: ${purchase.personalMessage}` : 'Gift Voucher',
        maxRedemptions: 1,
        currentRedemptions: 0,
        expiresAt,
        isActive: true,
        recipientName: purchase.recipientName,
        recipientEmail: purchase.recipientEmail,
        createdBy: purchase.buyerId || await ensureAdminUser()
      }).returning();

      // Update purchase record
      await db.update(giftVoucherPurchases)
        .set({
          voucherId: voucher.id,
          paymentStatus: 'completed',
          paymentMethod: 'stripe'
        })
        .where(eq(giftVoucherPurchases.id, purchaseId));

      // Send email to recipient
      try {
        const { sendVoucherEmail } = await import('./utils/email.js');
        await sendVoucherEmail({
          recipientEmail: purchase.recipientEmail,
          recipientName: purchase.recipientName || undefined,
          voucherCode,
          amount: parseFloat(purchase.amount),
          personalMessage: purchase.personalMessage || undefined,
          senderName: purchase.buyerName || 'Someone special',
          expiresAt: expiresAt.toISOString()
        });

        // Mark email as sent
        await db.update(giftVoucherPurchases)
          .set({
            emailSent: true,
            emailSentAt: new Date()
          })
          .where(eq(giftVoucherPurchases.id, purchaseId));
      } catch (emailError) {
        console.error('Failed to send voucher email:', emailError);
        // Don't fail the request if email fails
      }

      res.json({ success: true,
        success: true,
        voucherCode,
        amount: purchase.amount,
        recipientEmail: purchase.recipientEmail,
        expiresAt: expiresAt.toISOString()
      });
    } catch (error: any) {
      console.error('Gift voucher confirmation error:', error);
      res.status(500).json({ error: error.message || "Failed to confirm purchase" });
    }
  });

  // Confirm gift voucher purchase via DodoPay
  app.post("/api/gift-vouchers/confirm-dodopay", async (req, res) => {
    try {
      const { purchaseId, paymentId, paymentMethod, userEmail, userName, sessionId } = req.body;

      if (!purchaseId) {
        return res.status(400).json({ error: "Purchase ID required" });
      }

      // Get the purchase record
      const [purchase] = await db.select().from(giftVoucherPurchases).where(eq(giftVoucherPurchases.id, purchaseId));
      if (!purchase) {
        return res.status(404).json({ error: "Purchase not found" });
      }

      if (purchase.paymentStatus === 'completed') {
        // Already completed - return existing data
        const [existingVoucher] = await db.select().from(shopVouchers).where(eq(shopVouchers.id, purchase.voucherId!));
        return res.json({ success: true,
          success: true,
          voucherCode: existingVoucher?.code || 'UNKNOWN',
          amount: purchase.amount,
          recipientEmail: purchase.recipientEmail,
          expiresAt: existingVoucher?.expiresAt?.toISOString()
        });
      }

      // Generate voucher code (14 characters)
      const generateCode = () => {
        const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
        let code = 'GIFT-';
        for (let i = 0; i < 10; i++) {
          code += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return code;
      };

      let voucherCode = generateCode();
      
      // Make sure code is unique
      let attempts = 0;
      while (attempts < 10) {
        const existing = await db.select().from(shopVouchers).where(eq(shopVouchers.code, voucherCode));
        if (existing.length === 0) break;
        voucherCode = generateCode();
        attempts++;
      }

      // Calculate expiry (1 year from now)
      const expiresAt = new Date();
      expiresAt.setFullYear(expiresAt.getFullYear() + 1);

      // Create the voucher
      const [voucher] = await db.insert(shopVouchers).values({
        code: voucherCode,
        amount: purchase.amount,
        description: purchase.personalMessage ? `Gift Voucher: ${purchase.personalMessage}` : 'Gift Voucher',
        maxRedemptions: 1,
        currentRedemptions: 0,
        expiresAt,
        isActive: true,
        recipientName: purchase.recipientName,
        recipientEmail: purchase.recipientEmail,
        createdBy: purchase.buyerId || await ensureAdminUser()
      }).returning();

      // Update purchase record
      await db.update(giftVoucherPurchases)
        .set({
          voucherId: voucher.id,
          paymentStatus: 'completed',
          paymentMethod: paymentMethod || 'dodopay',
          paymentReference: paymentId || null
        })
        .where(eq(giftVoucherPurchases.id, purchaseId));

      // Send email to recipient
      try {
        const { sendVoucherEmail } = await import('./utils/email.js');
        await sendVoucherEmail({
          recipientEmail: purchase.recipientEmail,
          recipientName: purchase.recipientName || undefined,
          voucherCode,
          amount: parseFloat(purchase.amount),
          personalMessage: purchase.personalMessage || undefined,
          senderName: purchase.buyerName || 'Someone special',
          expiresAt: expiresAt.toISOString()
        });

        // Mark email as sent
        await db.update(giftVoucherPurchases)
          .set({
            emailSent: true,
            emailSentAt: new Date()
          })
          .where(eq(giftVoucherPurchases.id, purchaseId));
          
        console.log(`âœ… Voucher ${voucherCode} created and email sent to ${purchase.recipientEmail}`);
      } catch (emailError) {
        console.error('Failed to send voucher email:', emailError);
        // Don't fail the request if email fails
      }

      res.json({ success: true,
        success: true,
        voucherCode,
        amount: purchase.amount,
        recipientEmail: purchase.recipientEmail,
        expiresAt: expiresAt.toISOString()
      });
    } catch (error: any) {
      console.error('DodoPay gift voucher confirmation error:', error);
      res.status(500).json({ error: error.message || "Failed to confirm purchase" });
    }
  });



  // Create gift voucher purchase record (for PayPal/Paystack - no Stripe intent)
  app.post("/api/gift-vouchers/create-purchase", optionalAuth, async (req, res) => {
    try {
      const { amount, recipientEmail, recipientName, personalMessage, sendToSelf, buyerEmail, buyerName } = req.body;
      const userId = (req as AuthenticatedRequest).user?.id;

      if (!amount || amount < 5) {
        return res.status(400).json({ error: "Minimum voucher amount is $5" });
      }
      if (amount > 500) {
        return res.status(400).json({ error: "Maximum voucher amount is $500" });
      }
      if (!recipientEmail) {
        return res.status(400).json({ error: "Recipient email is required" });
      }

      const voucherCode = generateVoucherCode();
      const expiresAt = new Date();
      expiresAt.setFullYear(expiresAt.getFullYear() + 1);

      const [purchase] = await db.insert(giftVoucherPurchases).values({
        code: voucherCode,
        amount: amount.toString(),
        recipientEmail,
        recipientName: recipientName || null,
        personalMessage: personalMessage || null,
        buyerId: userId || null,
        buyerEmail: buyerEmail || null,
        buyerName: buyerName || null,
        sendToSelf: sendToSelf || false,
        paymentStatus: 'pending',
        expiresAt
      }).returning();

      res.json({ success: true,
        purchaseId: purchase.id,
        voucherCode,
        amount: purchase.amount
      });
    } catch (error: any) {
      console.error('Create gift voucher purchase error:', error);
      res.status(500).json({ error: error.message || "Failed to create purchase" });
    }
  });

  // Purchase gift voucher with wallet balance
  app.post("/api/gift-vouchers/purchase-with-wallet", requireAuth, async (req, res) => {
    try {
      const { amount, recipientEmail, recipientName, personalMessage, sendToSelf, buyerEmail, buyerName } = req.body;
      const userId = (req as AuthenticatedRequest).user?.id;

      if (!amount || amount < 5) {
        return res.status(400).json({ error: "Minimum voucher amount is $5" });
      }
      if (amount > 500) {
        return res.status(400).json({ error: "Maximum voucher amount is $500" });
      }
      if (!recipientEmail) {
        return res.status(400).json({ error: "Recipient email is required" });
      }

      const customer = await storage.getShopCustomerByUserId(userId);
      if (!customer) {
        return res.status(400).json({ error: "Customer account not found" });
      }

      const walletBalance = parseFloat(customer.walletBalance || '0');
      if (walletBalance < amount) {
        return res.status(400).json({ 
          error: "Insufficient wallet balance",
          required: amount,
          available: walletBalance
        });
      }

      const voucherCode = generateVoucherCode();
      const expiresAt = new Date();
      expiresAt.setFullYear(expiresAt.getFullYear() + 1);

      await storage.updateWalletBalance(customer.id, -amount);

      const [purchase] = await db.insert(giftVoucherPurchases).values({
        code: voucherCode,
        amount: amount.toString(),
        recipientEmail,
        recipientName: recipientName || null,
        personalMessage: personalMessage || null,
        buyerId: userId,
        buyerEmail: buyerEmail || null,
        buyerName: buyerName || null,
        sendToSelf: sendToSelf || false,
        paymentStatus: 'completed',
        paymentMethod: 'wallet',
        expiresAt
      }).returning();

      try {
        const { sendGiftVoucherEmail } = await import('./utils/email-templates.js');
        await sendGiftVoucherEmail(
          recipientEmail,
          recipientName || 'Friend',
          buyerName || 'Someone',
          voucherCode,
          parseFloat(amount.toString()),
          personalMessage || undefined
        );
      } catch (emailError) {
        console.error('Failed to send gift voucher email:', emailError);
      }

      res.json({ success: true,
        success: true,
        voucherCode,
        amount: purchase.amount,
        recipientEmail: purchase.recipientEmail,
        expiresAt: purchase.expiresAt
      });
    } catch (error: any) {
      console.error('Wallet gift voucher purchase error:', error);
      res.status(500).json({ error: error.message || "Failed to process wallet payment" });
    }
  });

  // Purchase course with wallet balance
  app.post("/api/courses/purchase-with-wallet", requireAuth, async (req, res) => {
    try {
      const { courseId, amount, couponCode } = req.body;
      const userId = (req as AuthenticatedRequest).user?.id;

      if (!courseId) {
        return res.status(400).json({ success: false, error: "Course ID is required" });
      }
      
      // Validate courseId is a valid UUID format
      const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
      if (!uuidRegex.test(courseId)) {
        return res.status(400).json({ 
          success: false, 
          error: `Invalid course ID format. Please select a valid course to purchase.`
        });
      }
      
      if (!amount || amount <= 0) {
        return res.status(400).json({ success: false, error: "Invalid amount" });
      }

      // Get customer wallet
      const customer = await storage.getShopCustomerByUserId(userId);
      if (!customer) {
        return res.status(400).json({ success: false, error: "Customer account not found" });
      }

      const walletBalance = parseFloat(customer.walletBalance || '0');
      if (walletBalance < amount) {
        return res.status(400).json({ 
          success: false,
          error: "Insufficient wallet balance",
          required: amount,
          available: walletBalance
        });
      }

      // Check if already enrolled
      const existingEnrollment = await db
        .select()
        .from(courseEnrollments)
        .where(and(
          eq(courseEnrollments.userId, userId),
          eq(courseEnrollments.courseId, courseId)
        ))
        .limit(1);

      if (existingEnrollment.length > 0) {
        return res.status(400).json({ 
          success: false, 
          error: "You are already enrolled in this course" 
        });
      }

      // Get course details
      const [course] = await db
        .select()
        .from(courses)
        .where(eq(courses.id, courseId))
        .limit(1);

      if (!course) {
        return res.status(404).json({ success: false, error: "Course not found" });
      }

      // Deduct from wallet
      await storage.updateWalletBalance(customer.id, -amount);

      // Create enrollment
      const [enrollment] = await db
        .insert(courseEnrollments)
        .values({
          userId,
          courseId,
          progress: 0,
          isActive: true
        })
        .returning();

      // Create purchase record
      const transactionId = `wallet-${courseId.substring(0, 8)}-${Date.now()}`;
      await db
        .insert(coursePurchases)
        .values({
          userId,
          courseId,
          amount: amount.toString(),
          currency: 'USD',
          paymentMethod: 'wallet',
          paymentStatus: 'completed',
          transactionId
        });

      console.log(`âœ… Course ${courseId} purchased with wallet by user ${userId}`);

      // Send purchase confirmation email
      try {
        const userProfile = await db.select().from(profiles).where(eq(profiles.userId, userId)).limit(1);
        const teacherProfile = course.userId ? await db.select().from(profiles).where(eq(profiles.userId, course.userId)).limit(1) : [];
        
        if (userProfile.length > 0 && userProfile[0].email) {
          const { sendCoursePurchaseEmail } = await import('./utils/email-templates.js');
          await sendCoursePurchaseEmail(
            userProfile[0].email,
            userProfile[0].name || 'Student',
            {
              courseName: course.title,
              teacherName: teacherProfile.length > 0 ? teacherProfile[0].name : 'EduFiliova Instructor',
              orderId: transactionId,
              price: amount.toFixed(2),
              accessType: 'Lifetime Access',
              purchaseDate: new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })
            }
          );
        }
      } catch (emailError) {
        console.error('Email sending failed (non-blocking):', emailError);
      }


      res.json({ success: true,
        success: true,
        transactionId,
        enrollmentId: enrollment.id,
        message: "Course purchased successfully"
      });
    } catch (error: any) {
      console.error('Wallet course purchase error:', error);
      res.status(500).json({ success: false, error: error.message || "Failed to process wallet payment" });
    }
  });

  // Get user's purchased gift vouchers
  app.get("/api/gift-vouchers/my-purchases", requireAuth, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;

      const purchases = await db.select()
        .from(giftVoucherPurchases)
        .where(
          and(
            eq(giftVoucherPurchases.buyerId, userId),
            eq(giftVoucherPurchases.paymentStatus, 'completed')
          )
        )
        .orderBy(desc(giftVoucherPurchases.createdAt));

      res.json(purchases);
    } catch (error: any) {
      console.error('Get gift voucher purchases error:', error);
      res.status(500).json({ error: "Failed to fetch purchases" });
    }
  });


  // Get pending voucher details (for WhatsApp checkout flow)
  app.get("/api/gift-vouchers/pending/:code", async (req, res) => {
    try {
      const { code } = req.params;

      const voucher = await db.query.giftVoucherPurchases.findFirst({
        where: eq(giftVoucherPurchases.code, code)
      });

      if (!voucher) {
        return res.status(404).json({ error: "Voucher not found" });
      }

      if (voucher.paymentStatus === 'completed') {
        return res.status(400).json({ 
          error: "This voucher has already been paid for",
          alreadyPaid: true 
        });
      }

      res.json({ success: true,
        code: voucher.code,
        amount: voucher.amount,
        recipientEmail: voucher.recipientEmail,
        recipientName: voucher.recipientName,
        personalMessage: voucher.personalMessage,
        sendToSelf: voucher.sendToSelf,
        buyerName: voucher.buyerName
      });
    } catch (error: any) {
      console.error('Get pending voucher error:', error);
      res.status(500).json({ error: "Failed to fetch voucher details" });
    }
  });

  // Create Stripe checkout session for pending voucher (for WhatsApp flow)
  app.post("/api/gift-vouchers/create-checkout-session", async (req, res) => {
    try {
      const { voucherCode } = req.body;

      if (!voucherCode) {
        return res.status(400).json({ error: "Voucher code is required" });
      }

      const voucher = await db.query.giftVoucherPurchases.findFirst({
        where: eq(giftVoucherPurchases.code, voucherCode)
      });

      if (!voucher) {
        return res.status(404).json({ error: "Voucher not found" });
      }

      if (voucher.paymentStatus === 'completed') {
        return res.status(400).json({ error: "This voucher has already been paid for" });
      }

      const stripe = await getPrimaryPaymentClient();
      if (!stripe) {
        return res.status(500).json({ error: "Payment service not configured" });
      }

      const amount = parseFloat(voucher.amount);
      const baseUrl = process.env.REPLIT_DEV_DOMAIN 
        ? `https://${process.env.REPLIT_DEV_DOMAIN}`
        : process.env.BASE_URL || process.env.APP_URL || 'https://edufiliova.com';

      const session = await stripe.checkout.sessions.create({
        payment_method_types: ['card'],
        line_items: [{
          price_data: {
            currency: 'usd',
            product_data: {
              name: `EduFiliova Gift Voucher - $${amount}`,
              description: voucher.sendToSelf 
                ? 'Gift voucher for yourself'
                : `Gift voucher for ${voucher.recipientName || voucher.recipientEmail}`,
            },
            unit_amount: Math.round(amount * 100),
          },
          quantity: 1,
        }],
        mode: 'payment',
        success_url: `${baseUrl}/checkout/voucher?code=${voucherCode}&success=true&session_id={CHECKOUT_SESSION_ID}`,
        cancel_url: `${baseUrl}/checkout/voucher?code=${voucherCode}&cancelled=true`,
        customer_email: voucher.buyerEmail || undefined,
        metadata: {
          type: 'gift_voucher',
          voucherCode,
          buyerId: voucher.buyerId || '',
          recipientEmail: voucher.recipientEmail || '',
          recipientName: voucher.recipientName || '',
          amount: amount.toString()
        }
      });

      res.json({ url: session.url, sessionId: session.id });
    } catch (error: any) {
      console.error('Create voucher checkout session error:', error);
      res.status(500).json({ error: error.message || "Failed to create checkout session" });
    }
  });

  // Complete voucher checkout after Stripe payment (for WhatsApp flow)
  app.post("/api/gift-vouchers/complete-checkout", async (req, res) => {
    try {
      const { voucherCode, sessionId } = req.body;

      if (!voucherCode || !sessionId) {
        return res.status(400).json({ error: "Voucher code and session ID are required" });
      }

      const stripe = await getPrimaryPaymentClient();
      if (!stripe) {
        return res.status(500).json({ error: "Payment service not configured" });
      }

      const session = await stripe.checkout.sessions.retrieve(sessionId);
      
      if (session.payment_status !== 'paid') {
        return res.status(400).json({ error: "Payment not completed" });
      }

      const voucher = await db.query.giftVoucherPurchases.findFirst({
        where: eq(giftVoucherPurchases.code, voucherCode)
      });

      if (!voucher) {
        return res.status(404).json({ error: "Voucher not found" });
      }

      if (voucher.paymentStatus === 'completed') {
        return res.json({ success: true,
          success: true,
          amount: voucher.amount,
          recipientEmail: voucher.recipientEmail,
          alreadyPaid: true
        });
      }

      await db.update(giftVoucherPurchases)
        .set({
          paymentStatus: 'completed',
          paymentIntentId: session.payment_intent as string,
          paymentMethod: 'stripe'
        })
        .where(eq(giftVoucherPurchases.code, voucherCode));

      try {
        const { sendGiftVoucherEmail } = await import('./utils/email-templates.js');
        await sendGiftVoucherEmail(
          voucher.recipientEmail,
          voucher.recipientName || 'Friend',
          voucher.buyerName || 'Someone',
          voucherCode,
          parseFloat(voucher.amount),
          voucher.personalMessage || undefined,
          voucher.expiresAt
        );
      } catch (emailError) {
        console.error('Failed to send gift voucher email:', emailError);
      }

      res.json({ success: true,
        success: true,
        amount: voucher.amount,
        recipientEmail: voucher.recipientEmail
      });
    } catch (error: any) {
      console.error('Complete voucher checkout error:', error);
      res.status(500).json({ error: error.message || "Failed to complete checkout" });
    }
  });
  // ============ END GIFT VOUCHER PURCHASE ROUTES ============


  // Get customer profile
  app.get("/api/shop/profile", requireAuth, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;
      let customer = await storage.getShopCustomerByUserId(userId);
      
      if (!customer) {
        const profile = await db.select().from(profiles).where(eq(profiles.userId, userId)).limit(1);
        customer = await storage.createShopCustomer({
          userId,
          fullName: profile[0]?.name || 'Customer',
          email: (req as AuthenticatedRequest).user?.email || ''
        });
      }

      res.json(customer);
    } catch (error: any) {
      console.error('Get profile error:', error);
      res.status(500).json({ error: "Failed to fetch profile" });
    }
  });

  // Update customer profile
  app.put("/api/shop/profile", requireAuth, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;
      const customer = await storage.getShopCustomerByUserId(userId);
      
      if (!customer) {
        return res.status(404).json({ error: "Customer profile not found" });
      }

      const updated = await storage.updateShopCustomer(customer.id, req.body);
      
      // Also update country in profiles table if provided
      if (req.body.country) {
        // Find country ID
        const countryRecord = await db
          .select()
          .from(countries)
          .where(eq(countries.name, req.body.country))
          .limit(1);

        await db
          .update(profiles)
          .set({
            country: req.body.country,
            countryId: countryRecord.length > 0 ? countryRecord[0].id : null
          })
          .where(eq(profiles.userId, userId));
      }
      
      res.json(updated);
    } catch (error: any) {
      console.error('Update profile error:', error);
      res.status(500).json({ error: "Failed to update profile" });
    }
  });

  // Get referral stats
  app.get("/api/shop/referral", requireAuth, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;
      const customer = await storage.getShopCustomerByUserId(userId);
      
      if (!customer) {
        return res.status(404).json({ error: "Customer profile not found" });
      }

      // Generate referral code if not exists
      if (!customer.referralCode) {
        const code = Math.random().toString(36).substring(2, 10).toUpperCase();
        await storage.updateShopCustomer(customer.id, { referralCode: code });
        customer.referralCode = code;
      }

      // Calculate reward status
      const referralCount = customer.referralCount || 0;
      const rewardThreshold = 50;
      const rewardAmount = 15;
      const earnedRewards = Math.floor(referralCount / rewardThreshold) * rewardAmount;
      const nextRewardAt = (Math.floor(referralCount / rewardThreshold) + 1) * rewardThreshold;
      const referralsToNextReward = nextRewardAt - referralCount;

      const referralLink = `${req.protocol}://${req.get('host')}?ref=${customer.referralCode}`;

      res.json({ success: true,
        success: true,
        data: {
          referralCode: customer.referralCode,
          referralLink,
          referralCount,
          earnedRewards,
          rewardThreshold,
          rewardAmount,
          referralsToNextReward: referralsToNextReward > 0 ? referralsToNextReward : 0,
        }
      });
    } catch (error: any) {
      console.error('Get referral stats error:', error);
      res.status(500).json({ error: "Failed to fetch referral stats" });
    }
  });

  // Track referral (when someone signs up with a referral code)
  app.post("/api/shop/referral/track", requireAuth, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;
      const { referralCode } = req.body;

      if (!referralCode) {
        return res.status(400).json({ error: "Referral code is required" });
      }

      const customer = await storage.getShopCustomerByUserId(userId);
      if (!customer) {
        return res.status(404).json({ error: "Customer profile not found" });
      }

      // Check if already referred
      if (customer.referredBy) {
        return res.status(400).json({ error: "You have already been referred" });
      }

      // Find referrer by code
      const referrer = await db
        .select()
        .from(shopCustomers)
        .where(eq(shopCustomers.referralCode, referralCode))
        .limit(1);

      if (referrer.length === 0) {
        return res.status(404).json({ error: "Invalid referral code" });
      }

      if (referrer[0].id === customer.id) {
        return res.status(400).json({ error: "You cannot refer yourself" });
      }

      // Update customer with referrer
      await storage.updateShopCustomer(customer.id, { referredBy: referrer[0].id });

      // Increment referrer's count
      const newCount = (referrer[0].referralCount || 0) + 1;
      await storage.updateShopCustomer(referrer[0].id, { referralCount: newCount });

      // Check if referrer reached threshold and award $15
      if (newCount % 50 === 0) {
        const newBalance = parseFloat(referrer[0].walletBalance || '0') + 15;
        await storage.updateShopCustomer(referrer[0].id, { 
          walletBalance: newBalance.toFixed(2)
        });

        // Record transaction
        await storage.createShopTransaction({
          customerId: referrer[0].id,
          type: 'credit',
          amount: '15.00',
          description: `Referral reward for ${newCount} referrals`,
          status: 'completed'
        });
      }

      res.json({ success: true, message: "Referral tracked successfully" });
    } catch (error: any) {
      console.error('Track referral error:', error);
      res.status(500).json({ error: "Failed to track referral" });
    }
  });

  // Get all active membership plans (public - for pricing page)
  app.get("/api/shop/membership-plans", async (req, res) => {
    try {
      const plans = await db
        .select()
        .from(shopMembershipPlans)
        .where(eq(shopMembershipPlans.active, true))
        .orderBy(asc(shopMembershipPlans.displayOrder));
      
      res.json({ success: true, data: plans });
    } catch (error: any) {
      console.error('Get membership plans error:', error);
      res.status(500).json({ error: "Failed to fetch membership plans" });
    }
  });

  // Get single membership plan by planId
  app.get("/api/shop/membership-plans/:planId", async (req, res) => {
    try {
      const { planId } = req.params;
      const plan = await db
        .select()
        .from(shopMembershipPlans)
        .where(and(
          eq(shopMembershipPlans.planId, planId),
          eq(shopMembershipPlans.active, true)
        ))
        .limit(1);
      
      if (plan.length === 0) {
        return res.status(404).json({ error: "Plan not found" });
      }
      
      res.json(plan[0]);
    } catch (error: any) {
      console.error('Get membership plan error:', error);
      res.status(500).json({ error: "Failed to fetch membership plan" });
    }
  });

  // Admin: Get all membership plans (including inactive)
  app.get("/api/admin/membership-plans", requireAuth, requireAdmin, async (req, res) => {
    try {
      const plans = await db
        .select()
        .from(shopMembershipPlans)
        .orderBy(asc(shopMembershipPlans.displayOrder));
      
      res.json(plans);
    } catch (error: any) {
      console.error('Admin get membership plans error:', error);
      res.status(500).json({ error: "Failed to fetch membership plans" });
    }
  });

  // Admin: Create new membership plan
  app.post("/api/admin/membership-plans", requireAuth, requireAdmin, async (req, res) => {
    try {
      // Transform numeric prices to strings if needed
      const bodyData = { ...req.body };
      if (bodyData.monthlyPrice !== undefined && typeof bodyData.monthlyPrice === 'number') {
        bodyData.monthlyPrice = bodyData.monthlyPrice.toString();
      }
      if (bodyData.yearlyPrice !== undefined && typeof bodyData.yearlyPrice === 'number') {
        bodyData.yearlyPrice = bodyData.yearlyPrice.toString();
      }
      
      const validatedData = insertShopMembershipPlanSchema.parse(bodyData);
      
      // Validate annualAdLimit is null or non-negative
      if (validatedData.annualAdLimit !== null && 
          validatedData.annualAdLimit !== undefined && 
          validatedData.annualAdLimit < 0) {
        return res.status(400).json({ error: "Annual ad limit cannot be negative" });
      }
      
      const newPlan = await db.insert(shopMembershipPlans).values(validatedData).returning();
      res.json(newPlan[0]);
    } catch (error: any) {
      console.error('Admin create membership plan error:', error);
      res.status(500).json({ error: "Failed to create membership plan" });
    }
  });

  // Admin: Update membership plan
  app.put("/api/admin/membership-plans/:id", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      
      // Transform numeric prices to strings if needed
      const bodyData = { ...req.body };
      if (bodyData.monthlyPrice !== undefined && typeof bodyData.monthlyPrice === 'number') {
        bodyData.monthlyPrice = bodyData.monthlyPrice.toString();
      }
      if (bodyData.yearlyPrice !== undefined && typeof bodyData.yearlyPrice === 'number') {
        bodyData.yearlyPrice = bodyData.yearlyPrice.toString();
      }
      
      const validatedData = insertShopMembershipPlanSchema.partial().parse(bodyData);
      
      // Validate annualAdLimit is null or non-negative
      if (validatedData.annualAdLimit !== null && 
          validatedData.annualAdLimit !== undefined && 
          validatedData.annualAdLimit < 0) {
        return res.status(400).json({ error: "Annual ad limit cannot be negative" });
      }
      
      const updated = await db
        .update(shopMembershipPlans)
        .set({ ...validatedData, updatedAt: new Date() })
        .where(eq(shopMembershipPlans.id, id))
        .returning();
      
      if (updated.length === 0) {
        return res.status(404).json({ error: "Plan not found" });
      }
      
      res.json(updated[0]);
    } catch (error: any) {
      console.error('Admin update membership plan error:', error);
      res.status(500).json({ error: "Failed to update membership plan" });
    }
  });

  // Admin: Delete membership plan
  app.delete("/api/admin/membership-plans/:id", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const deleted = await db
        .delete(shopMembershipPlans)
        .where(eq(shopMembershipPlans.id, id))
        .returning();
      
      if (deleted.length === 0) {
        return res.status(404).json({ error: "Plan not found" });
      }
      
      res.json({ message: "Plan deleted successfully" });
    } catch (error: any) {
      console.error('Admin delete membership plan error:', error);
      res.status(500).json({ error: "Failed to delete membership plan" });
    }
  });

  // ============ FREELANCER PRICING PLANS API ROUTES ============
  
  // Public: Get all active freelancer pricing plans
  app.get("/api/freelancer-pricing-plans", async (req, res) => {
    try {
      const plans = await db
        .select()
        .from(freelancerPricingPlans)
        .where(eq(freelancerPricingPlans.active, true))
        .orderBy(asc(freelancerPricingPlans.displayOrder));
      
      res.json({ success: true, data: plans });
    } catch (error: any) {
      console.error('Get freelancer pricing plans error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch freelancer pricing plans" });
    }
  });

  // Admin: Get all freelancer pricing plans (including inactive)
  app.get("/api/admin/freelancer-pricing-plans", requireAuth, requireAdmin, async (req, res) => {
    try {
      const plans = await db
        .select()
        .from(freelancerPricingPlans)
        .orderBy(asc(freelancerPricingPlans.displayOrder));
      
      res.json({ success: true, data: plans });
    } catch (error: any) {
      console.error('Admin get freelancer pricing plans error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch freelancer pricing plans" });
    }
  });

  // Admin: Create new freelancer pricing plan
  app.post("/api/admin/freelancer-pricing-plans", requireAuth, requireAdmin, async (req, res) => {
    try {
      const bodyData = { ...req.body };
      
      // Transform numeric prices to strings if needed
      if (bodyData.monthlyPrice !== undefined && typeof bodyData.monthlyPrice === 'number') {
        bodyData.monthlyPrice = bodyData.monthlyPrice.toString();
      }
      if (bodyData.yearlyPrice !== undefined && typeof bodyData.yearlyPrice === 'number') {
        bodyData.yearlyPrice = bodyData.yearlyPrice.toString();
      }
      if (bodyData.lifetimePrice !== undefined && typeof bodyData.lifetimePrice === 'number') {
        bodyData.lifetimePrice = bodyData.lifetimePrice.toString();
      }
      
      const validatedData = insertFreelancerPricingPlanSchema.parse(bodyData);
      
      const newPlan = await db.insert(freelancerPricingPlans).values(validatedData).returning();
      res.json({ success: true, data: newPlan[0] });
    } catch (error: any) {
      console.error('Admin create freelancer pricing plan error:', error);
      res.status(500).json({ success: false, error: "Failed to create freelancer pricing plan" });
    }
  });

  // Admin: Update freelancer pricing plan
  app.put("/api/admin/freelancer-pricing-plans/:id", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const bodyData = { ...req.body };
      
      // Transform numeric prices to strings if needed
      if (bodyData.monthlyPrice !== undefined && typeof bodyData.monthlyPrice === 'number') {
        bodyData.monthlyPrice = bodyData.monthlyPrice.toString();
      }
      if (bodyData.yearlyPrice !== undefined && typeof bodyData.yearlyPrice === 'number') {
        bodyData.yearlyPrice = bodyData.yearlyPrice.toString();
      }
      if (bodyData.lifetimePrice !== undefined && typeof bodyData.lifetimePrice === 'number') {
        bodyData.lifetimePrice = bodyData.lifetimePrice.toString();
      }
      
      const validatedData = insertFreelancerPricingPlanSchema.partial().parse(bodyData);
      
      const updated = await db
        .update(freelancerPricingPlans)
        .set({ ...validatedData, updatedAt: new Date() })
        .where(eq(freelancerPricingPlans.id, id))
        .returning();
      
      if (updated.length === 0) {
        return res.status(404).json({ success: false, error: "Plan not found" });
      }
      
      res.json({ success: true, data: updated[0] });
    } catch (error: any) {
      console.error('Admin update freelancer pricing plan error:', error);
      res.status(500).json({ success: false, error: "Failed to update freelancer pricing plan" });
    }
  });

  // Admin: Delete freelancer pricing plan
  app.delete("/api/admin/freelancer-pricing-plans/:id", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const deleted = await db
        .delete(freelancerPricingPlans)
        .where(eq(freelancerPricingPlans.id, id))
        .returning();
      
      if (deleted.length === 0) {
        return res.status(404).json({ success: false, error: "Plan not found" });
      }
      
      res.json({ success: true, message: "Plan deleted successfully" });
    } catch (error: any) {
      console.error('Admin delete freelancer pricing plan error:', error);
      res.status(500).json({ success: false, error: "Failed to delete freelancer pricing plan" });
    }
  });

  // Confirm freelancer subscription payment (DodoPay and other gateways)
  app.post("/api/freelancer/subscription/confirm", requireAuth, async (req: AuthenticatedRequest, res: Response) => {
    try {
      const { paymentId, planId, planName, amount, billingCycle, gateway } = req.body;
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      // Validate that planId exists and is active
      if (!planId) {
        return res.status(400).json({ success: false, error: 'Plan ID is required' });
      }

      const validPlan = await db
        .select()
        .from(freelancerPricingPlans)
        .where(and(eq(freelancerPricingPlans.planId, planId), eq(freelancerPricingPlans.active, true)))
        .limit(1);

      if (validPlan.length === 0) {
        return res.status(400).json({ success: false, error: 'Invalid or inactive plan' });
      }

      // Verify the amount matches the plan (prevent tampering)
      const plan = validPlan[0];
      let expectedPrice = 0;
      if (billingCycle === 'yearly' && plan.yearlyPrice) {
        expectedPrice = parseFloat(plan.yearlyPrice);
      } else if (billingCycle === 'lifetime' && plan.lifetimePrice) {
        expectedPrice = parseFloat(plan.lifetimePrice);
      } else if (plan.monthlyPrice) {
        expectedPrice = parseFloat(plan.monthlyPrice);
      }

      // Allow small tolerance for rounding
      if (Math.abs(amount - expectedPrice) > 0.01) {
        console.warn(`Freelancer plan amount mismatch: expected ${expectedPrice}, got ${amount}`);
      }

      // Calculate plan expiry based on billing cycle
      const planExpiry = new Date();
      if (billingCycle === 'yearly') {
        planExpiry.setFullYear(planExpiry.getFullYear() + 1);
      } else if (billingCycle === 'lifetime') {
        planExpiry.setFullYear(planExpiry.getFullYear() + 100);
      } else {
        planExpiry.setMonth(planExpiry.getMonth() + 1);
      }

      // Update user profile with freelancer plan
      await db.update(profiles)
        .set({ 
          legacyPlan: planId,
          planExpiry: planExpiry,
          updatedAt: new Date()
        })
        .where(eq(profiles.userId, userId));

      // Record the transaction in payments table
      try {
        await db.insert(payments).values({
          userId,
          amount: amount?.toString() || '0',
          currency: 'USD',
          status: 'succeeded',
          gateway: gateway || 'dodopay',
          paymentIntentId: paymentId || `dodo_${Date.now()}`,
          description: `Freelancer Plan: ${plan.name} (${billingCycle})`,
          metadata: { planId, planName: plan.name, billingCycle },
          createdAt: new Date()
        });
      } catch (paymentLogError) {
        console.warn('Could not log freelancer payment:', paymentLogError);
      }

      console.log(`âœ… Freelancer plan confirmed: ${plan.name} for user ${userId}, expires ${planExpiry.toISOString()}`);

      res.json({ 
        success: true, 
        message: 'Freelancer subscription confirmed',
        planExpiry: planExpiry.toISOString()
      });
    } catch (error: any) {
      console.error('Confirm freelancer subscription error:', error);
      res.status(500).json({ success: false, error: 'Failed to confirm freelancer subscription' });
    }
  });
  app.post("/api/freelancer/verify-email", async (req, res) => {
    try {
      const { email, code } = req.body;

      if (!email || !code) {
        return res.status(400).json({ success: false, error: "Email and verification code are required" });
      }

      // Find verification code
      const verification = await db
        .select()
        .from(verificationCodes)
        .where(
          and(
            eq(verificationCodes.contactInfo, email),
            eq(verificationCodes.type, 'email'),
            eq(verificationCodes.isUsed, false)
          )
        )
        .limit(1);

      if (verification.length === 0) {
        return res.status(400).json({ success: false, error: "Invalid or expired verification code" });
      }

      // Check if code matches and hasn't expired
      if (verification[0].code !== code || new Date() > verification[0].expiresAt) {
        return res.status(400).json({ success: false, error: "Invalid or expired verification code" });
      }

      const userData = verification[0].userData as any;

      // Generate unique user ID
      let userIdToUse = generateUserId();

      // Create user
      const newUser = await db.insert(users).values({
        userId: userIdToUse,
        email: userData.email,
        passwordHash: userData.passwordHash,
        isEmailVerified: true,
        isPhoneVerified: true
      }).returning();

      // Create profile
      const newProfile = await db.insert(profiles).values({
        userId: newUser[0].id,
        name: userData.name,
        age: userData.age,
        grade: userData.grade,
        educationLevel: userData.educationLevel,
        country: userData.country,
        role: 'freelancer',
        status: 'active'
      }).returning();

      // Mark verification as used
      await db
        .update(verificationCodes)
        .set({ isUsed: true })
        .where(eq(verificationCodes.id, verification[0].id));

      // Send welcome email
      await sendEmail(
        userData.email,
        'Welcome to EduFiliova Freelancer Platform!',
        getEmailTemplate('welcome', { 
          name: userData.name,
          loginUrl: `${req.protocol}://${req.get('host')}`
        })
      );

      res.json({ success: true,
        success: true,
        message: "Email verified successfully! Your freelancer account has been created.",
        user: {
          id: newUser[0].id,
          userId: newUser[0].userId,
          email: newUser[0].email
        },
        profile: newProfile[0]
      });

    } catch (error: any) {
      console.error('Freelancer email verification error:', error);
      res.status(500).json({ success: false, error: "Verification failed" });
    }
  });

  // Convert existing user to freelancer
  app.post("/api/user/convert-to-freelancer", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user?.id;
      
      if (!userId) {
        return res.status(401).json({ success: false, error: "Not authenticated" });
      }

      // Update user profile to freelancer role
      await db
        .update(profiles)
        .set({ role: 'freelancer' })
        .where(eq(profiles.userId, userId));

      // Get updated profile
      const updatedProfile = await db
        .select()
        .from(profiles)
        .where(eq(profiles.userId, userId))
        .limit(1);

      res.json({ success: true,
        success: true,
        message: "Successfully converted to freelancer account",
        profile: updatedProfile[0]
      });

    } catch (error: any) {
      console.error('Convert to freelancer error:', error);
      res.status(500).json({ success: false, error: "Conversion failed" });
    }
  });

  // User settings endpoint
  app.post('/api/user/settings', async (req, res) => {
    try {
      const { userId, ...settings } = req.body;
      
      if (!userId) {
        return res.status(400).json({ error: 'User ID is required' });
      }

      // Check if user settings exist
      const existingSettings = await db
        .select()
        .from(userOtherSettings)
        .where(eq(userOtherSettings.userId, userId))
        .limit(1);

      if (existingSettings.length === 0) {
        // Create new settings
        await db.insert(userOtherSettings).values({
          userId,
          ...settings,
          updatedAt: new Date()
        });
      } else {
        // Update existing settings
        await db
          .update(userOtherSettings)
          .set({
            ...settings,
            updatedAt: new Date()
          })
          .where(eq(userOtherSettings.userId, userId));
      }

      res.json({ success: true });
    } catch (error: any) {
      console.error('Error updating user settings:', error);
      res.status(500).json({ error: 'Failed to update settings' });
    }
  });

  // =======================
  // CHAT THREAD API ROUTES
  // =======================

  // Helper function to check subscription limits for freelancer contact
  // Uses storage interface for consistent data access
  const checkContactLimits = async (userId: string) => {
    // Get user's subscription using storage interface
    const subscription = await storage.getUserActiveSubscription(userId);

    // Default limits for different plans
    const planLimits = {
      free: { threadsPerDay: 2, messagesPerDay: 10 },
      basic: { threadsPerDay: 10, messagesPerDay: 100 },
      premium: { threadsPerDay: -1, messagesPerDay: -1 }, // unlimited
      pro: { threadsPerDay: -1, messagesPerDay: -1 } // unlimited
    };

    const plan = subscription?.planName || 'free';
    const limits = planLimits[plan as keyof typeof planLimits] || planLimits.free;

    // Check today's usage using storage interface
    const threadsToday = await storage.getTodayThreadCount(userId);
    const messagesToday = await storage.getTodayMessageCount(userId);

    return {
      canCreateThread: limits.threadsPerDay === -1 || threadsToday < limits.threadsPerDay,
      canSendMessage: limits.messagesPerDay === -1 || messagesToday < limits.messagesPerDay,
      plan,
      usage: {
        threadsToday,
        messagesToday
      },
      limits
    };
  };


  // Create or get chat thread
  app.post('/api/chat/threads', requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      // Validate request body using Zod schema
      const validatedData = insertChatThreadSchema.omit({ id: true, createdAt: true, updatedAt: true }).parse(req.body);
      const { freelancerId, customerId, projectId } = validatedData;
      
      // Verify user is either the freelancer or customer (use profile ID)
      if (req.user!.profile.id !== freelancerId && req.user!.profile.id !== customerId) {
        return res.status(403).json({ success: false, error: 'Not authorized to create this thread' });
      }

      // Check subscription limits for customers contacting freelancers
      if (req.user!.profile.id === customerId) {
        const limits = await checkContactLimits(req.user!.profile.id); // Use profile ID for consistent ID domain
        if (!limits.canCreateThread) {
          return res.status(429).json({ 
            success: false, 
            error: 'Daily thread limit reached. Please upgrade your plan for more contacts.',
            limits: limits.limits,
            usage: limits.usage
          });
        }
      }

      // Use storage interface to get or create thread
      const thread = await storage.getOrCreateChatThread(freelancerId, customerId, projectId);
      
      res.json({ success: true, data: thread });
    } catch (error: any) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ success: false, error: 'Invalid request data', details: error.errors });
      }
      console.error('Create chat thread error:', error);
      res.status(500).json({ success: false, error: 'Failed to create chat thread' });
    }
  });

  // Get user's chat threads
  app.get('/api/chat/threads', requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      // Use profile ID for consistent user identification
      const threads = await storage.getChatThreadsByUser(req.user!.profile.id);
      
      // Get thread previews with last message and participant info
      const threadsWithDetails = await Promise.all(threads.map(async (thread) => {
        const messages = await storage.getMessagesByThread(thread.id, { limit: 1 });
        const participants = await storage.getChatParticipantsByThread(thread.id);
        
        return {
          ...thread,
          lastMessage: messages[0] || null,
          participants
        };
      }));

      res.json({ success: true, data: threadsWithDetails });
    } catch (error: any) {
      console.error('Get chat threads error:', error);
      res.status(500).json({ success: false, error: 'Failed to get chat threads' });
    }
  });

  // Send message to thread
  app.post('/api/chat/threads/:threadId/messages', requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const { threadId } = req.params;
      
      // Validate request body using Zod schema
      const validatedData = insertMessageSchema.omit({ 
        id: true, 
        createdAt: true, 
        updatedAt: true, 
        senderId: true, 
        threadId: true 
      }).parse(req.body);
      
      const { content, fileType } = validatedData;

      if (!content?.trim()) {
        return res.status(400).json({ success: false, error: 'Message content is required' });
      }

      // Verify user is a participant in this thread
      const participants = await storage.getChatParticipantsByThread(threadId);
      const isParticipant = participants.some(p => p.userId === req.user!.profile.id);
      
      if (!isParticipant) {
        return res.status(403).json({ success: false, error: 'Not authorized to send messages in this thread' });
      }

      // Check subscription limits using profile ID for consistent ID domain
      const limits = await checkContactLimits(req.user!.profile.id);
      if (!limits.canSendMessage) {
        return res.status(429).json({ 
          success: false, 
          error: 'Daily message limit reached. Please upgrade your plan.',
          limits: limits.limits,
          usage: limits.usage
        });
      }

      // Create message using storage interface
      const message = await storage.createMessage({
        senderId: req.user!.profile.id,
        threadId,
        content: content.trim(),
        fileType: fileType || null
      });

      // Broadcast to thread participants via WebSocket
      try {
        for (const participant of participants) {
          if (participant.userId !== req.user!.profile.id) {
            const userWs = (global as any).wsClients?.get(participant.userId);
            if (userWs && userWs.readyState === 1) {
              userWs.send(JSON.stringify({
                type: 'thread_message',
                threadId,
                message,
                sender: {
                  id: req.user!.profile.id,
                  name: req.user!.profile.name,
                  avatarUrl: req.user!.profile.avatarUrl
                }
              }));
            }
          }
        }
      } catch (wsError) {
        console.log('WebSocket broadcast failed:', wsError);
      }

      res.json({ success: true, data: message });
    } catch (error: any) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ success: false, error: 'Invalid request data', details: error.errors });
      }
      console.error('Send thread message error:', error);
      res.status(500).json({ success: false, error: 'Failed to send message' });
    }
  });

  // Get thread messages with pagination
  app.get('/api/chat/threads/:threadId/messages', requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const { threadId } = req.params;
      const { limit = 50, before } = req.query;

      // Verify user is a participant
      const participants = await storage.getChatParticipantsByThread(threadId);
      const isParticipant = participants.some(p => p.userId === req.user!.profile.id);
      
      if (!isParticipant) {
        return res.status(403).json({ success: false, error: 'Not authorized to view this thread' });
      }

      const messages = await storage.getMessagesByThread(threadId, {
        limit: parseInt(limit as string),
        before: before as string
      });

      res.json({ success: true, data: messages });
    } catch (error: any) {
      console.error('Get thread messages error:', error);
      res.status(500).json({ success: false, error: 'Failed to get thread messages' });
    }
  });

  // Add participant to thread (admin or thread creator only)
  app.post('/api/chat/threads/:threadId/participants', requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const { threadId } = req.params;
      
      // Validate request body using Zod schema
      const validatedData = insertChatParticipantSchema.omit({ 
        id: true, 
        createdAt: true, 
        threadId: true 
      }).parse(req.body);
      
      const { userId, role = 'member' } = validatedData;

      // Check if thread exists
      const thread = await storage.getChatThreadById(threadId);
      if (!thread) {
        return res.status(404).json({ success: false, error: 'Thread not found' });
      }

      // Verify requester is already a participant
      const participants = await storage.getChatParticipantsByThread(threadId);
      const isParticipant = participants.some(p => p.userId === req.user!.profile.id);
      
      if (!isParticipant && req.user!.role !== 'admin') {
        return res.status(403).json({ success: false, error: 'Not authorized to add participants' });
      }

      const participant = await storage.createChatParticipant({
        threadId,
        userId,
        role: role as 'admin' | 'member'
      });

      res.json({ success: true, data: participant });
    } catch (error: any) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ success: false, error: 'Invalid request data', details: error.errors });
      }
      console.error('Add participant error:', error);
      res.status(500).json({ success: false, error: 'Failed to add participant' });
    }
  });

  // Get thread participants
  app.get('/api/chat/threads/:threadId/participants', requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const { threadId } = req.params;

      // Verify user is a participant
      const participants = await storage.getChatParticipantsByThread(threadId);
      const isParticipant = participants.some(p => p.userId === req.user!.profile.id);
      
      if (!isParticipant) {
        return res.status(403).json({ success: false, error: 'Not authorized to view participants' });
      }

      res.json({ success: true, data: participants });
    } catch (error: any) {
      console.error('Get participants error:', error);
      res.status(500).json({ success: false, error: 'Failed to get participants' });
    }
  });

  // Get chat thread by ID
  app.get('/api/chat/threads/:threadId', requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const { threadId } = req.params;

      // Verify user is a participant
      const participants = await storage.getChatParticipantsByThread(threadId);
      const isParticipant = participants.some(p => p.userId === req.user!.profile.id);
      
      if (!isParticipant) {
        return res.status(403).json({ success: false, error: 'Not authorized to view this thread' });
      }

      const thread = await storage.getChatThreadById(threadId);
      if (!thread) {
        return res.status(404).json({ success: false, error: 'Thread not found' });
      }

      res.json({ success: true, data: { ...thread, participants } });
    } catch (error: any) {
      console.error('Get chat thread error:', error);
      res.status(500).json({ success: false, error: 'Failed to get chat thread' });
    }
  });

  // Update thread status (for admins)
  app.patch('/api/chat/threads/:threadId', requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const { threadId } = req.params;
      
      // Validate request body - allow partial updates for status and subject
      const updateSchema = z.object({
        status: z.string().optional(),
        subject: z.string().optional()
      });
      
      const validatedData = updateSchema.parse(req.body);
      const { status, subject } = validatedData;

      // Only admins or participants can update thread
      const participants = await storage.getChatParticipantsByThread(threadId);
      const isParticipant = participants.some(p => p.userId === req.user!.profile.id);
      
      if (!isParticipant && req.user!.role !== 'admin') {
        return res.status(403).json({ success: false, error: 'Not authorized to update this thread' });
      }

      const updates: any = {};
      if (status) updates.status = status;
      if (subject) updates.subject = subject;

      const updatedThread = await storage.updateChatThread(threadId, updates);
      if (!updatedThread) {
        return res.status(404).json({ success: false, error: 'Thread not found' });
      }

      res.json({ success: true, data: updatedThread });
    } catch (error: any) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ success: false, error: 'Invalid request data', details: error.errors });
      }
      console.error('Update chat thread error:', error);
      res.status(500).json({ success: false, error: 'Failed to update chat thread' });
    }
  });

  // =======================
  // TASKS CRUD API Routes
  // =======================

  // Get all tasks for a user
  app.get('/api/tasks/:userId', async (req, res) => {
    try {
      const { userId } = req.params;
      const { status } = req.query;

      // Convert userId to UUID format
      const userUuid = await getUserUuidByTextId(userId);
      if (!userUuid) {
        return res.status(404).json({ success: false, error: 'User not found' });
      }

      let query = db
        .select()
        .from(tasks)
        .where(eq(tasks.userId, userUuid))
        .orderBy(desc(tasks.createdAt));

      // Filter by status if provided
      if (status && status !== 'all') {
        query = query.where(and(
          eq(tasks.userId, userUuid),
          eq(tasks.status, status as any)
        ));
      }

      const userTasks = await query;
      res.json({ success: true, data: userTasks });
    } catch (error: any) {
      console.error('Error fetching tasks:', error);
      res.status(500).json({ error: 'Failed to fetch tasks' });
    }
  });

  // Create a new task
  app.post('/api/tasks', async (req, res) => {
    try {
      const { userId, title, description, subject, dueDate, status = 'todo', priority = 'medium', tags = [] } = req.body;

      if (!userId || !title || !subject || !dueDate) {
        return res.status(400).json({
          success: false,
          error: 'Missing required fields: userId, title, subject, dueDate'
        });
      }

      const newTask = await db
        .insert(tasks)
        .values({
          userId,
          title,
          description,
          subject,
          dueDate: new Date(dueDate),
          status,
          priority,
          tags
        })
        .returning();

      res.json({ 
        success: true, 
        data: newTask[0],
        message: 'Task created successfully'
      });
    } catch (error: any) {
      console.error('Error creating task:', error);
      res.status(500).json({ error: 'Failed to create task' });
    }
  });

  // Update a task
  app.put('/api/tasks/:taskId', async (req, res) => {
    try {
      const { taskId } = req.params;
      const { userId, title, description, subject, dueDate, status, priority, tags, progress, commentsCount } = req.body;

      if (!userId) {
        return res.status(400).json({
          success: false,
          error: 'User ID is required'
        });
      }

      const updateData: any = { updatedAt: new Date() };
      if (title !== undefined) updateData.title = title;
      if (description !== undefined) updateData.description = description;
      if (subject !== undefined) updateData.subject = subject;
      if (dueDate !== undefined) updateData.dueDate = new Date(dueDate);
      if (status !== undefined) updateData.status = status;
      if (priority !== undefined) updateData.priority = priority;
      if (tags !== undefined) updateData.tags = tags;
      if (progress !== undefined) updateData.progress = progress;
      if (commentsCount !== undefined) updateData.commentsCount = commentsCount;

      const updatedTask = await db
        .update(tasks)
        .set(updateData)
        .where(and(
          eq(tasks.id, taskId),
          eq(tasks.userId, userId)
        ))
        .returning();

      if (updatedTask.length === 0) {
        return res.status(404).json({ error: 'Task not found or not authorized' });
      }

      res.json({ 
        success: true, 
        data: updatedTask[0],
        message: 'Task updated successfully'
      });
    } catch (error: any) {
      console.error('Error updating task:', error);
      res.status(500).json({ error: 'Failed to update task' });
    }
  });

  // Delete a task
  app.delete('/api/tasks/:taskId', async (req, res) => {
    try {
      const { taskId } = req.params;
      const { userId } = req.body;

      if (!userId) {
        return res.status(400).json({
          success: false,
          error: 'User ID is required'
        });
      }

      const deletedTask = await db
        .delete(tasks)
        .where(and(
          eq(tasks.id, taskId),
          eq(tasks.userId, userId)
        ))
        .returning();

      if (deletedTask.length === 0) {
        return res.status(404).json({ error: 'Task not found or not authorized' });
      }

      res.json({ 
        success: true, 
        message: 'Task deleted successfully'
      });
    } catch (error: any) {
      console.error('Error deleting task:', error);
      res.status(500).json({ error: 'Failed to delete task' });
    }
  });

  // =======================
  // STUDY NOTES CRUD API Routes
  // =======================

  // Get all notes for a user
  app.get('/api/notes/:userId', async (req, res) => {
    try {
      const { userId } = req.params;

      const userNotes = await db
        .select()
        .from(studyNotes)
        .where(eq(studyNotes.userId, userId))
        .orderBy(desc(studyNotes.updatedAt));

      res.json({ success: true, data: userNotes });
    } catch (error: any) {
      console.error('Error fetching notes:', error);
      res.status(500).json({ error: 'Failed to fetch notes' });
    }
  });

  // Create a new note
  app.post('/api/notes', async (req, res) => {
    try {
      const { userId, title, content, subject, color = '#42fa76' } = req.body;

      if (!userId || !title || !content || !subject) {
        return res.status(400).json({
          success: false,
          error: 'Missing required fields: userId, title, content, subject'
        });
      }

      const newNote = await db
        .insert(studyNotes)
        .values({
          userId,
          title,
          content,
          subject,
          color
        })
        .returning();

      res.status(201).json({ 
        success: true, 
        data: newNote[0],
        message: 'Note created successfully'
      });
    } catch (error: any) {
      console.error('Error creating note:', error);
      res.status(500).json({ error: 'Failed to create note' });
    }
  });

  // Update an existing note
  app.put('/api/notes/:noteId', async (req, res) => {
    try {
      const { noteId } = req.params;
      const { userId, title, content, subject, color } = req.body;

      if (!userId) {
        return res.status(400).json({
          success: false,
          error: 'User ID is required'
        });
      }

      const updateData: any = { updatedAt: new Date() };
      if (title !== undefined) updateData.title = title;
      if (content !== undefined) updateData.content = content;
      if (subject !== undefined) updateData.subject = subject;
      if (color !== undefined) updateData.color = color;

      const updatedNote = await db
        .update(studyNotes)
        .set(updateData)
        .where(and(
          eq(studyNotes.id, noteId),
          eq(studyNotes.userId, userId)
        ))
        .returning();

      if (updatedNote.length === 0) {
        return res.status(404).json({ error: 'Note not found or not authorized' });
      }

      res.json({ 
        success: true, 
        data: updatedNote[0],
        message: 'Note updated successfully'
      });
    } catch (error: any) {
      console.error('Error updating note:', error);
      res.status(500).json({ error: 'Failed to update note' });
    }
  });

  // Delete a note
  app.delete('/api/notes/:noteId', async (req, res) => {
    try {
      const { noteId } = req.params;
      const { userId } = req.body;

      if (!userId) {
        return res.status(400).json({
          success: false,
          error: 'User ID is required'
        });
      }

      const deletedNote = await db
        .delete(studyNotes)
        .where(and(
          eq(studyNotes.id, noteId),
          eq(studyNotes.userId, userId)
        ))
        .returning();

      if (deletedNote.length === 0) {
        return res.status(404).json({ error: 'Note not found or not authorized' });
      }

      res.json({ 
        success: true, 
        message: 'Note deleted successfully'
      });
    } catch (error: any) {
      console.error('Error deleting note:', error);
      res.status(500).json({ error: 'Failed to delete note' });
    }
  });

  // =======================
  // ANNOUNCEMENTS API Routes
  // =======================

  // Get announcements for a student (based on their grade and subjects)
  app.get('/api/announcements/:userId', async (req, res) => {
    try {
      const { userId } = req.params; // This is the text ID like "T2509P002"

      // Convert text userId to UUID
      const userUuid = await getUserUuidByTextId(userId);
      if (!userUuid) {
        return res.json({ 
          success: true, 
          data: [] 
        });
      }

      // Get student profile to determine grade
      const [userProfile] = await db
        .select()
        .from(profiles)
        .where(eq(profiles.userId, userUuid));

      if (!userProfile) {
        // If no profile, return empty announcements (user needs to complete setup)
        return res.json({ 
          success: true, 
          data: [] 
        });
      }

      // Fetch announcements that target this student
      const userAnnouncements = await db
        .select()
        .from(announcements)
        .where(and(
          eq(announcements.isActive, true),
          or(
            eq(announcements.targetAudience, 'all'),
            eq(announcements.targetGrade, userProfile.grade)
          )
        ))
        .orderBy(desc(announcements.createdAt));

      // Check which announcements the user has read
      const readAnnouncements = await db
        .select({ announcementId: announcementReads.announcementId })
        .from(announcementReads)
        .where(eq(announcementReads.userId, userUuid));

      const readAnnouncementIds = new Set(readAnnouncements.map(r => r.announcementId));

      const announcementsWithReadStatus = userAnnouncements.map(announcement => ({
        ...announcement,
        authorId: announcement.teacherId,
        authorName: 'EduFiliova Support',
        authorRole: 'admin',
        type: 'general',
        publishedAt: announcement.createdAt,
        isRead: readAnnouncementIds.has(announcement.id)
      }));

      res.json({ 
        success: true, 
        data: announcementsWithReadStatus 
      });
    } catch (error: any) {
      console.error('Error fetching announcements:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to fetch announcements' 
      });
    }
  });

  // Mark announcement as read
  app.post('/api/announcements/:announcementId/read', async (req, res) => {
    try {
      const { announcementId } = req.params;
      const { userId } = req.body;

      if (!userId) {
        return res.status(400).json({
          success: false,
          error: 'User ID is required'
        });
      }

      // Check if already read
      const existingRead = await db
        .select()
        .from(announcementReads)
        .where(and(
          eq(announcementReads.announcementId, announcementId),
          eq(announcementReads.userId, userId)
        ));

      if (existingRead.length === 0) {
        // Mark as read
        await db
          .insert(announcementReads)
          .values({
            announcementId,
            userId
          });
      }

      res.json({ 
        success: true, 
        message: 'Announcement marked as read' 
      });
    } catch (error: any) {
      console.error('Error marking announcement as read:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to mark announcement as read' 
      });
    }
  });

  // Create announcement (Teachers/Admins only)
  app.post('/api/announcements', async (req, res) => {
    try {
      const { 
        teacherId, 
        title, 
        content, 
        priority = 'normal',
        targetAudience = 'all',
        targetGrade,
        targetStudentIds = [],
        expiresAt
      } = req.body;

      if (!teacherId || !title || !content) {
        return res.status(400).json({
          success: false,
          error: 'Missing required fields: teacherId, title, content'
        });
      }

      // Convert teacherId to UUID format if needed
      const teacherUuid = await getUserUuidByTextId(teacherId);
      if (!teacherUuid) {
        return res.status(404).json({
          success: false,
          error: 'Teacher not found'
        });
      }

      // Get author info
      const [author] = await db
        .select({
          name: profiles.name,
          role: profiles.role
        })
        .from(profiles)
        .where(eq(profiles.userId, teacherUuid));

      if (!author) {
        return res.status(404).json({
          success: false,
          error: 'Author not found'
        });
      }

      // Check if user is teacher or admin
      if (!['teacher', 'admin'].includes(author.role)) {
        return res.status(403).json({
          success: false,
          error: 'Only teachers and admins can create announcements'
        });
      }

      const newAnnouncement = await db
        .insert(announcements)
        .values({
          teacherId: teacherUuid,
          title,
          content,
          priority,
          targetAudience,
          targetGrade: targetGrade ? parseInt(targetGrade.toString()) : null,
          targetStudentIds,
          expiresAt: expiresAt ? new Date(expiresAt) : null
        })
        .returning();

      // Broadcast to connected WebSocket clients
      const announcementData = {
        type: 'new_announcement',
        data: newAnnouncement[0]
      };

      // Send to all connected students
      wsClients.forEach((client, clientId) => {
        if (client.readyState === WebSocket.OPEN) {
          client.send(JSON.stringify(announcementData));
        }
      });

      res.status(201).json({ 
        success: true, 
        data: newAnnouncement[0],
        message: 'Announcement created successfully'
      });
    } catch (error: any) {
      console.error('Error creating announcement:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to create announcement' 
      });
    }
  });

  // Get unread announcements count
  app.get('/api/announcements/:userId/unread-count', async (req, res) => {
    try {
      const { userId } = req.params;

      // Get student profile to determine grade
      const [userProfile] = await db
        .select()
        .from(profiles)
        .where(eq(profiles.userId, userId));

      if (!userProfile) {
        // If no profile, return zero unread count
        return res.json({ 
          success: true, 
          unreadCount: 0 
        });
      }

      // Count announcements that target this student
      const [totalCount] = await db
        .select({ count: count() })
        .from(announcements)
        .where(and(
          eq(announcements.isActive, true),
          or(
            eq(announcements.targetAudience, 'all'),
            eq(announcements.targetGrade, userProfile.grade)
          )
        ));

      // Count read announcements
      const [readCount] = await db
        .select({ count: count() })
        .from(announcementReads)
        .innerJoin(announcements, eq(announcementReads.announcementId, announcements.id))
        .where(and(
          eq(announcementReads.userId, userId),
          eq(announcements.isActive, true),
          or(
            eq(announcements.targetAudience, 'all'),
            eq(announcements.targetGrade, userProfile.grade)
          )
        ));

      const unreadCount = (totalCount?.count || 0) - (readCount?.count || 0);

      res.json({ 
        success: true, 
        unreadCount 
      });
    } catch (error: any) {
      console.error('Error fetching unread announcements count:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to fetch unread count' 
      });
    }
  });

  // Admin Routes for Announcements Management
  // Get all announcements for admin dashboard
  app.get('/api/admin/announcements', requireAuth, requireAdmin, async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user || user.role !== 'admin') {
        return res.status(403).json({
          success: false,
          error: 'Admin access required'
        });
      }

      const allAnnouncements = await db
        .select()
        .from(announcements)
        .orderBy(desc(announcements.createdAt));

      res.json({ 
        success: true, 
        data: allAnnouncements 
      });
    } catch (error: any) {
      console.error('Error fetching admin announcements:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to fetch announcements' 
      });
    }
  });

  // Update announcement (admin only)
  app.put('/api/admin/announcements/:id', requireAuth, requireAdmin, async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user || user.role !== 'admin') {
        return res.status(403).json({
          success: false,
          error: 'Admin access required'
        });
      }

      const { id } = req.params;
      const { title, content, priority, targetAudience, targetGrade, isActive } = req.body;

      if (!title || !content) {
        return res.status(400).json({
          success: false,
          error: 'Title and content are required'
        });
      }

      const updatedAnnouncement = await db
        .update(announcements)
        .set({
          title,
          content,
          priority: priority || 'normal',
          targetAudience: targetAudience || 'all',
          targetGrade: targetAudience === 'grade_specific' ? targetGrade : null,
          isActive: isActive !== undefined ? isActive : true,
          updatedAt: new Date()
        })
        .where(eq(announcements.id, id))
        .returning();

      if (updatedAnnouncement.length === 0) {
        return res.status(404).json({
          success: false,
          error: 'Announcement not found'
        });
      }

      res.json({ 
        success: true, 
        data: updatedAnnouncement[0],
        message: 'Announcement updated successfully'
      });
    } catch (error: any) {
      console.error('Error updating announcement:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to update announcement' 
      });
    }
  });

  // Delete announcement (admin only)
  app.delete('/api/admin/announcements/:id', requireAuth, requireAdmin, async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user || user.role !== 'admin') {
        return res.status(403).json({
          success: false,
          error: 'Admin access required'
        });
      }

      const { id } = req.params;

      const deletedAnnouncement = await db
        .delete(announcements)
        .where(eq(announcements.id, id))
        .returning();

      if (deletedAnnouncement.length === 0) {
        return res.status(404).json({
          success: false,
          error: 'Announcement not found'
        });
      }

      res.json({ 
        success: true, 
        message: 'Announcement deleted successfully'
      });
    } catch (error: any) {
      console.error('Error deleting announcement:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to delete announcement' 
      });
    }
  });


  // ============================================
  // BLOG POSTS ROUTES
  // ============================================
  
  // Get all blog posts (admin)
  app.get('/api/admin/blog-posts', requireAuth, requireAdmin, async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user || user.role !== 'admin') {
        return res.status(403).json({
          success: false,
          error: 'Admin access required'
        });
      }

      const allPosts = await db
        .select()
        .from(blogPosts)
        .orderBy(desc(blogPosts.createdAt));

      res.json(allPosts);
    } catch (error: any) {
      console.error('Error fetching admin blog posts:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to fetch blog posts' 
      });
    }
  });

  // Create blog post (admin)
  app.post('/api/admin/blog-posts', requireAuth, requireAdmin, async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user || user.role !== 'admin') {
        return res.status(403).json({
          success: false,
          error: 'Admin access required'
        });
      }

      const { title, excerpt, content, category, coverImage, youtubeUrl, isPublished } = req.body;

      if (!title || !content) {
        return res.status(400).json({ 
          success: false, 
          error: 'Title and content are required' 
        });
      }

      // Generate slug from title
      const slug = title.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '');

      // Check if slug already exists
      const [existing] = await db
        .select()
        .from(blogPosts)
        .where(eq(blogPosts.slug, slug))
        .limit(1);

      if (existing) {
        return res.status(400).json({ 
          success: false, 
          error: 'A blog post with this title already exists' 
        });
      }

      // Get user profile for author info
      const [profile] = await db
        .select()
        .from(profiles)
        .where(eq(profiles.userId, user.id))
        .limit(1);

      if (!profile) {
        return res.status(400).json({ 
          success: false, 
          error: 'User profile not found' 
        });
      }

      // Create the blog post
      const [newPost] = await db
        .insert(blogPosts)
        .values({
          title,
          slug,
          excerpt: excerpt || '',
          content,
          category: category || 'General',
          coverImage: coverImage || null,
          youtubeUrl: youtubeUrl || null,
          authorId: user.id,
          authorName: profile.name,
          authorAvatar: profile.avatarUrl || null,
          isPublished: isPublished || false,
          publishedAt: isPublished ? new Date() : null,
          createdAt: new Date(),
          updatedAt: new Date()
        })
        .returning();

      res.json({ 
        success: true, 
        data: newPost, 
        message: 'Blog post created successfully' 
      });
    } catch (error: any) {
      console.error('Error creating blog post:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to create blog post' 
      });
    }
  });

  // Update blog post (admin)
  app.put('/api/admin/blog-posts/:id', requireAuth, requireAdmin, async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user || user.role !== 'admin') {
        return res.status(403).json({
          success: false,
          error: 'Admin access required'
        });
      }

      const { id } = req.params;
      const { title, excerpt, content, category, coverImage, youtubeUrl, isPublished } = req.body;

      if (!title || !content) {
        return res.status(400).json({ 
          success: false, 
          error: 'Title and content are required' 
        });
      }

      // Check if post exists
      const [existingPost] = await db
        .select()
        .from(blogPosts)
        .where(eq(blogPosts.id, parseInt(id)))
        .limit(1);

      if (!existingPost) {
        return res.status(404).json({ 
          success: false, 
          error: 'Blog post not found' 
        });
      }

      // Generate new slug if title changed
      const slug = title.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '');

      // Check if new slug conflicts with another post
      if (slug !== existingPost.slug) {
        const [conflicting] = await db
          .select()
          .from(blogPosts)
          .where(eq(blogPosts.slug, slug))
          .limit(1);

        if (conflicting) {
          return res.status(400).json({ 
            success: false, 
            error: 'A blog post with this title already exists' 
          });
        }
      }

      // Update the blog post
      const [updatedPost] = await db
        .update(blogPosts)
        .set({
          title,
          slug,
          excerpt: excerpt || '',
          content,
          category: category || 'General',
          coverImage: coverImage || null,
          youtubeUrl: youtubeUrl || null,
          isPublished: isPublished || false,
          publishedAt: isPublished && !existingPost.isPublished ? new Date() : existingPost.publishedAt,
          updatedAt: new Date()
        })
        .where(eq(blogPosts.id, parseInt(id)))
        .returning();

      res.json({ 
        success: true, 
        data: updatedPost, 
        message: 'Blog post updated successfully' 
      });
    } catch (error: any) {
      console.error('Error updating blog post:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to update blog post' 
      });
    }
  });

  // Delete blog post (admin)
  app.delete('/api/admin/blog-posts/:id', requireAuth, requireAdmin, async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user || user.role !== 'admin') {
        return res.status(403).json({
          success: false,
          error: 'Admin access required'
        });
      }

      const { id } = req.params;

      // Check if post exists
      const [existingPost] = await db
        .select()
        .from(blogPosts)
        .where(eq(blogPosts.id, parseInt(id)))
        .limit(1);

      if (!existingPost) {
        return res.status(404).json({ 
          success: false, 
          error: 'Blog post not found' 
        });
      }

      // Delete the blog post
      await db
        .delete(blogPosts)
        .where(eq(blogPosts.id, parseInt(id)));

      res.json({ 
        success: true, 
        message: 'Blog post deleted successfully' 
      });
    } catch (error: any) {
      console.error('Error deleting blog post:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to delete blog post' 
      });
    }
  });

  // Get all published blog posts (public)
  app.get('/api/blog-posts', async (req, res) => {
    try {
      const publishedPosts = await db
        .select()
        .from(blogPosts)
        .where(eq(blogPosts.isPublished, true))
        .orderBy(desc(blogPosts.publishedAt));

      res.json(publishedPosts);
    } catch (error: any) {
      console.error('Error fetching blog posts:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to fetch blog posts' 
      });
    }
  });

  // Get single blog post by slug (public)
  app.get('/api/blog-posts/:slug', async (req, res) => {
    try {
      const { slug } = req.params;

      const [post] = await db
        .select()
        .from(blogPosts)
        .where(and(
          eq(blogPosts.slug, slug),
          eq(blogPosts.isPublished, true)
        ))
        .limit(1);

      if (!post) {
        return res.status(404).json({
          success: false,
          error: 'Blog post not found'
        });
      }

      res.json(post);
    } catch (error: any) {
      console.error('Error fetching blog post:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to fetch blog post' 
      });
    }
  });

  // Get unread messages count (including group messages)
  app.get('/api/messages/:userId/unread-count', async (req, res) => {
    try {
      const { userId } = req.params; // This is the text-based user ID like "HJOR2AC54I"

      // Use existing helper function to convert text user ID to profile UUID
      const profileUuid = await getUserUuidByUserId(userId);
      
      if (!profileUuid) {
        return res.status(404).json({ 
          success: false, 
          error: 'User not found' 
        });
      }

      // Count total direct messages sent to this user (as receiver) using profile.id
      const [totalDirectCount] = await db
        .select({ count: count() })
        .from(messages)
        .where(and(
          eq(messages.receiverId, profileUuid),
          isNull(messages.groupId) // Only direct messages
        ));

      // Count read direct messages (messages this user has read)
      const [readDirectCount] = await db
        .select({ count: count() })
        .from(messages)
        .where(and(
          eq(messages.receiverId, profileUuid),
          isNull(messages.groupId), // Only direct messages
          isNotNull(messages.readAt)
        ));

      // Get all groups the user is a member of
      const userGroups = await db
        .select({ groupId: communityGroupMembers.groupId })
        .from(communityGroupMembers)
        .where(eq(communityGroupMembers.userId, profileUuid));

      let groupUnreadCount = 0;
      
      // Count unread group messages for each group
      for (const group of userGroups) {
        const [totalGroupCount] = await db
          .select({ count: count() })
          .from(messages)
          .where(and(
            eq(messages.groupId, group.groupId),
            ne(messages.senderId, profileUuid) // Don't count user's own messages
          ));

        // For group messages, we need to implement a separate read tracking system
        // For now, we'll count all group messages as unread except user's own
        // TODO: Implement proper group message read tracking
        groupUnreadCount += totalGroupCount?.count || 0;
      }

      const directUnreadCount = (totalDirectCount?.count || 0) - (readDirectCount?.count || 0);
      const totalUnreadCount = directUnreadCount + groupUnreadCount;

      res.json({ 
        success: true, 
        unreadCount: totalUnreadCount,
        directUnreadCount,
        groupUnreadCount
      });
    } catch (error: any) {
      console.error('Error fetching unread messages count:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to fetch unread messages count' 
      });
    }
  });

  // Temporary in-memory storage for payment methods and profiles while DB is having issues
  const paymentMethodsStorage = new Map();
  const profileStorage = new Map();

  // Payment methods endpoints
  app.get('/api/payment-methods', requireAuth, async (req, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: 'Unauthorized' });
      }

      const user = req.user as any;
      
      try {
        // Try to fetch from database first
        const userPaymentMethods = await db
          .select()
          .from(paymentMethods)
          .where(eq(paymentMethods.userId, user.id))
          .orderBy(desc(paymentMethods.isDefault), desc(paymentMethods.createdAt));
        
        res.json(userPaymentMethods);
      } catch (dbError) {
        // Fallback to in-memory storage if DB fails
        console.log('Database unavailable, using in-memory storage for payment methods');
        const userMethods = paymentMethodsStorage.get(user.id) || [];
        res.json(userMethods);
      }
    } catch (error: any) {
      console.error('Error fetching payment methods:', error);
      res.status(500).json({ error: 'Failed to fetch payment methods' });
    }
  });

  app.post('/api/payment-methods', requireAuth, async (req, res) => {
    try {
      const { userId, displayName, cardNumber, expiryDate, cvv, cardholderName, isDefault } = req.body;
      
      // Validate required fields
      if (!userId || !displayName || !cardNumber || !expiryDate || !cardholderName) {
        return res.status(400).json({
          success: false,
          error: 'Missing required fields'
        });
      }
      
      const newPaymentMethod = {
        id: `pm_${Date.now()}`, // Generate a temporary ID
        userId,
        type: 'stripe_card',
        displayName,
        lastFour: cardNumber.slice(-4),
        expiryDate,
        cardholderName,
        isDefault: isDefault || false,
        isVerified: true,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };
      
      try {
        // Try to save to database first
        if (isDefault) {
          await db
            .update(paymentMethods)
            .set({ isDefault: false })
            .where(eq(paymentMethods.userId, userId));
        }
        
        const [insertedPaymentMethod] = await db
          .insert(paymentMethods)
          .values({
            userId,
            type: 'stripe_card',
            displayName,
            lastFour: cardNumber.slice(-4),
            expiryDate,
            cardholderName,
            isDefault: isDefault || false,
            isVerified: true
          })
          .returning();
        
        res.json({ 
          success: true, 
          data: insertedPaymentMethod,
          message: 'Payment method added successfully'
        });
      } catch (dbError) {
        // Fallback to in-memory storage if DB fails
        console.log('Database unavailable, using in-memory storage for payment methods');
        const userMethods = paymentMethodsStorage.get(userId) || [];
        
        // If this is set as default, unset all other defaults
        if (isDefault) {
          userMethods.forEach(method => method.isDefault = false);
        }
        
        userMethods.push(newPaymentMethod);
        paymentMethodsStorage.set(userId, userMethods);
        
        res.json({ 
          success: true, 
          data: newPaymentMethod,
          message: 'Payment method added successfully'
        });
      }
    } catch (error: any) {
      console.error('Error adding payment method:', error);
      res.status(500).json({ error: 'Failed to add payment method' });
    }
  });

  app.delete('/api/payment-methods/:methodId', requireAuth, async (req, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: 'Unauthorized' });
      }

      const { methodId } = req.params;
      const user = req.user as any;
      
      try {
        // Try to delete from database first
        await db
          .delete(paymentMethods)
          .where(and(
            eq(paymentMethods.id, methodId),
            eq(paymentMethods.userId, user.id)
          ));
        
        res.json({ success: true, message: 'Payment method deleted successfully' });
      } catch (dbError) {
        // Fallback to in-memory storage if DB fails
        console.log('Database unavailable, using in-memory storage for payment methods');
        const userMethods = paymentMethodsStorage.get(user.id) || [];
        const updatedMethods = userMethods.filter(method => method.id !== methodId);
        paymentMethodsStorage.set(user.id, updatedMethods);
        
        res.json({ success: true, message: 'Payment method deleted successfully' });
      }
    } catch (error: any) {
      console.error('Error deleting payment method:', error);
      res.status(500).json({ error: 'Failed to delete payment method' });
    }
  });

  app.put('/api/payment-methods/:methodId/set-default', requireAuth, async (req, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: 'Unauthorized' });
      }

      const { methodId } = req.params;
      const user = req.user as any;
      
      try {
        // Try database first
        await db
          .update(paymentMethods)
          .set({ isDefault: false })
          .where(eq(paymentMethods.userId, user.id));
        
        await db
          .update(paymentMethods)
          .set({ isDefault: true })
          .where(and(
            eq(paymentMethods.id, methodId),
            eq(paymentMethods.userId, user.id)
          ));
        
        res.json({ success: true, message: 'Default payment method updated successfully' });
      } catch (dbError) {
        // Fallback to in-memory storage if DB fails
        console.log('Database unavailable, using in-memory storage for setting default payment method');
        const userMethods = paymentMethodsStorage.get(user.id) || [];
        
        // Unset all defaults first
        userMethods.forEach(method => method.isDefault = false);
        
        // Set the selected method as default
        const targetMethod = userMethods.find(method => method.id === methodId);
        if (targetMethod) {
          targetMethod.isDefault = true;
          paymentMethodsStorage.set(user.id, userMethods);
          res.json({ success: true, message: 'Default payment method updated successfully' });
        } else {
          res.status(404).json({ error: 'Payment method not found' });
        }
      }
    } catch (error: any) {
      console.error('Error setting default payment method:', error);
      res.status(500).json({ error: 'Failed to set default payment method' });
    }
  });

  // Stripe SetupIntent endpoint for adding payment methods
  app.post('/api/payment-methods/setup-intent', requireAuth, async (req, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: 'Unauthorized' });
      }

      const stripe = await getPrimaryPaymentClient();
      if (!stripe) {
        return res.status(500).json({ 
          error: 'Payment system not available' 
        });
      }

      const user = req.user as any;
      let customerId = user.profile?.stripeCustomerId;

      // Create Stripe customer if doesn't exist
      if (!customerId) {
        const customer = await stripe.customers.create({
          email: user.email,
          metadata: {
            userId: user.id,
          },
        });
        customerId = customer.id;

        // Update profile with Stripe customer ID
        await db
          .update(profiles)
          .set({ stripeCustomerId: customerId })
          .where(eq(profiles.userId, user.id));
      }

      // Create SetupIntent
      const setupIntent = await stripe.setupIntents.create({
        customer: customerId,
        payment_method_types: ['card'],
      });

      res.json({ clientSecret: setupIntent.client_secret });
    } catch (error: any) {
      console.error('Error creating setup intent:', error);
      res.status(500).json({ error: 'Failed to create setup intent' });
    }
  });

  // Manual sync endpoint for development (webhooks don't work locally)
  app.post('/api/payment-methods/sync', requireAuth, async (req, res) => {
    try {
      const stripe = await getPrimaryPaymentClient();
      if (!stripe) {
        return res.status(500).json({ error: 'Stripe not configured' });
      }

      const user = req.user as any;
      
      // Fetch the Stripe customer ID from the database
      const [userProfile] = await db
        .select({ stripeCustomerId: profiles.stripeCustomerId })
        .from(profiles)
        .where(eq(profiles.userId, user.id))
        .limit(1);

      const customerId = userProfile?.stripeCustomerId;

      if (!customerId) {
        return res.status(400).json({ error: 'No Stripe customer ID found. Please contact support.' });
      }

      // Get all payment methods from Stripe for this customer
      const stripeMethods = await stripe.paymentMethods.list({
        customer: customerId,
        type: 'card',
      });

      if (stripeMethods.data.length === 0) {
        return res.json({ success: true, synced: 0 });
      }

      let syncedCount = 0;

      for (const paymentMethod of stripeMethods.data) {
        // Check if this payment method already exists in our database
        const [existing] = await db
          .select()
          .from(paymentMethods)
          .where(eq(paymentMethods.stripePaymentMethodId, paymentMethod.id))
          .limit(1);

        if (!existing) {
          // Check if this is the first payment method (make it default)
          const existingMethods = await db
            .select()
            .from(paymentMethods)
            .where(eq(paymentMethods.userId, user.id));

          const isFirstMethod = existingMethods.length === 0;

          // Save new payment method to database
          await db.insert(paymentMethods).values({
            userId: user.id,
            stripePaymentMethodId: paymentMethod.id,
            type: 'stripe_card',
            displayName: `${paymentMethod.card?.brand?.toUpperCase() || 'Card'} ****${paymentMethod.card?.last4}`,
            lastFour: paymentMethod.card?.last4 || '',
            expiryDate: `${paymentMethod.card?.exp_month}/${paymentMethod.card?.exp_year}`,
            cardholderName: paymentMethod.billing_details?.name || '',
            isDefault: isFirstMethod,
            isVerified: true,
          });

          syncedCount++;
        }
      }

      res.json({ success: true, synced: syncedCount });
    } catch (error: any) {
      console.error('Error syncing payment methods:', error);
      res.status(500).json({ error: 'Failed to sync payment methods' });
    }
  });

  // Stripe webhook to handle payment method attachment
  app.post('/api/webhooks/stripe', express.raw({ type: 'application/json' }), async (req, res) => {
    try {
      const stripe = await getPrimaryPaymentClient();
      if (!stripe) {
        return res.status(500).send('Stripe not configured');
      }

      const sig = req.headers['stripe-signature'] as string;
      const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;

      if (!webhookSecret) {
        console.log('Warning: STRIPE_WEBHOOK_SECRET not configured, skipping signature verification');
        // In production, you should always verify the signature
      }

      let event;
      try {
        if (webhookSecret) {
          event = stripe.webhooks.constructEvent(req.body, sig, webhookSecret);
        } else {
          event = JSON.parse(req.body.toString());
        }
      } catch (err: any) {
        console.error('Webhook signature verification failed:', err.message);
        return res.status(400).send(`Webhook Error: ${err.message}`);
      }

      // Handle the event
      if (event.type === 'setup_intent.succeeded') {
        const setupIntent = event.data.object as any;
        const customerId = setupIntent.customer;
        const paymentMethodId = setupIntent.payment_method;

        // Get payment method details from Stripe
        const paymentMethod = await stripe.paymentMethods.retrieve(paymentMethodId);
        
        // Find user by Stripe customer ID
        const [userProfile] = await db
          .select()
          .from(profiles)
          .where(eq(profiles.stripeCustomerId, customerId))
          .limit(1);

        if (userProfile) {
          // Check if this is the first payment method (make it default)
          const existingMethods = await db
            .select()
            .from(paymentMethods)
            .where(eq(paymentMethods.userId, userProfile.userId));

          const isFirstMethod = existingMethods.length === 0;

          // Unset all other defaults if this is being set as default
          if (isFirstMethod) {
            await db
              .update(paymentMethods)
              .set({ isDefault: false })
              .where(eq(paymentMethods.userId, userProfile.userId));
          }

          // Save payment method to database
          await db.insert(paymentMethods).values({
            userId: userProfile.userId,
            stripePaymentMethodId: paymentMethodId,
            type: 'stripe_card',
            displayName: `${paymentMethod.card?.brand?.toUpperCase() || 'Card'} ****${paymentMethod.card?.last4}`,
            lastFour: paymentMethod.card?.last4 || '',
            expiryDate: `${paymentMethod.card?.exp_month}/${paymentMethod.card?.exp_year}`,
            cardholderName: paymentMethod.billing_details?.name || '',
            isDefault: isFirstMethod,
            isVerified: true,
          });
        }
      }

      res.json({ received: true });
    } catch (error: any) {
      console.error('Webhook error:', error);
      res.status(500).send('Webhook handler failed');
    }
  });

  // Stripe Checkout Session Route
  app.post('/api/create-checkout-session', async (req, res) => {
    try {
      const stripe = await getPrimaryPaymentClient();
      if (!stripe) {
        return res.status(500).json({ 
          success: false, 
          error: 'Payment system not available' 
        });
      }

      const { plan, userId, countryCode } = req.body;

      if (!plan || !userId) {
        return res.status(400).json({
          success: false,
          error: 'Missing required fields: plan, userId'
        });
      }

      // Define plan pricing
      const planPrices = {
        primary_basic: 4.99,
        high_school_basic: 6.99,
        college_course: 9.99
      };

      const amount = planPrices[plan as keyof typeof planPrices] || 4.99;

      // Create checkout session
      const session = await stripe.checkout.sessions.create({
        payment_method_types: ['card'],
        line_items: [{
          price_data: {
            currency: 'usd',
            product_data: {
              name: `EduFiliova ${plan.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase())} Plan`,
              description: 'Unlimited access to educational content and premium features'
            },
            unit_amount: Math.round(amount * 100), // Convert to cents
            recurring: {
              interval: 'month'
            }
          },
          quantity: 1,
        }],
        mode: 'subscription',
        success_url: `${process.env.BASE_URL || 'http://localhost:5000'}/payment-success?session_id={CHECKOUT_SESSION_ID}`,
        cancel_url: `${process.env.BASE_URL || 'http://localhost:5000'}/student-dashboard`,
        metadata: {
          userId,
          plan,
          countryCode: countryCode || 'US'
        }
      });

      res.json({ success: true,
        success: true,
        checkoutUrl: session.url,
        sessionId: session.id
      });

    } catch (error: any) {
      console.error('Stripe checkout session error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to create checkout session'
      });
    }
  });

  // Stripe Payment Routes

  // Paystack Payment Routes
  app.post('/api/courses/paystack/initialize', requireAuth, async (req, res) => {
    try {
      const { courseId, amount, email } = req.body;
      const user = (req as AuthenticatedRequest).user;

      if (!user) {
        return res.status(401).json({ error: 'Unauthorized' });
      }

      const paystackSecretKey = process.env.PAYSTACK_SECRET_KEY;
      if (!paystackSecretKey) {
        return res.status(500).json({ error: 'Paystack not configured' });
      }

      // Initialize Paystack transaction
      const response = await fetch('https://api.paystack.co/transaction/initialize', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${paystackSecretKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          email: email || user.email,
          amount: amount, // Amount in kobo (cents)
          currency: 'USD',
          metadata: {
            courseId,
            userId: user.id,
            type: 'course_purchase'
          },
          callback_url: `${process.env.BASE_URL || 'http://localhost:5000'}/api/courses/paystack/callback`
        })
      });

      const data = await response.json();

      if (data.status) {
        res.json({ 
          success: true, 
          authorization_url: data.data.authorization_url,
          access_code: data.data.access_code,
          reference: data.data.reference
        });
      } else {
        res.status(400).json({ error: data.message || 'Failed to initialize payment' });
      }
    } catch (error: any) {
      console.error('Paystack initialization error:', error);
      res.status(500).json({ error: 'Failed to initialize Paystack payment' });
    }
  });

  // Paystack callback handler
  app.get('/api/courses/paystack/callback', async (req, res) => {
    try {
      const { reference } = req.query;

      if (!reference) {
        return res.redirect('/?payment=failed');
      }

      const paystackSecretKey = process.env.PAYSTACK_SECRET_KEY;
      if (!paystackSecretKey) {
        return res.redirect('/?payment=error');
      }

      // Verify transaction
      const response = await fetch(`https://api.paystack.co/transaction/verify/${reference}`, {
        headers: {
          'Authorization': `Bearer ${paystackSecretKey}`
        }
      });

      const data = await response.json();

      if (data.status && data.data.status === 'success') {
        const { courseId, userId } = data.data.metadata;
        const amount = data.data.amount / 100; // Convert from kobo to dollars

        // Create or update purchase record
        await db
          .insert(coursePurchases)
          .values({
            userId,
            courseId,
            amount: amount.toString(),
            currency: 'USD',
            paymentIntentId: reference as string,
            paymentStatus: 'completed',
            purchasedAt: new Date()
          })
          .onConflictDoUpdate({
            target: [coursePurchases.userId, coursePurchases.courseId],
            set: {
              paymentStatus: 'completed',
              purchasedAt: new Date()
            }
          });

        // Auto-enroll user
        const existingEnrollment = await db
          .select()
          .from(courseEnrollments)
          .where(and(
            eq(courseEnrollments.userId, userId),
            eq(courseEnrollments.courseId, courseId)
          ))
          .limit(1);

        if (existingEnrollment.length === 0) {
          await db.insert(courseEnrollments).values({
            userId,
            courseId,
            enrolledAt: new Date(),
            progress: 0,
          });
        }

        res.redirect(`/course-detail-${courseId}?payment=success`);
      } else {
        res.redirect('/?payment=failed');
      }
    } catch (error: any) {
      console.error('Paystack callback error:', error);
      res.redirect('/?payment=error');
    }
  });
  app.post('/api/create-payment-intent', async (req, res) => {
    try {
      const stripe = await getPrimaryPaymentClient();
      if (!stripe) {
        return res.status(500).json({ 
          success: false, 
          error: 'Payment system not available' 
        });
      }

      const { amount, planName, billingCycle, subscriptionTier, gradeLevel, userId, planId, planType } = req.body;

      // Validate based on plan type
      if (planType === 'freelancer') {
        if (!planId) {
          return res.status(400).json({
            success: false,
            error: 'planId is required for freelancer subscriptions'
          });
        }
      }

      if (!amount || !planName || !userId) {
        return res.status(400).json({
          success: false,
          error: 'Missing required fields: amount, planName, userId'
        });
      }

      // Get user's country to determine currency
      let userCountry = 'United States';
      let currency = 'usd';
      let convertedAmount = amount;

      // Only fetch profile for authenticated users, not guests
      if (userId && userId !== 'guest') {
        try {
          const userProfile = await db
            .select()
            .from(profiles)
            .where(eq(profiles.userId, userId))
            .limit(1);

          if (userProfile.length > 0 && userProfile[0].country) {
            userCountry = userProfile[0].country;
            
            // Get country code for currency conversion
            const countryCode = getCountryCodeFromName(userCountry);
            
            // List of currencies supported by Stripe
            const stripeSupportedCurrencies = [
              'usd', 'aed', 'afn', 'all', 'amd', 'ang', 'aoa', 'ars', 'aud', 'awg', 'azn', 'bam', 'bbd', 
              'bdt', 'bgn', 'bhd', 'bif', 'bmd', 'bnd', 'bob', 'brl', 'bsd', 'bwp', 'byn', 'bzd', 'cad', 
              'cdf', 'chf', 'clp', 'cny', 'cop', 'crc', 'cve', 'czk', 'djf', 'dkk', 'dop', 'dzd', 'egp', 
              'etb', 'eur', 'fjd', 'fkp', 'gbp', 'gel', 'gip', 'gmd', 'gnf', 'gtq', 'gyd', 'hkd', 'hnl', 
              'hrk', 'htg', 'huf', 'idr', 'ils', 'inr', 'isk', 'jmd', 'jod', 'jpy', 'kes', 'kgs', 'khr', 
              'kmf', 'krw', 'kwd', 'kyd', 'kzt', 'lak', 'lbp', 'lkr', 'lrd', 'lsl', 'mad', 'mdl', 'mga', 
              'mkd', 'mmk', 'mnt', 'mop', 'mur', 'mvr', 'mwk', 'mxn', 'myr', 'mzn', 'nad', 'ngn', 'nio', 
              'nok', 'npr', 'nzd', 'omr', 'pab', 'pen', 'pgk', 'php', 'pkr', 'pln', 'pyg', 'qar', 'ron', 
              'rsd', 'rub', 'rwf', 'sar', 'sbd', 'scr', 'sek', 'sgd', 'shp', 'sle', 'sos', 'srd', 'std', 
              'szl', 'thb', 'tjs', 'tnd', 'top', 'try', 'ttd', 'twd', 'tzs', 'uah', 'ugx', 'uyu', 'uzs', 
              'vnd', 'vuv', 'wst', 'xaf', 'xcd', 'xcg', 'xof', 'xpf', 'yer', 'zar', 'zmw', 'usdc', 'btn', 
              'ghs', 'eek', 'lvl', 'svc', 'vef', 'ltl', 'sll', 'mro'
            ];

            // Map country code to currency (use USD for unsupported currencies)
            const countryToCurrency: { [key: string]: string } = {
              'US': 'usd', 'CA': 'cad', 'GB': 'gbp', 'EU': 'eur', 'DE': 'eur', 'FR': 'eur', 'ES': 'eur', 'IT': 'eur',
              'AU': 'aud', 'NZ': 'nzd', 'JP': 'jpy', 'CN': 'cny', 'IN': 'inr', 'BR': 'brl', 'MX': 'mxn',
              'ZA': 'zar', 'NG': 'ngn', 'KE': 'kes', 'GH': 'ghs', 'EG': 'egp', 'MA': 'mad',
              'RU': 'rub', 'KR': 'krw', 'TH': 'thb', 'VN': 'vnd', 'ID': 'idr', 'MY': 'myr', 'PH': 'php', 'SG': 'sgd',
              'AR': 'ars', 'CL': 'clp', 'CO': 'cop', 'PE': 'pen', 'UY': 'uyu', 'VE': 'usd', // VES not supported, use USD
              'TR': 'try', 'SA': 'sar', 'AE': 'aed', 'IL': 'ils', 'JO': 'jod', 'LB': 'lbp',
              'PL': 'pln', 'CZ': 'czk', 'HU': 'huf', 'RO': 'ron', 'BG': 'bgn', 'HR': 'hrk',
              'NO': 'nok', 'SE': 'sek', 'DK': 'dkk', 'FI': 'eur', 'IS': 'isk',
              'CH': 'chf', 'AT': 'eur', 'BE': 'eur', 'NL': 'eur', 'LU': 'eur', 'IE': 'eur', 'PT': 'eur'
            };

            const proposedCurrency = countryToCurrency[countryCode] || 'usd';
            
            // Ensure the currency is supported by Stripe, fallback to USD if not
            currency = stripeSupportedCurrencies.includes(proposedCurrency) ? proposedCurrency : 'usd';
            
            // If currency is not USD, fetch exchange rate and convert amount
            if (currency !== 'usd') {
              try {
                const response = await fetch(`https://api.exchangerate-api.com/v4/latest/USD`);
                const data = await response.json();
                const rate = data.rates[currency.toUpperCase()] || 1;
                convertedAmount = amount * rate;
              } catch (exchangeError) {
                console.log('Exchange rate fetch failed, using USD:', exchangeError);
                currency = 'usd';
                convertedAmount = amount;
              }
            }
          }
        } catch (profileError) {
          console.log('Profile fetch failed, using default USD:', profileError);
        }
      }

      // Create payment intent with user's currency
      const paymentIntent = await stripe.paymentIntents.create({
        amount: Math.round(convertedAmount * 100), // Convert to cents/smallest unit
        currency: currency.toLowerCase(),
        metadata: {
          planName,
          billingCycle,
          subscriptionTier: subscriptionTier || '',
          gradeLevel: gradeLevel?.toString() || '',
          planId: planId || '',
