          planType: planType || 'student',
          userId,
          originalUSDAmount: amount.toString(),
          userCountry,
          conversionRate: (convertedAmount / amount).toString()
        }

      });
      res.json({ success: true,
        success: true,
        clientSecret: paymentIntent.client_secret,
        paymentIntentId: paymentIntent.id,
        currency: currency.toUpperCase(),
        convertedAmount,
        originalAmount: amount
      });

    } catch (error: any) {
      console.error('Stripe payment intent error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to create payment intent'
      });
    }
  });

  // Handle successful payments and update user plan
  app.post('/api/confirm-payment', async (req, res) => {
    try {
      const { paymentIntentId, userId } = req.body;

      const stripe = await getPrimaryPaymentClient();
      if (!stripe) {
        return res.status(500).json({ 
          success: false, 
          error: 'Payment system not available' 
        });
      }

      // Retrieve payment intent to verify it succeeded
      const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
      
      if (paymentIntent.status !== 'succeeded') {
        return res.status(400).json({
          success: false,
          error: 'Payment not completed'
        });
      }

      const { planName, billingCycle, subscriptionTier, gradeLevel } = paymentIntent.metadata;

      // SECURITY: Validate grade-based subscription metadata
      const allowedTiers = ['elementary', 'high_school', 'college_university'];
      const allowedCycles = ['monthly', 'yearly'];
      
      if (!subscriptionTier || !allowedTiers.includes(subscriptionTier)) {
        console.error('Invalid subscription tier in payment metadata:', subscriptionTier);
        return res.status(400).json({
          success: false,
          error: 'Invalid subscription tier'
        });
      }
      
      if (!billingCycle || !allowedCycles.includes(billingCycle)) {
        console.error('Invalid billing cycle in payment metadata:', billingCycle);
        return res.status(400).json({
          success: false,
          error: 'Invalid billing cycle'
        });
      }

      // Calculate plan expiry date based on billing cycle
      const now = new Date();
      let planExpiry;
      let planKey;
      
      switch (billingCycle) {
        case 'monthly':
          planExpiry = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000); // 30 days
          break;
        case 'yearly':
          planExpiry = new Date(now.getTime() + 365 * 24 * 60 * 60 * 1000); // 1 year
          break;
        default:
          planExpiry = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000); // Default to monthly
      }

      // Grade level for profile update
      const gradeNumber = gradeLevel ? parseInt(gradeLevel) : null;

      // Update user's plan in database with grade-based subscription
      try {
        const updateData: any = {
          subscriptionTier: subscriptionTier,
          planExpiry: planExpiry,
          verificationBadge: 'blue',
          lastPricingShown: new Date(),
          updatedAt: new Date()
        };
        
        // Update grade level if provided
        if (gradeNumber !== null) {
          updateData.grade = gradeNumber;
          // Set gradeLevel enum value based on gradeNumber
          if (gradeNumber >= 1 && gradeNumber <= 12) {
            updateData.gradeLevel = gradeNumber.toString();
          } else if (gradeNumber === 13) {
            updateData.gradeLevel = 'college';
          } else if (gradeNumber >= 14) {
            updateData.gradeLevel = 'university';
          }
        }
        
        await db
          .update(profiles)
          .set(updateData)
          .where(eq(profiles.userId, userId));

        res.json({ success: true,
          success: true,
          message: 'Payment confirmed and plan updated',
          planName,
          billingCycle
        });

      } catch (dbError) {
        console.error('Database error updating plan:', dbError);
        res.status(500).json({
          success: false,
          error: 'Payment successful but failed to update plan'
        });
      }

    } catch (error: any) {
      console.error('Payment confirmation error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to confirm payment'
      });
    }
  });

  // Confirm Freelancer Subscription Payment
  app.post('/api/confirm-freelancer-subscription', async (req, res) => {
    try {
      const { paymentIntentId, userId } = req.body;

      const stripe = await getPrimaryPaymentClient();
      if (!stripe) {
        return res.status(500).json({ 
          success: false, 
          error: 'Payment system not available' 
        });
      }

      // Retrieve payment intent to verify it succeeded
      const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
      
      if (paymentIntent.status !== 'succeeded') {
        return res.status(400).json({
          success: false,
          error: 'Payment not completed'
        });
      }

      const { planId, planType, billingCycle } = paymentIntent.metadata;

      // Validate this is a freelancer plan payment
      if (planType !== 'freelancer') {
        return res.status(400).json({
          success: false,
          error: 'Invalid plan type'
        });
      }

      // Calculate plan expiry date based on billing cycle
      const now = new Date();
      let planExpiry;
      
      switch (billingCycle) {
        case 'monthly':
          planExpiry = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000); // 30 days
          break;
        case 'yearly':
          planExpiry = new Date(now.getTime() + 365 * 24 * 60 * 60 * 1000); // 1 year
          break;
        case 'lifetime':
          planExpiry = new Date(now.getTime() + 100 * 365 * 24 * 60 * 60 * 1000); // 100 years (lifetime)
          break;
        default:
          planExpiry = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000); // Default to monthly
      }

      // Fetch plan details to get the badge color
      const [planDetails] = await db
        .select()
        .from(freelancerPricingPlans)
        .where(eq(freelancerPricingPlans.planId, planId))
        .limit(1);

      if (!planDetails) {
        return res.status(400).json({
          success: false,
          error: 'Invalid plan ID'
        });
      }

      // Map badge color to verification badge enum
      // blue -> blue, green -> green, orange -> blue (Elite plan gets blue badge)
      const badgeMapping: Record<string, 'none' | 'green' | 'blue'> = {
        'blue': 'blue',
        'green': 'green',
        'orange': 'blue' // Elite plan gets blue badge
      };
      
      const verificationBadge = badgeMapping[planDetails.badgeColor] || 'none';

      // Update user's freelancer subscription in database
      try {
        await db
          .update(profiles)
          .set({
            legacyPlan: planId,
            planExpiry: planExpiry,
            verificationBadge: verificationBadge,
            updatedAt: new Date()
          })
          .where(eq(profiles.userId, userId));

        res.json({ success: true,
          success: true,
          message: 'Freelancer subscription confirmed',
          planId,
          billingCycle,
          expiry: planExpiry,
          badgeAwarded: verificationBadge
        });

      } catch (dbError) {
        console.error('Database error updating freelancer subscription:', dbError);
        res.status(500).json({
          success: false,
          error: 'Payment successful but failed to update subscription'
        });
      }

    } catch (error: any) {
      console.error('Freelancer subscription confirmation error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to confirm subscription'
      });
    }
  });

  // Process wallet payment
  app.post('/api/process-wallet-payment', requireAuth, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;
      
      if (!userId) {
        return res.status(401).json({
          success: false,
          error: 'Authentication required'
        });
      }

      const { amount, orderId, planName, billingCycle, bannerId, type } = req.body;

      if (!amount || amount <= 0) {
        return res.status(400).json({
          success: false,
          error: 'Invalid amount'
        });
      }

      // Get user's shop customer record for wallet
      const customer = await storage.getShopCustomerByUserId(userId);
      
      if (!customer) {
        return res.status(404).json({
          success: false,
          error: 'Customer wallet not found'
        });
      }

      const walletBalance = parseFloat(customer.walletBalance);
      
      if (walletBalance < amount) {
        return res.status(400).json({
          success: false,
          error: 'Insufficient wallet balance'
        });
      }

      // Deduct amount from wallet
      const newBalance = walletBalance - amount;
      
      await db
        .update(shopCustomers)
        .set({
          walletBalance: newBalance.toFixed(2),
          updatedAt: new Date()
        })
        .where(eq(shopCustomers.id, customer.id));

      // Create transaction record
      const transactionDescription = orderId 
        ? `Order payment #${orderId.substring(0, 8)}` 
        : bannerId 
        ? `Banner ad payment #${bannerId.substring(0, 8)}`
        : `${planName || 'Subscription'} - ${billingCycle || 'monthly'}`;

      await db
        .insert(shopTransactions)
        .values({
          customerId: customer.id,
          amount: (-amount).toFixed(2), // Negative for deduction
          type: 'purchase',
          description: transactionDescription,
          status: 'paid',
          referenceId: orderId || bannerId || `wallet-${Date.now()}`
        });

      // If this is an order payment, update the order
      if (orderId) {
        await db
          .update(orders)
          .set({
            status: 'paid',
            paymentMethod: 'wallet',
            completedAt: new Date(),
            updatedAt: new Date()
          })
          .where(eq(orders.id, orderId));
      }

      // If this is a banner ad payment, update the banner status to pending
      if (bannerId) {
        await db
          .update(adsBanners)
          .set({
            status: 'pending',
            updatedAt: new Date()
          })
          .where(eq(adsBanners.id, bannerId));
      }

      res.json({ success: true,
        success: true,
        message: 'Payment processed successfully',
        newBalance: newBalance.toFixed(2)
      });

    } catch (error: any) {
      console.error('Wallet payment error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to process wallet payment'
      });
    }
  });

  // Calculate pro-rated upgrade cost
  app.post('/api/calculate-upgrade-cost', requireAuth, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;
      const { targetTier, billingCycle } = req.body;

      if (!userId || !targetTier || !billingCycle) {
        return res.status(400).json({
          success: false,
          error: 'Missing required fields'
        });
      }

      // Get current subscription details
      const userProfile = await db.select()
        .from(profiles)
        .where(eq(profiles.userId, userId))
        .limit(1);

      if (userProfile.length === 0) {
        return res.status(404).json({
          success: false,
          error: 'User profile not found'
        });
      }

      const profile = userProfile[0];
      const currentTier = profile.subscriptionTier;
      const planExpiry = profile.planExpiry;

      if (!currentTier || !planExpiry) {
        return res.status(400).json({
          success: false,
          error: 'No active subscription found'
        });
      }

      // Import GRADE_SUBSCRIPTION_PLANS
      const { GRADE_SUBSCRIPTION_PLANS } = await import('@shared/schema');
      
      // Get current and target plan details
      const currentPlan = GRADE_SUBSCRIPTION_PLANS[currentTier as keyof typeof GRADE_SUBSCRIPTION_PLANS];
      const targetPlan = GRADE_SUBSCRIPTION_PLANS[targetTier as keyof typeof GRADE_SUBSCRIPTION_PLANS];

      if (!currentPlan || !targetPlan) {
        return res.status(400).json({
          success: false,
          error: 'Invalid subscription tier'
        });
      }

      // Calculate remaining days
      const now = new Date();
      const expiryDate = new Date(planExpiry);
      const daysRemaining = Math.max(0, Math.ceil((expiryDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)));

      // Determine billing period length
      const currentBillingCycle = billingCycle as 'monthly' | 'yearly';
      const daysInPeriod = currentBillingCycle === 'monthly' ? 30 : 365;

      // Calculate pro-rated credit from current plan
      const currentPlanPrice = currentPlan.pricing[currentBillingCycle];
      const dailyRate = currentPlanPrice / daysInPeriod;
      const credit = dailyRate * daysRemaining;

      // Calculate target plan cost
      const targetPlanPrice = targetPlan.pricing[currentBillingCycle];

      // Calculate upgrade cost (what they need to pay)
      const upgradeCost = Math.max(0, targetPlanPrice - credit);

      res.json({ success: true,
        success: true,
        data: {
          currentTier,
          targetTier,
          daysRemaining,
          credit: parseFloat(credit.toFixed(2)),
          targetPlanPrice: parseFloat(targetPlanPrice.toFixed(2)),
          upgradeCost: parseFloat(upgradeCost.toFixed(2)),
          billingCycle: currentBillingCycle,
          expiryDate: expiryDate.toISOString()
        }
      });
    } catch (error: any) {
      console.error('Calculate upgrade cost error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to calculate upgrade cost'
      });
    }
  });

  // Process pro-rated subscription upgrade
  app.post('/api/upgrade-subscription', requireAuth, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;
      const { targetTier, billingCycle, paymentIntentId } = req.body;

      if (!userId || !targetTier || !billingCycle || !paymentIntentId) {
        return res.status(400).json({
          success: false,
          error: 'Missing required fields'
        });
      }

      const stripe = await getPrimaryPaymentClient();
      if (!stripe) {
        return res.status(500).json({
          success: false,
          error: 'Payment system not available'
        });
      }

      // Verify payment
      const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
      
      if (paymentIntent.status !== 'succeeded') {
        return res.status(400).json({
          success: false,
          error: 'Payment not completed'
        });
      }

      // Get current subscription
      const userProfile = await db.select()
        .from(profiles)
        .where(eq(profiles.userId, userId))
        .limit(1);

      if (userProfile.length === 0) {
        return res.status(404).json({
          success: false,
          error: 'User profile not found'
        });
      }

      const profile = userProfile[0];
      const planExpiry = profile.planExpiry;

      if (!planExpiry) {
        return res.status(400).json({
          success: false,
          error: 'No active subscription to upgrade'
        });
      }

      // Calculate new expiry date (keep remaining days)
      const now = new Date();
      const expiryDate = new Date(planExpiry);
      const daysRemaining = Math.max(0, Math.ceil((expiryDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)));
      
      // New expiry is current time + days remaining
      const newExpiry = new Date();
      newExpiry.setDate(newExpiry.getDate() + daysRemaining);

      // Update user's subscription
      await db.update(profiles)
        .set({
          subscriptionTier: targetTier,
          planExpiry: newExpiry,
          updatedAt: new Date()
        })
        .where(eq(profiles.userId, userId));

      res.json({ success: true,
        success: true,
        message: 'Subscription upgraded successfully',
        data: {
          newTier: targetTier,
          newExpiry: newExpiry.toISOString(),
          daysRemaining
        }
      });
    } catch (error: any) {
      console.error('Upgrade subscription error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to upgrade subscription'
      });
    }
  });

  // Create Zod schemas for guest order validation
  const guestCartItemSchema = z.object({
    productId: z.string().uuid(),
    quantity: z.number().int().min(1).max(100),
    productName: z.string().min(1).max(200),
    productType: z.enum(['digital', 'physical']),
    priceAtAdd: z.string().regex(/^\d+(\.\d{1,2})?$/).transform(str => parseFloat(str)) // Validate price format
  });

  const guestOrderRequestSchema = z.object({
    orderId: z.string().min(1, 'Order ID is required'),
    currency: z.string().default('USD'),
    userId: z.string().optional(),
    // For guest orders, require cart items to calculate server-side totals
    guestCartItems: z.array(guestCartItemSchema).min(1).max(50).optional(), // Max 50 items per order
    guestEmail: z.string().email().optional() // Guest email for receipts
  });

  // Cart/Order Payment Intent - Secure implementation for authenticated and guest users  
  app.post('/api/create-order-payment-intent', async (req, res) => {
    try {
      const stripe = await getPrimaryPaymentClient();
      if (!stripe) {
        return res.status(500).json({ 
          success: false, 
          error: 'Payment system not available' 
        });
      }

      // Input validation using comprehensive Zod schema
      const validationResult = guestOrderRequestSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({
          success: false,
          error: 'Invalid request data',
          details: validationResult.error.errors
        });
      }

      const { orderId, currency, userId, guestCartItems, guestEmail } = validationResult.data;

      // Determine if this is a guest or authenticated user order
      let order = null;
      let isGuestOrder = false;
      let authenticatedUser = null;
      
      // Check for authentication first
      const authHeader = req.headers.authorization;
      const sessionId = authHeader?.replace('Bearer ', '') || req.headers['x-session-id'] as string;
      
      if (sessionId) {
        // Validate session for authenticated users
        try {
          const session = await db.select()
            .from(userLoginSessions)
            .where(and(
              eq(userLoginSessions.sessionId, sessionId),
              eq(userLoginSessions.isActive, true),
              gt(userLoginSessions.expiresAt, new Date())
            ))
            .limit(1);

          if (session.length > 0) {
            const userProfile = await db.select({
              id: users.id,
              userId: users.userId,
              email: users.email,
              role: profiles.role
            })
            .from(users)
            .innerJoin(profiles, eq(users.id, profiles.userId))
            .where(eq(users.id, session[0].userId))
            .limit(1);

            if (userProfile.length > 0) {
              authenticatedUser = userProfile[0];
            }
          }
        } catch (authError) {
          console.error('Auth validation error:', authError);
          // Continue as guest if auth fails
        }
      }

      // Handle guest orders
      if (!authenticatedUser && (orderId.startsWith('guest-') || userId === 'guest')) {
        isGuestOrder = true;
        
        if (!guestCartItems || guestCartItems.length === 0) {
          return res.status(400).json({
            success: false,
            error: 'Cart items are required for guest orders'
          });
        }

        if (!guestEmail) {
          return res.status(400).json({
            success: false,
            error: 'Email is required for guest orders'
          });
        }

        // Calculate server-side total from cart items - NEVER trust client amounts
        let calculatedTotal = 0;
        const validatedItems = [];
        
        for (const item of guestCartItems) {
          // Validate product exists and get current price
          const [product] = await db
            .select({
              id: products.id,
              name: products.name,
              price: products.price,
              type: products.type,
              status: products.status,
              stock: products.stock
            })
            .from(products)
            .where(and(
              eq(products.id, item.productId),
              eq(products.status, 'approved') // Only allow approved products
            ))
            .limit(1);

          if (!product) {
            return res.status(400).json({
              success: false,
              error: `Product not found or unavailable: ${item.productName}`
            });
          }

          // Check stock for physical products
          if (product.type === 'physical' && product.stock && product.stock < item.quantity) {
            return res.status(400).json({
              success: false,
              error: `Insufficient stock for ${product.name}. Available: ${product.stock}, Requested: ${item.quantity}`
            });
          }

          // Use current product price, not client-provided price for security
          const currentPrice = parseFloat(product.price);
          const itemTotal = currentPrice * item.quantity;
          calculatedTotal += itemTotal;

          validatedItems.push({
            ...item,
            priceAtAdd: currentPrice, // Use server-verified price
            productName: product.name, // Use server product name
            productType: product.type // Use server product type
          });
        }

        // Create temporary order object with server-calculated total
        order = {
          id: orderId,
          totalAmount: calculatedTotal.toFixed(2),
          currency: currency || 'USD',
          status: 'pending',
          items: validatedItems,
          guestEmail
        };
      } 
      // Handle authenticated user orders
      else if (authenticatedUser) {
        // For authenticated users, verify order exists and belongs to user
        console.log('ðŸ” Looking up order:', { orderId, userId: authenticatedUser.id });
        
        // Retry logic to handle database replication lag
        let dbOrder = null;
        let retryCount = 0;
        const maxRetries = 3;
        
        while (!dbOrder && retryCount < maxRetries) {
          const [foundOrder] = await db
            .select()
            .from(orders)
            .where(and(
              eq(orders.id, orderId),
              eq(orders.userId, authenticatedUser.id),
              eq(orders.status, 'pending')
            ))
            .limit(1);
          
          if (foundOrder) {
            dbOrder = foundOrder;
          } else if (retryCount < maxRetries - 1) {
            // Wait 100ms before retrying
            await new Promise(resolve => setTimeout(resolve, 100));
            retryCount++;
          } else {
            break;
          }
        }

        console.log('ðŸ” Order lookup result:', dbOrder ? 'Found' : `Not found after ${retryCount + 1} attempts`);
        
        if (!dbOrder) {
          // Debug: Check if order exists with different userId
          const [anyOrder] = await db
            .select()
            .from(orders)
            .where(eq(orders.id, orderId))
            .limit(1);
          
          console.log('ðŸ” Order exists with any userId?', anyOrder ? `Yes (userId: ${anyOrder.userId}, status: ${anyOrder.status})` : 'No');
          
          return res.status(404).json({
            success: false,
            error: 'Order not found, already processed, or access denied'
          });
        }
        
        order = dbOrder;
      } else {
        // Neither authenticated nor valid guest order
        return res.status(401).json({
          success: false,
          error: 'Authentication required for user orders, or invalid guest order format'
        });
      }

      // Create payment intent using server-calculated amount (never trust client amount)
      const paymentIntent = await stripe.paymentIntents.create({
        amount: Math.round(parseFloat(order.totalAmount) * 100), // Convert to cents
        currency: (order.currency || 'USD').toLowerCase(),
        metadata: {
          orderId: order.id,
          orderNumber: `${isGuestOrder ? 'GUEST' : 'ORDER'}-${Date.now()}`,
          userId: authenticatedUser?.id || 'guest',
          userEmail: authenticatedUser?.email || (isGuestOrder ? (order as any).guestEmail : ''),
          type: 'order_payment',
          isGuestOrder: isGuestOrder.toString(),
          itemCount: isGuestOrder ? ((order as any).items?.length || 0).toString() : '1'
        }
      });

      res.json({ success: true,
        success: true,
        clientSecret: paymentIntent.client_secret,
        paymentIntentId: paymentIntent.id,
        currency: order.currency || 'USD',
        amount: order.totalAmount,
        isGuestOrder,
        calculatedFromItems: isGuestOrder // Indicate if total was server-calculated
      });

    } catch (error: any) {
      console.error('Order payment intent error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to create payment intent'
      });
    }
  });

  // Get Payment Success Details - Retrieve payment information for success page
  app.get('/api/payment-success/:sessionId', async (req, res) => {
    try {
      const stripe = await getPrimaryPaymentClient();
      if (!stripe) {
        return res.status(500).json({ 
          success: false, 
          error: 'Payment system not available' 
        });
      }

      const { sessionId } = req.params;

      if (!sessionId) {
        return res.status(400).json({
          success: false,
          error: 'Session ID is required'
        });
      }

      // Retrieve payment intent from Stripe
      const paymentIntent = await stripe.paymentIntents.retrieve(sessionId);
      
      if (paymentIntent.status !== 'succeeded') {
        return res.status(400).json({
          success: false,
          error: 'Payment not completed'
        });
      }

      // Return payment details
      res.json({ success: true,
        success: true,
        paymentIntent: {
          id: paymentIntent.id,
          amount: paymentIntent.amount,
          currency: paymentIntent.currency,
          status: paymentIntent.status,
          metadata: paymentIntent.metadata
        }
      });

    } catch (error: any) {
      console.error('Payment success retrieval error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to retrieve payment details'
      });
    }
  });

  // Helper function to check and update download limits
  async function checkDownloadLimits(userId: string, productIds: string[]): Promise<{ canDownload: boolean; reason?: string; limitType?: string }> {
    try {
      // Get user's customer record
      const customer = await storage.getShopCustomerByUserId(userId);
      if (!customer) {
        return { canDownload: true }; // No customer record, allow (guest or first-time)
      }

      // Get membership
      const membership = await storage.getShopMembershipByCustomerId(customer.id);
      if (!membership) {
        return { canDownload: true }; // No membership, allow
      }

      // Get plan details
      const [planDetails] = await db
        .select()
        .from(shopMembershipPlans)
        .where(eq(shopMembershipPlans.planId, membership.plan))
        .limit(1);

      if (!planDetails) {
        return { canDownload: true }; // No plan details, allow
      }

      // Get product details to check if free or paid
      const productDetails = await db
        .select({
          id: products.id,
          price: products.price,
          type: products.type
        })
        .from(products)
        .where(inArray(products.id, productIds));

      const hasPaidProducts = productDetails.some(p => parseFloat(p.price) > 0);
      const now = new Date();

      // Check if daily reset is needed
      const lastDailyReset = membership.lastDailyResetDate ? new Date(membership.lastDailyResetDate) : new Date(0);
      const daysSinceReset = Math.floor((now.getTime() - lastDailyReset.getTime()) / (1000 * 60 * 60 * 24));
      
      if (daysSinceReset >= 1) {
        // Reset daily counter
        await db
          .update(shopMemberships)
          .set({
            dailyDownloadsUsed: 0,
            lastDailyResetDate: now
          })
          .where(eq(shopMemberships.id, membership.id));
        membership.dailyDownloadsUsed = 0;
      }

      // Check if monthly reset is needed
      const lastMonthlyReset = membership.lastMonthlyResetDate ? new Date(membership.lastMonthlyResetDate) : new Date(0);
      const monthsSinceReset = (now.getFullYear() - lastMonthlyReset.getFullYear()) * 12 + (now.getMonth() - lastMonthlyReset.getMonth());
      
      if (monthsSinceReset >= 1) {
        // Reset monthly counter
        await db
          .update(shopMemberships)
          .set({
            monthlyPaidDownloadsUsed: 0,
            lastMonthlyResetDate: now
          })
          .where(eq(shopMemberships.id, membership.id));
        membership.monthlyPaidDownloadsUsed = 0;
      }

      // Check limits only for paid products (free products are unlimited)
      if (hasPaidProducts) {
        // Check daily limit for paid products
        if (planDetails.dailyDownloadLimit !== null) {
          const currentDailyUsed = membership.dailyDownloadsUsed || 0;
          if (currentDailyUsed >= planDetails.dailyDownloadLimit) {
            return { 
              canDownload: false, 
              reason: `Daily download limit reached (${planDetails.dailyDownloadLimit}/day). Resets tomorrow.`,
              limitType: 'daily'
            };
          }
        }


        // Free plan cannot download paid products
        if (planDetails.monthlyPaidDownloadLimit === 0) {
          return {
            canDownload: false,
            reason: 'Free plan members cannot download paid products. Please upgrade your membership.',
            limitType: 'plan'
          };
        }

        // Check monthly limit for paid products
        if (planDetails.monthlyPaidDownloadLimit !== null) {
          const currentMonthlyUsed = membership.monthlyPaidDownloadsUsed || 0;
          if (currentMonthlyUsed >= planDetails.monthlyPaidDownloadLimit) {
            return {
              canDownload: false,
              reason: `Monthly paid product download limit reached (${planDetails.monthlyPaidDownloadLimit}/month). Resets next month.`,
              limitType: 'monthly'
            };
          }
        }
      }

      // All checks passed, increment counters (only for paid products)
      const dailyIncrement = hasPaidProducts ? 1 : 0;
      const monthlyIncrement = hasPaidProducts ? 1 : 0;

      await db
        .update(shopMemberships)
        .set({
          dailyDownloadsUsed: (membership.dailyDownloadsUsed || 0) + dailyIncrement,
          monthlyPaidDownloadsUsed: (membership.monthlyPaidDownloadsUsed || 0) + monthlyIncrement
        })
        .where(eq(shopMemberships.id, membership.id));

      return { canDownload: true };
    } catch (error: any) {
      console.error('Error checking download limits:', error);
      return { canDownload: true }; // On error, allow download to not block users
    }
  }

  // Helper function to generate download tokens for digital products
  async function generateDownloadTokensForOrder(orderId: string, buyerUserId: string | null) {
    try {
      // Get order items with product details
      const items = await db
        .select({
          orderItemId: orderItems.id,
          productId: orderItems.productId,
          product: products
        })
        .from(orderItems)
        .leftJoin(products, eq(orderItems.productId, products.id))
        .where(eq(orderItems.orderId, orderId));

      // Filter digital products
      const digitalProducts = items.filter(item => item.product?.type === 'digital');
      
      if (digitalProducts.length === 0) {
        return { hasDigitalProducts: false, tokens: [] };
      }

      // Generate tokens for each digital product
      const tokens = [];
      const now = new Date();
      const expiresAt = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000); // 1 month from now

      for (const item of digitalProducts) {
        if (!item.product) continue;
        
        // Generate secure token
        const crypto = await import('crypto');
        const downloadToken = crypto.randomBytes(32).toString('hex');

        // Create download record - downloadedAt is null until actual download occurs
        const [downloadRecord] = await db
          .insert(downloads)
          .values({
            userId: buyerUserId || '00000000-0000-0000-0000-000000000000', // Use null UUID for guests
            productId: item.productId,
            orderId: orderId,
            downloadToken: downloadToken,
            expiresAt: expiresAt,
            isExpired: false
            // downloadedAt will be set when user actually downloads
          })
          .returning();

        tokens.push({
          productId: item.productId,
          productName: item.product.name,
          downloadToken: downloadToken,
          expiresAt: expiresAt
        });
      }

      // Update order with digital fulfillment status and expiration
      await db
        .update(orders)
        .set({
          digitalFulfillmentStatus: 'pending',
          downloadLinksExpiresAt: expiresAt,
          updatedAt: now
        })
        .where(eq(orders.id, orderId));

      return { hasDigitalProducts: true, tokens, expiresAt };
    } catch (error: any) {
      console.error('Error generating download tokens:', error);
      // Bubble up the error instead of swallowing it
      throw new Error(`Failed to generate download tokens: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  // Confirm Order Payment - Secure implementation for both authenticated and guest users
  app.post('/api/confirm-order-payment', async (req, res) => {
    try {
      const stripe = await getPrimaryPaymentClient();
      if (!stripe) {
        return res.status(500).json({ 
          success: false, 
          error: 'Payment system not available' 
        });
      }

      // Input validation using Zod
      const requestSchema = z.object({
        paymentIntentId: z.string().min(1, 'Payment Intent ID is required'),
        orderId: z.string().min(1, 'Order ID is required').optional() // Optional since we can get from payment intent metadata
      });

      const validationResult = requestSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({
          success: false,
          error: 'Invalid request data',
          details: validationResult.error.errors
        });
      }

      const { paymentIntentId } = validationResult.data;

      // Retrieve payment intent to verify it succeeded
      const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
      
      if (paymentIntent.status !== 'succeeded') {
        return res.status(400).json({
          success: false,
          error: 'Payment not completed'
        });
      }

      const { orderId, type, isGuestOrder, userId, userEmail } = paymentIntent.metadata;

      if (type !== 'order_payment') {
        return res.status(400).json({
          success: false,
          error: 'Invalid payment type'
        });
      }

      if (!orderId) {
        return res.status(400).json({
          success: false,
          error: 'Order ID missing from payment intent metadata'
        });
      }

      const isGuest = isGuestOrder === 'true';

      // Handle guest orders
      if (isGuest) {
        // For guest orders, update existing order (created via /guest-checkout endpoint)
        try {
          // Find existing guest order by order ID or create from payment intent metadata
          let existingOrder = null;
          
          if (orderId) {
            // Try to find existing order by ID for guest orders created via /guest-checkout
            const orderResults = await db
              .select()
              .from(orders)
              .where(and(
                eq(orders.id, orderId),
                isNull(orders.userId), // Guest orders have null userId
                isNotNull(orders.guestEmail) // And non-null guestEmail
              ))
              .limit(1);
            
            existingOrder = orderResults[0] || null;
          }
          
          // Check if already processed by payment intent ID
          const duplicateCheck = await db
            .select()
            .from(orders)
            .where(eq(orders.paymentIntentId, paymentIntentId))
            .limit(1);

          if (duplicateCheck.length > 0) {
            return res.json({ success: true,
              success: true,
              message: 'Order already processed',
              order: duplicateCheck[0],
              alreadyProcessed: true
            });
          }

          if (existingOrder) {
            // Update existing guest order created via /guest-checkout
            const [updatedOrder] = await db
              .update(orders)
              .set({
                status: 'paid',
                paymentIntentId: paymentIntentId,
                completedAt: new Date(),
                updatedAt: new Date()
              })
              .where(eq(orders.id, existingOrder.id))
              .returning();

            console.log('âœ… Guest order confirmed:', {
              orderId: updatedOrder.id,
              guestEmail: updatedOrder.guestEmail,
              amount: updatedOrder.totalAmount,
              paymentIntentId
            });

            // Generate download tokens for digital products
            const downloadTokens = await generateDownloadTokensForOrder(updatedOrder.id, null);

            // Send email notification for digital products
            if (downloadTokens.hasDigitalProducts && downloadTokens.tokens.length > 0) {
              try {
                const { emailService } = await import('./utils/email.js');
                const emailSent = await emailService.sendDigitalProductPurchaseEmail(updatedOrder.guestEmail!, {
                  orderId: updatedOrder.id,
                  totalPrice: parseFloat(updatedOrder.totalAmount),
                  items: downloadTokens.tokens.map(t => ({
                    name: t.productName,
                    downloadToken: t.downloadToken,
                    expiresAt: t.expiresAt
                  }))
                });

                // Only update status if email was actually sent
                if (emailSent) {
                  await db
                    .update(orders)
                    .set({
                      downloadEmailSent: true,
                      downloadEmailSentAt: new Date(),
                      digitalFulfillmentStatus: 'sent',
                      updatedAt: new Date()
                    })
                    .where(eq(orders.id, updatedOrder.id));

                  console.log('âœ… Digital product email sent to:', updatedOrder.guestEmail);
                } else {
                  console.warn('âš ï¸ Email service not configured or failed, keeping fulfillment status as pending');
                }
              } catch (emailError) {
                console.error('âŒ Failed to send digital product email:', emailError);
                // Don't fail the order, just log the error
              }
            }

            res.json({ success: true,
              success: true,
              message: 'Guest payment confirmed and order completed',
              order: updatedOrder,
              downloadTokens: downloadTokens.tokens,
              hasDigitalProducts: downloadTokens.hasDigitalProducts,
              isGuestOrder: true
            });
          } else {
            // Fallback: Create new guest order (for legacy guest payments)
            const [newOrder] = await db
              .insert(orders)
              .values({
                userId: null, // Guest orders have null userId
                guestEmail: userEmail, // Store guest email
                totalAmount: (paymentIntent.amount / 100).toFixed(2), // Convert from cents
                currency: paymentIntent.currency.toUpperCase(),
                status: 'paid',
                paymentIntentId: paymentIntentId,
                paymentMethod: 'stripe',
                customerNotes: `Guest order - Email: ${userEmail}`,
                completedAt: new Date()
              })
              .returning();

            console.log('âœ… Guest order created and completed:', {
              orderId: newOrder.id,
              guestEmail: newOrder.guestEmail,
              amount: newOrder.totalAmount,
              paymentIntentId
            });

            // Generate download tokens for digital products
            const downloadTokens = await generateDownloadTokensForOrder(newOrder.id, null);

            // Send email notification for digital products
            if (downloadTokens.hasDigitalProducts && downloadTokens.tokens.length > 0) {
              try {
                const { emailService } = await import('./utils/email.js');
                const emailSent = await emailService.sendDigitalProductPurchaseEmail(newOrder.guestEmail!, {
                  orderId: newOrder.id,
                  totalPrice: parseFloat(newOrder.totalAmount),
                  items: downloadTokens.tokens.map(t => ({
                    name: t.productName,
                    downloadToken: t.downloadToken,
                    expiresAt: t.expiresAt
                  }))
                });

                // Only update status if email was actually sent
                if (emailSent) {
                  await db
                    .update(orders)
                    .set({
                      downloadEmailSent: true,
                      downloadEmailSentAt: new Date(),
                      digitalFulfillmentStatus: 'sent',
                      updatedAt: new Date()
                    })
                    .where(eq(orders.id, newOrder.id));

                  console.log('âœ… Digital product email sent to:', newOrder.guestEmail);
                } else {
                  console.warn('âš ï¸ Email service not configured or failed, keeping fulfillment status as pending');
                }
              } catch (emailError) {
                console.error('âŒ Failed to send digital product email:', emailError);
              }
            }

            res.json({ success: true,
              success: true,
              message: 'Guest payment confirmed and order completed',
              order: newOrder,
              downloadTokens: downloadTokens.tokens,
              hasDigitalProducts: downloadTokens.hasDigitalProducts,
              isGuestOrder: true
            });
          }

        } catch (guestError) {
          console.error('Guest order confirmation error:', guestError);
          return res.status(500).json({
            success: false,
            error: 'Payment successful but failed to confirm guest order'
          });
        }
      } 
      // Handle authenticated user orders
      else {
        // Get authentication for regular users
        const authHeader = req.headers.authorization;
        const sessionId = authHeader?.replace('Bearer ', '') || req.headers['x-session-id'] as string;
        
        if (!sessionId) {
          return res.status(401).json({
            success: false,
            error: 'Authentication required for user orders'
          });
        }

        // Validate session
        const session = await db.select()
          .from(userLoginSessions)
          .where(and(
            eq(userLoginSessions.sessionId, sessionId),
            eq(userLoginSessions.isActive, true),
            gt(userLoginSessions.expiresAt, new Date())
          ))
          .limit(1);

        if (session.length === 0) {
          return res.status(401).json({
            success: false,
            error: 'Invalid or expired session'
          });
        }

        const authenticatedUserId = session[0].userId;

        // Additional security: verify the order belongs to the authenticated user
        const [existingOrder] = await db
          .select()
          .from(orders)
          .where(and(
            eq(orders.id, orderId),
            eq(orders.userId, authenticatedUserId)
          ))
          .limit(1);

        if (!existingOrder) {
          return res.status(404).json({
            success: false,
            error: 'Order not found or access denied'
          });
        }

        // Verify payment intent metadata matches our order and authenticated user
        if (paymentIntent.metadata.orderId !== orderId || paymentIntent.metadata.userId !== authenticatedUserId) {
          return res.status(400).json({
            success: false,
            error: 'Payment intent does not match order details or authenticated user'
          });
        }

        // Double-check payment amount matches order amount for security
        const expectedAmountInCents = Math.round(parseFloat(existingOrder.totalAmount) * 100);
        if (paymentIntent.amount !== expectedAmountInCents) {
          return res.status(400).json({
            success: false,
            error: 'Payment amount does not match order total'
          });
        }

        // Update existing order
        const [updatedOrder] = await db
          .update(orders)
          .set({
            status: 'paid' as const,
            paymentIntentId: paymentIntentId,
            completedAt: new Date(),
            updatedAt: new Date()
          })
          .where(and(
            eq(orders.id, orderId),
            eq(orders.userId, authenticatedUserId)
          ))
          .returning();

        if (!updatedOrder) {
          return res.status(404).json({
            success: false,
            error: 'Failed to update order status'
          });
        }

        // ===== CRITICAL FIX: Create shopPurchases entries so purchases appear in dashboard =====
        try {
          // Get or create shop customer
          let [shopCustomer] = await db
            .select()
            .from(shopCustomers)
            .where(eq(shopCustomers.userId, authenticatedUserId))
            .limit(1);

          if (!shopCustomer) {
            // Create shop customer if doesn't exist
            const [user] = await db
              .select()
              .from(users)
              .where(eq(users.id, authenticatedUserId))
              .limit(1);

            if (user) {
              [shopCustomer] = await db
                .insert(shopCustomers)
                .values({
                  userId: authenticatedUserId,
                  fullName: user.fullName || user.email,
                  email: user.email,
                  accountType: 'free'
                })
                .returning();
            }
          }

          if (shopCustomer) {
            // Get order items to create shop purchases
            const items = await db
              .select({
                orderItem: orderItems,
                product: products
              })
              .from(orderItems)
              .leftJoin(products, eq(orderItems.productId, products.id))
              .where(eq(orderItems.orderId, updatedOrder.id));

            // Create shop purchase entry for each item
            for (const item of items) {
              if (item.product) {
                await db.insert(shopPurchases).values({
                  customerId: shopCustomer.id,
                  itemName: item.product.name,
                  itemType: item.product.type || 'digital',
                  downloadUrl: item.product.fileUrl || '',
                  thumbnailUrl: item.product.images?.[0] || null,
                  price: item.orderItem.unitPrice,
                  orderId: updatedOrder.id,
                  status: 'completed'
                });
              }
            }

            console.log('âœ… Created shop purchase records for order:', updatedOrder.id);
          }
        } catch (purchaseError) {
          console.error('Failed to create shop purchases (non-critical):', purchaseError);
          // Don't fail the payment confirmation, but log the error
        }
        // ===== END CRITICAL FIX =====

        // NOTE: Download limits are now checked at download time, not at purchase time
        // A user who pays for a product should always be able to access their purchase
        // regardless of their download limits at the time of payment confirmation

        // Generate download tokens for digital products
        const downloadTokens = await generateDownloadTokensForOrder(updatedOrder.id, authenticatedUserId);

        // Send email notification for digital products
        if (downloadTokens.hasDigitalProducts && downloadTokens.tokens.length > 0) {
          try {
            // Get user email
            const [user] = await db
              .select()
              .from(users)
              .where(eq(users.id, authenticatedUserId))
              .limit(1);

            if (user?.email) {
              const { emailService } = await import('./utils/email.js');
              const emailSent = await emailService.sendDigitalProductPurchaseEmail(user.email, {
                orderId: updatedOrder.id,
                customerName: user.fullName || undefined,
                totalPrice: parseFloat(updatedOrder.totalAmount),
                items: downloadTokens.tokens.map(t => ({
                  name: t.productName,
                  downloadToken: t.downloadToken,
                  expiresAt: t.expiresAt
                }))
              });

              // Only update status if email was actually sent
              if (emailSent) {
                await db
                  .update(orders)
                  .set({
                    downloadEmailSent: true,
                    downloadEmailSentAt: new Date(),
                    digitalFulfillmentStatus: 'sent',
                    updatedAt: new Date()
                  })
                  .where(eq(orders.id, updatedOrder.id));

                console.log('âœ… Digital product email sent to:', user.email);
              } else {
                console.warn('âš ï¸ Email service not configured or failed, keeping fulfillment status as pending');
              }
            }
          } catch (emailError) {
            console.error('âŒ Failed to send digital product email:', emailError);
          }
        }

        res.json({ success: true,
          success: true,
          message: 'Payment confirmed and order completed',
          order: updatedOrder,
          downloadTokens: downloadTokens.tokens,
          hasDigitalProducts: downloadTokens.hasDigitalProducts,
          isGuestOrder: false
        });
      }

    } catch (error: any) {
      console.error('Order payment confirmation error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to confirm payment'
      });
    }
  });

  // ============================================
  // TRANSACTION MANAGEMENT API ENDPOINTS
  // ============================================

  // Get user balance
  app.get('/api/transactions/balance/:userId', async (req, res) => {
    try {
      const { userId } = req.params;
      
      const userBalance = await db
        .select()
        .from(userBalances)
        .where(eq(userBalances.userId, userId))
        .limit(1);

      if (userBalance.length === 0) {
        // Create initial balance if doesn't exist
        const [newBalance] = await db
          .insert(userBalances)
          .values({
            userId: userId,
            availableBalance: '0.00',
            totalEarnings: '0.00',
            totalWithdrawn: '0.00',
            pendingPayouts: '0.00'
          })
          .returning();

        return res.json({ success: true,
          success: true,
          balance: newBalance
        });
      }

      res.json({ success: true,
        success: true,
        balance: userBalance[0]
      });

    } catch (error: any) {
      console.error('Error fetching user balance:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch balance'
      });
    }
  });

  // Get user transactions with filters
  app.get('/api/transactions/:userId', async (req, res) => {
    try {
      const { userId } = req.params;
      const { type, status, method, page = 1, limit = 10 } = req.query;
      
      const offset = (Number(page) - 1) * Number(limit);
      
      let query = db
        .select()
        .from(transactions)
        .where(eq(transactions.userId, userId));

      // Apply filters
      if (type) {
        query = query.where(and(eq(transactions.userId, userId), eq(transactions.type, type as string)));
      }
      if (status) {
        query = query.where(and(eq(transactions.userId, userId), eq(transactions.status, status as string)));
      }
      if (method) {
        query = query.where(and(eq(transactions.userId, userId), eq(transactions.method, method as string)));
      }

      const userTransactions = await query
        .orderBy(desc(transactions.createdAt))
        .limit(Number(limit))
        .offset(offset);

      // Get total count for pagination
      const totalCountResult = await db
        .select({ count: count() })
        .from(transactions)
        .where(eq(transactions.userId, userId));

      res.json({ success: true,
        success: true,
        transactions: userTransactions,
        pagination: {
          page: Number(page),
          limit: Number(limit),
          total: totalCountResult[0].count,
          totalPages: Math.ceil(totalCountResult[0].count / Number(limit))
        }
      });

    } catch (error: any) {
      console.error('Error fetching transactions:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch transactions'
      });
    }
  });

  // Request payout
  app.post('/api/transactions/request-payout', async (req, res) => {
    try {
      const { userId, amount, payoutAccountId, description } = req.body;

      if (!userId || !amount || !payoutAccountId) {
        return res.status(400).json({
          success: false,
          error: 'Missing required fields: userId, amount, payoutAccountId'
        });
      }

      // Check user balance
      const userBalance = await db
        .select()
        .from(userBalances)
        .where(eq(userBalances.userId, userId))
        .limit(1);

      if (userBalance.length === 0 || Number(userBalance[0].availableBalance) < Number(amount)) {
        return res.status(400).json({
          success: false,
          error: 'Insufficient balance'
        });
      }

      // Check payout account exists and is verified
      const payoutAccount = await db
        .select()
        .from(payoutAccounts)
        .where(and(
          eq(payoutAccounts.id, payoutAccountId),
          eq(payoutAccounts.userId, userId),
          eq(payoutAccounts.isVerified, true)
        ))
        .limit(1);

      if (payoutAccount.length === 0) {
        return res.status(400).json({
          success: false,
          error: 'Payout account not found or not verified'
        });
      }

      // Create payout transaction
      const [newTransaction] = await db
        .insert(transactions)
        .values({
          userId: userId,
          type: 'debit',
          amount: amount.toString(),
          status: 'pending',
          method: payoutAccount[0].type,
          description: description || `Payout to ${payoutAccount[0].accountName}`,
          payoutAccountId: payoutAccountId
        })
        .returning();

      // Update pending payouts
      await db
        .update(userBalances)
        .set({
          pendingPayouts: sql`${userBalances.pendingPayouts} + ${amount}`,
          lastUpdated: new Date()
        })
        .where(eq(userBalances.userId, userId));

      res.json({ success: true,
        success: true,
        transaction: newTransaction,
        message: 'Payout request submitted successfully'
      });

    } catch (error: any) {
      console.error('Error requesting payout:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to request payout'
      });
    }
  });

  // Get user payout accounts
  app.get('/api/payout-accounts/:userId', async (req, res) => {
    try {
      const { userId } = req.params;
      
      const accounts = await db
        .select({
          id: payoutAccounts.id,
          type: payoutAccounts.type,
          accountName: payoutAccounts.accountName,
          isVerified: payoutAccounts.isVerified,
          isDefault: payoutAccounts.isDefault,
          createdAt: payoutAccounts.createdAt,
          // Mask sensitive details
          details: sql`jsonb_build_object(
            'masked', true,
            'type', ${payoutAccounts.type}
          )`
        })
        .from(payoutAccounts)
        .where(eq(payoutAccounts.userId, userId))
        .orderBy(desc(payoutAccounts.isDefault), desc(payoutAccounts.createdAt));

      res.json({ success: true,
        success: true,
        accounts: accounts
      });

    } catch (error: any) {
      console.error('Error fetching payout accounts:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch payout accounts'
      });
    }
  });

  // Add payout account
  app.post('/api/payout-accounts', async (req, res) => {
    try {
      // Validate request body using Zod schema
      const validationResult = insertPayoutAccountSchema.safeParse(req.body);
      
      if (!validationResult.success) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: validationResult.error.issues.map(issue => ({
            field: issue.path.join('.'),
            message: issue.message
          }))
        });
      }

      const { userId, type, accountName, details, isDefault } = validationResult.data;

      // If setting as default, remove default from other accounts
      if (isDefault) {
        await db
          .update(payoutAccounts)
          .set({ isDefault: false })
          .where(eq(payoutAccounts.userId, userId));
      }

      const [newAccount] = await db
        .insert(payoutAccounts)
        .values({
          userId: userId,
          type: type,
          accountName: accountName,
          details: details,
          isDefault: isDefault || false,
          isVerified: false // Admin needs to verify
        })
        .returning();

      res.json({ success: true,
        success: true,
        account: {
          ...newAccount,
          details: { masked: true, type: newAccount.type } // Mask in response
        },
        message: 'Payout account added successfully. Pending admin verification.'
      });

    } catch (error: any) {
      console.error('Error adding payout account:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to add payout account'
      });
    }
  });

  // Set default payout account
  app.put('/api/payout-accounts/:accountId/set-default', async (req, res) => {
    try {
      const { accountId } = req.params;
      const { userId } = req.body;

      // First, get the account to verify ownership
      const account = await db
        .select()
        .from(payoutAccounts)
        .where(eq(payoutAccounts.id, accountId))
        .limit(1);

      if (account.length === 0) {
        return res.status(404).json({
          success: false,
          error: 'Payout account not found'
        });
      }

      // Verify ownership (if userId is provided)
      if (userId && account[0].userId !== userId) {
        return res.status(403).json({
          success: false,
          error: 'Unauthorized access to payout account'
        });
      }

      // Remove default from all user's accounts
      await db
        .update(payoutAccounts)
        .set({ isDefault: false })
        .where(eq(payoutAccounts.userId, account[0].userId));

      // Set this account as default
      await db
        .update(payoutAccounts)
        .set({ isDefault: true })
        .where(eq(payoutAccounts.id, accountId));

      res.json({ success: true,
        success: true,
        message: 'Default payout account updated successfully'
      });

    } catch (error: any) {
      console.error('Error setting default payout account:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to set default payout account'
      });
    }
  });

  // Delete payout account
  app.delete('/api/payout-accounts/:accountId', async (req, res) => {
    try {
      const { accountId } = req.params;
      const { userId } = req.body;

      // First, get the account to verify ownership
      const account = await db
        .select()
        .from(payoutAccounts)
        .where(eq(payoutAccounts.id, accountId))
        .limit(1);

      if (account.length === 0) {
        return res.status(404).json({
          success: false,
          error: 'Payout account not found'
        });
      }

      // Verify ownership (if userId is provided)
      if (userId && account[0].userId !== userId) {
        return res.status(403).json({
          success: false,
          error: 'Unauthorized access to payout account'
        });
      }

      // Check if there are pending transactions using this account
      const pendingTransactions = await db
        .select()
        .from(transactions)
        .where(and(
          eq(transactions.payoutAccountId, accountId),
          eq(transactions.status, 'pending')
        ))
        .limit(1);

      if (pendingTransactions.length > 0) {
        return res.status(400).json({
          success: false,
          error: 'Cannot delete account with pending transactions'
        });
      }

      // Delete the account
      await db
        .delete(payoutAccounts)
        .where(eq(payoutAccounts.id, accountId));

      res.json({ success: true,
        success: true,
        message: 'Payout account deleted successfully'
      });

    } catch (error: any) {
      console.error('Error deleting payout account:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to delete payout account'
      });
    }
  });

  // Admin: Get all transactions with filters

  app.get('/api/admin/transactions', requireAuth, requireAdmin, async (req, res) => {
    try {
      const { status, method, userId, page = 1, limit = 20 } = req.query;
      
      const offset = (Number(page) - 1) * Number(limit);
      
      let query = db
        .select({
          id: transactions.id,
          userId: transactions.userId,
          type: transactions.type,
          amount: transactions.amount,
          status: transactions.status,
          method: transactions.method,
          description: transactions.description,
          createdAt: transactions.createdAt,
          processedAt: transactions.processedAt,
          adminNotes: transactions.adminNotes,
          // Join with user profile for user name
          userName: profiles.name,
          userEmail: profiles.email
        })
        .from(transactions)
        .leftJoin(profiles, eq(transactions.userId, profiles.userId));

      // Apply filters
      const conditions = [];
      if (status) conditions.push(eq(transactions.status, status as string));
      if (method) conditions.push(eq(transactions.method, method as string));
      if (userId) conditions.push(eq(transactions.userId, userId as string));

      if (conditions.length > 0) {
        query = query.where(and(...conditions));
      }

      const allTransactions = await query
        .orderBy(desc(transactions.createdAt))
        .limit(Number(limit))
        .offset(offset);

      // Get total count
      const totalCountResult = await db
        .select({ count: count() })
        .from(transactions);

      res.json({ success: true,
        success: true,
        transactions: allTransactions,
        pagination: {
          page: Number(page),
          limit: Number(limit),
          total: totalCountResult[0].count,
          totalPages: Math.ceil(totalCountResult[0].count / Number(limit))
        }
      });

    } catch (error: any) {
      console.error('Error fetching admin transactions:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch transactions'
      });
    }
  });

  // Admin: Approve/decline payout
  app.patch('/api/admin/transactions/:id/approve', requireAuth, requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { action, adminNotes, adminId } = req.body; // action: 'approve' or 'decline'

      if (!action || !adminId) {
        return res.status(400).json({
          success: false,
          error: 'Missing action or adminId'
        });
      }

      // Get transaction details
      const transaction = await db
        .select()
        .from(transactions)
        .where(eq(transactions.id, id))
        .limit(1);

      if (transaction.length === 0) {
        return res.status(404).json({
          success: false,
          error: 'Transaction not found'
        });
      }

      const tx = transaction[0];
      
      if (tx.status !== 'pending') {
        return res.status(400).json({
          success: false,
          error: 'Transaction is not pending'
        });
      }

      const newStatus = action === 'approve' ? 'completed' : 'failed';
      
      // Update transaction
      await db
        .update(transactions)
        .set({
          status: newStatus,
          processedBy: adminId,
          processedAt: new Date(),
          adminNotes: adminNotes || null
        })
        .where(eq(transactions.id, id));

      // Process actual payout if approved and method is PayPal
      let paypalPayoutId = null;
      if (action === 'approve' && tx.method === 'paypal') {
        try {
          // Get payout account details
          const payoutAccount = await db
            .select()
            .from(payoutAccounts)
            .where(eq(payoutAccounts.id, tx.payoutAccountId!))
            .limit(1);

          if (payoutAccount.length > 0) {
            const accountDetails = payoutAccount[0].details as any;
            
            // Create PayPal payout
            const request = new paypal.payouts.PayoutsPostRequest();
            request.requestBody({
              sender_batch_header: {
                sender_batch_id: `payout_${tx.id}_${Date.now()}`,
                email_subject: "You have a payout from EduFiliova!",
                email_message: "You have received a payout from your EduFiliova earnings."
              },
              items: [
                {
                  recipient_type: "EMAIL",
                  amount: {
                    value: tx.amount,
                    currency: "USD"
                  },
                  receiver: accountDetails.email,
                  note: tx.description,
                  sender_item_id: tx.id
                }
              ]
            });

            const client = paypalClient();
            const response = await client.execute(request);
            
            if (response.statusCode === 201) {
              paypalPayoutId = response.result.batch_header.payout_batch_id;
              console.log('âœ… PayPal payout processed:', paypalPayoutId);
            } else {
              throw new Error('PayPal payout failed');
            }
          }
        } catch (paypalError) {
          console.error('PayPal payout error:', paypalError);
          // Continue with the transaction but log the error
          // In production, you might want to set status to 'failed' and notify admin
        }
      }

      // Update transaction with PayPal payout ID if applicable
      await db
        .update(transactions)
        .set({
          status: newStatus,
          processedBy: adminId,
          processedAt: new Date(),
          adminNotes: adminNotes || null,
          paypalPayoutId: paypalPayoutId
        })
        .where(eq(transactions.id, id));

      // Update user balance
      if (action === 'approve') {
        // Deduct from available balance and pending payouts
        await db
          .update(userBalances)
          .set({
            availableBalance: sql`${userBalances.availableBalance} - ${tx.amount}`,
            totalWithdrawn: sql`${userBalances.totalWithdrawn} + ${tx.amount}`,
            pendingPayouts: sql`${userBalances.pendingPayouts} - ${tx.amount}`,
            lastUpdated: new Date()
          })
          .where(eq(userBalances.userId, tx.userId));
      } else {
        // Just remove from pending payouts
        await db
          .update(userBalances)
          .set({
            pendingPayouts: sql`${userBalances.pendingPayouts} - ${tx.amount}`,
            lastUpdated: new Date()
          })
          .where(eq(userBalances.userId, tx.userId));
      }

      res.json({ success: true,
        success: true,
        message: `Payout ${action}d successfully`
      });

    } catch (error: any) {
      console.error('Error processing payout:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to process payout'
      });
    }
  });


  // Admin: Get transaction statistics for dashboard
  app.get('/api/admin/stats-test', requireAuth, requireAdmin, async (req, res) => {
    try {
      // Run all queries in parallel for better performance
      const [
        totalTransactionsResult,
        pendingPayoutsResult,
        totalVolumeResult,
        activeUsersResult,
        completedOrdersResult,
        topFreelancersResult,
        recentTransactionsResult,
        creatorEarningsResult
      ] = await Promise.all([
        // Total transactions count
        db.select({ count: count() }).from(transactions),
        
        // Pending payouts count (debit transactions that are pending)
        db.select({ count: count() })
          .from(transactions)
          .where(and(
            eq(transactions.type, 'debit'),
            eq(transactions.status, 'pending')
          )),
        
        // Total volume (sum of all transaction amounts)
        db.select({ total: sql<string>`COALESCE(SUM(CAST(${transactions.amount} AS DECIMAL)), 0)` })
          .from(transactions),
        
        // Active users (distinct users with transactions)
        db.selectDistinct({ userId: transactions.userId }).from(transactions),
        
        // Completed orders for revenue calculation
        db.select({ 
          total: sql<string>`COALESCE(SUM(CAST(${orders.totalAmount} AS DECIMAL)), 0)` 
        })
          .from(orders)
          .where(eq(orders.status, 'paid')),
        
        // Top freelancers by earnings
        db.select({
          userId: transactions.userId,
          userName: profiles.name,
          userEmail: profiles.email,
          totalEarnings: sql<string>`COALESCE(SUM(CAST(${transactions.amount} AS DECIMAL)), 0)`,
          transactionCount: count()
        })
          .from(transactions)
          .leftJoin(profiles, eq(transactions.userId, profiles.userId))
          .where(and(
            eq(transactions.type, 'credit'),
            eq(transactions.status, 'completed')
          ))
          .groupBy(transactions.userId, profiles.name, profiles.email)
          .orderBy(sql`COALESCE(SUM(CAST(${transactions.amount} AS DECIMAL)), 0) DESC`)
          .limit(10),
        
        // Recent transactions
        db.select({
          id: transactions.id,
          userId: transactions.userId,
          userName: profiles.name,
          userEmail: profiles.email,
          type: transactions.type,
          amount: transactions.amount,
          status: transactions.status,
          method: transactions.method,
          description: transactions.description,
          createdAt: transactions.createdAt
        })
          .from(transactions)
          .leftJoin(profiles, eq(transactions.userId, profiles.userId))
          .orderBy(desc(transactions.createdAt))
          .limit(20),
        
        // Get creator earnings summary for commission calculation
        db.select({
          platformCommission: sql<string>`COALESCE(SUM(CAST(${creatorEarningEvents.platformCommission} AS DECIMAL)), 0)`,
          creatorAmount: sql<string>`COALESCE(SUM(CAST(${creatorEarningEvents.creatorAmount} AS DECIMAL)), 0)`,
          grossAmount: sql<string>`COALESCE(SUM(CAST(${creatorEarningEvents.grossAmount} AS DECIMAL)), 0)`
        })
          .from(creatorEarningEvents)
          .where(eq(creatorEarningEvents.status, 'available'))
      ]);

      // Convert strings to numbers
      const totalTransactions = Number(totalTransactionsResult[0]?.count || 0);
      const pendingPayouts = Number(pendingPayoutsResult[0]?.count || 0);
      const totalVolume = parseFloat(totalVolumeResult[0]?.total || '0');
      const activeUsers = activeUsersResult.length;
      const totalRevenue = parseFloat(completedOrdersResult[0]?.total || '0');
      
      // Calculate commission from creator earnings or fallback to order-based calculation
      let platformCommission = 0;
      let freelancerEarnings = 0;
      
      if (creatorEarningsResult.length > 0 && parseFloat(creatorEarningsResult[0].grossAmount) > 0) {
        // Use creator earning events for accurate commission tracking
        platformCommission = parseFloat(creatorEarningsResult[0].platformCommission || '0');
        freelancerEarnings = parseFloat(creatorEarningsResult[0].creatorAmount || '0');
      } else {
        // Fallback: calculate 35% commission from total revenue
        platformCommission = totalRevenue * 0.35;
        freelancerEarnings = totalRevenue * 0.65;
      }

      // Format top freelancers
      const topFreelancers = topFreelancersResult.map(f => ({
        userId: f.userId,
        name: f.userName || 'Unknown User',
        email: f.userEmail || 'No email',
        totalEarnings: parseFloat(f.totalEarnings || '0'),
        transactionCount: Number(f.transactionCount || 0)
      }));

      res.json({ success: true,
        success: true,
        stats: {
          totalTransactions,
          pendingPayouts,
          totalVolume,
          activeUsers,
          totalRevenue,
          platformCommission,
          freelancerEarnings,
          topFreelancers,
          recentTransactions: recentTransactionsResult
        }
      });

    } catch (error: any) {
      console.error('Error fetching admin stats:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch statistics'
      });
    }
  });

  // Admin: Get transactions with pagination and filters (test endpoint)
  app.get('/api/admin/transactions-test', requireAuth, requireAdmin, async (req, res) => {
    try {
      const { status, method, userId, page = 1, limit = 20 } = req.query;
      
      const offset = (Number(page) - 1) * Number(limit);
      
      let query = db
        .select({
          id: transactions.id,
          userId: transactions.userId,
          type: transactions.type,
          amount: transactions.amount,
          status: transactions.status,
          method: transactions.method,
          description: transactions.description,
          createdAt: transactions.createdAt,
          processedAt: transactions.processedAt,
          adminNotes: transactions.adminNotes,
          userName: profiles.name,
          userEmail: profiles.email
        })
        .from(transactions)
        .leftJoin(profiles, eq(transactions.userId, profiles.userId));

      // Apply filters
      const conditions = [];
      if (status && status !== 'all') conditions.push(eq(transactions.status, status as string));
      if (method && method !== 'all') conditions.push(eq(transactions.method, method as string));
      if (userId) conditions.push(eq(transactions.userId, userId as string));

      if (conditions.length > 0) {
        query = query.where(and(...conditions));
      }

      const allTransactions = await query
        .orderBy(desc(transactions.createdAt))
        .limit(Number(limit))
        .offset(offset);

      // Get total count for pagination
      let countQuery = db.select({ count: count() }).from(transactions);
      if (conditions.length > 0) {
        countQuery = countQuery.where(and(...conditions));
      }
      const totalCountResult = await countQuery;

      res.json({ success: true,
        success: true,
        transactions: allTransactions,
        pagination: {
          page: Number(page),
          limit: Number(limit),
          total: Number(totalCountResult[0]?.count || 0),
          totalPages: Math.ceil(Number(totalCountResult[0]?.count || 0) / Number(limit))
        }
      });

    } catch (error: any) {
      console.error('Error fetching admin transactions:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch transactions'
      });
    }
  });

  // Admin: Get all payout accounts for verification
  // Admin: Get all payout accounts for verification
  app.get('/api/admin/payout-accounts', requireAuth, requireAdmin, async (req, res) => {
    try {
      const { status = 'all', page = 1, limit = 20 } = req.query;
      
      const offset = (Number(page) - 1) * Number(limit);
      
      let query = db
        .select({
          id: payoutAccounts.id,
          userId: payoutAccounts.userId,
          type: payoutAccounts.type,
          accountName: payoutAccounts.accountName,
          isVerified: payoutAccounts.isVerified,
          isDefault: payoutAccounts.isDefault,
          createdAt: payoutAccounts.createdAt,
          verifiedAt: payoutAccounts.verifiedAt,
          // Join with user profile for user info
          userName: profiles.name,
          userEmail: profiles.email,
          // Show unmasked details for admin review
          details: payoutAccounts.details
        })
        .from(payoutAccounts)
        .leftJoin(profiles, eq(payoutAccounts.userId, profiles.userId));
      
      // Apply status filter
      if (status === 'pending') {
        query = query.where(eq(payoutAccounts.isVerified, false));
      } else if (status === 'verified') {
        query = query.where(eq(payoutAccounts.isVerified, true));
      }
      
      const allAccounts = await query
        .orderBy(desc(payoutAccounts.createdAt))
        .limit(Number(limit))
        .offset(offset);
      
      // Get total count
      const totalCountQuery = db
        .select({ count: count() })
        .from(payoutAccounts);
        
      if (status === 'pending') {
        totalCountQuery.where(eq(payoutAccounts.isVerified, false));
      } else if (status === 'verified') {
        totalCountQuery.where(eq(payoutAccounts.isVerified, true));
      }
      
      const totalCountResult = await totalCountQuery;
      
      res.json({ success: true,
        success: true,
        accounts: allAccounts,
        pagination: {
          page: Number(page),
          limit: Number(limit),
          total: totalCountResult[0].count,
          totalPages: Math.ceil(totalCountResult[0].count / Number(limit))
        }
      });
      
    } catch (error: any) {
      console.error('Error fetching admin payout accounts:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch payout accounts'
      });
    }
  });

  // Admin: Verify payout account
  app.patch('/api/admin/payout-accounts/:id/verify', requireAuth, requireAdmin, async (req, res) => {
    console.log('ðŸš€ ENDPOINT HIT: /api/admin/payout-accounts/:id/verify');
    const { id } = req.params;
    const { action } = req.body; // action can be 'approve' or 'decline'
    
    try {
      const adminUserId = req.user?.userId || req.user?.id; // For logging purposes
      const adminId = req.user?.id; // UUID for database

      console.log('ðŸ” Payment approval request received:', {
        accountId: id,
        action: action,
        adminUserId: adminUserId,
        adminId: adminId,
        userFromReq: req.user,
        headers: {
          authorization: req.headers.authorization,
          sessionId: req.headers['x-session-id']
        },
        body: req.body,
        method: req.method
      });

      if (!action) {
        console.log('âŒ No action provided');
        return res.status(400).json({
          success: false,
          error: 'Action is required'
        });
      }

      if (!adminId) {
        console.log('âŒ No admin ID found');
        return res.status(401).json({
          success: false,
          error: 'Admin ID not found'
        });
      }

      if (action === 'approve') {
        console.log('âœ… Attempting to approve payout account:', id);
        await db
          .update(payoutAccounts)
          .set({
            isVerified: true,
            verifiedAt: new Date(),
            verifiedBy: adminId
          })
          .where(eq(payoutAccounts.id, id));
        
        console.log('âœ… Payout account approved successfully');
        
        res.json({ success: true,
          success: true,
          message: 'Payout account approved successfully'
        });
      } else if (action === 'decline') {
        console.log('âŒ Attempting to decline payout account:', id);
        
        // Get the account details before deletion for notification
        const accountToDecline = await db
          .select()
          .from(payoutAccounts)
          .where(eq(payoutAccounts.id, id))
          .limit(1);
        
        if (accountToDecline.length > 0) {
          const account = accountToDecline[0];
          
          // Insert a notification for the user about the decline
          try {
            await db.insert(moderationLogs).values({
              moderatorId: adminId,
              actionType: 'account_declined',
              targetType: 'payout_account',
              targetId: id,
              reason: `Payment method declined: ${account.accountName} (${account.type})`,
              details: {
                accountName: account.accountName,
                accountType: account.type,
                userId: account.userId,
                declinedAt: new Date().toISOString(),
                message: 'Your payment method was declined for verification. Please check the details and try again, or contact support if you need assistance.'
              },
              originalContent: JSON.stringify(account)
            });
            console.log('ðŸ“§ Decline notification sent to user');
          } catch (notifyError) {
            console.error('Error creating decline notification:', notifyError);
          }
        }
        
        // For declined accounts, we delete them
        await db
          .delete(payoutAccounts)
          .where(eq(payoutAccounts.id, id));
          
        console.log('âŒ Payout account declined and removed successfully');
        res.json({ success: true,
          success: true,
          message: 'Payout account declined and removed'
        });
      } else {
        console.log('âŒ Invalid action provided:', action);
        res.status(400).json({
          success: false,
          error: 'Invalid action. Use "approve" or "decline"'
        });
      }

    } catch (error: any) {
      console.error('Error processing payout account:', {
        error: error instanceof Error ? error.message : 'Unknown error',
        accountId: id,
        action: req.body.action,
        adminUserId: req.user?.userId || req.user?.id,
        stack: error instanceof Error ? error.stack : undefined
      });
      res.status(500).json({
        success: false,
        error: 'Failed to process payout account'
      });
    }
  });

  // Get user notifications for authenticated user
  app.get('/api/notifications', async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);

      if (!user) {
        return res.status(401).json({
          success: false,
          error: 'Authentication required'
        });
      }

      const userNotifications = await db
        .select({
          id: notifications.id,
          title: notifications.title,
          content: notifications.message,
          type: notifications.type,
          isRead: notifications.isRead,
          createdAt: notifications.createdAt,
          actionUrl: notifications.actionUrl,
          metadata: notifications.metadata,
        })
        .from(notifications)
        .where(eq(notifications.userId, user.id))
        .orderBy(desc(notifications.createdAt))
        .limit(50);

      return res.json(userNotifications);

    } catch (error: any) {
      console.error('Error fetching notifications:', error);
      return res.status(500).json({
        success: false,
        error: 'Failed to fetch notifications'
      });
    }
  });

  // Get user notifications (including account decline notifications)
  app.get('/api/notifications/:userId', async (req, res) => {
    try {
      const { userId } = req.params;
      
      // Fetch notifications from the notifications table
      const userNotifications = await db
        .select({
          id: notifications.id,
          title: notifications.title,
          content: notifications.message,
          message: notifications.message,
          type: notifications.type,
          isRead: notifications.isRead,
          actionUrl: notifications.actionUrl,
          metadata: notifications.metadata,
          createdAt: notifications.createdAt,
        })
        .from(notifications)
        .where(eq(notifications.userId, userId))
        .orderBy(desc(notifications.createdAt))
        .limit(50);

      res.json({ success: true,
        success: true,
        notifications: userNotifications
      });

    } catch (error: any) {
      console.error('Error fetching notifications:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch notifications'
      });
    }
  });

  // Mark notification as read
  app.put('/api/notifications/:notificationId/read', async (req, res) => {
    try {
      const { notificationId } = req.params;
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);

      if (!user) {
        return res.status(401).json({
          success: false,
          error: 'Authentication required'
        });
      }

      // Update notification to mark as read
      const [updatedNotification] = await db
        .update(notifications)
        .set({ isRead: true })
        .where(and(
          eq(notifications.id, notificationId),
          eq(notifications.userId, user.id)
        ))
        .returning();

      if (!updatedNotification) {
        return res.status(404).json({
          success: false,
          error: 'Notification not found'
        });
      }

      return res.json({ success: true,
        success: true,
        notification: updatedNotification
      });

    } catch (error: any) {
      console.error('Error marking notification as read:', error);
      return res.status(500).json({
        success: false,
        error: 'Failed to mark notification as read'
      });
    }
  });


  // Credit user account (for earnings)
  app.post('/api/transactions/credit', async (req, res) => {
    try {
      const { userId, amount, description, reference } = req.body;

      if (!userId || !amount || !description) {
        return res.status(400).json({
          success: false,
          error: 'Missing required fields'
        });
      }

      // Create credit transaction
      const [newTransaction] = await db
        .insert(transactions)
        .values({
          userId: userId,
          type: 'credit',
          amount: amount.toString(),
          status: 'paid',
          description: description,
          reference: reference || null
        })
        .returning();

      // Update user balance
      await db
        .update(userBalances)
        .set({
          availableBalance: sql`${userBalances.availableBalance} + ${amount}`,
          totalEarnings: sql`${userBalances.totalEarnings} + ${amount}`,
          lastUpdated: new Date()
        })
        .where(eq(userBalances.userId, userId));

      res.json({ success: true,
        success: true,
        transaction: newTransaction,
        message: 'Account credited successfully'
      });

    } catch (error: any) {
      console.error('Error crediting account:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to credit account'
      });
    }
  });

  // ============================================
  // BANK DATA MANAGEMENT ENDPOINTS
  // ============================================

  // Get banks by country
  app.get('/api/banks/:countryCode', async (req, res) => {
    try {
      const { countryCode } = req.params;
      
      try {
        const countryBanks = await db
          .select({
            id: banks.id,
            bankName: banks.bankName,
            bankCode: banks.bankCode,
            swiftCode: banks.swiftCode
          })
          .from(banks)
          .where(and(
            eq(banks.countryCode, countryCode.toUpperCase()),
            eq(banks.isActive, true)
          ))
          .orderBy(asc(banks.bankName));

        res.json({ success: true,
          success: true,
          banks: countryBanks,
          count: countryBanks.length
        });
      } catch (dbError) {
        // Return empty array if table doesn't exist yet
        res.json({ success: true,
          success: true,
          banks: [],
          count: 0,
          message: 'Banks table not yet created'
        });
      }

    } catch (error: any) {
      console.error('Error fetching banks:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch banks'
      });
    }
  });

  // Temporary public endpoint for development seeding
  app.post('/api/seed-banks-dev', async (req, res) => {
    try {
      console.log('ðŸ¦ Starting comprehensive bank seeding process...');
      const bankData = [
        // United States
        { countryCode: 'US', bankName: 'Bank of America', bankCode: '026009593', swiftCode: 'BOFAUS3N' },
        { countryCode: 'US', bankName: 'JPMorgan Chase Bank', bankCode: '021000021', swiftCode: 'CHASUS33' },
        { countryCode: 'US', bankName: 'Wells Fargo Bank', bankCode: '121000248', swiftCode: 'WFBIUS6S' },
        { countryCode: 'US', bankName: 'Citibank', bankCode: '021000089', swiftCode: 'CITIUS33' },
        { countryCode: 'US', bankName: 'U.S. Bank', bankCode: '091000022', swiftCode: 'USBKUS44' },
        { countryCode: 'US', bankName: 'PNC Bank', bankCode: '043000096', swiftCode: 'PNCCUS33' },
        { countryCode: 'US', bankName: 'Capital One Bank', bankCode: '051405515', swiftCode: 'HIBKUS44' },
        { countryCode: 'US', bankName: 'Goldman Sachs Bank', bankCode: '124071889', swiftCode: 'GSBNUSC1' },
        { countryCode: 'US', bankName: 'Morgan Stanley Bank', bankCode: '102000021', swiftCode: 'MSBUS3NS' },
        { countryCode: 'US', bankName: 'American Express Bank', bankCode: '074914003', swiftCode: 'AECBUSNY' },
        
        // United Kingdom
        { countryCode: 'GB', bankName: 'Barclays Bank', bankCode: '20-00-00', swiftCode: 'BARCGB22' },
        { countryCode: 'GB', bankName: 'HSBC Bank', bankCode: '40-05-15', swiftCode: 'HBUKGB4B' },
        { countryCode: 'GB', bankName: 'Lloyds Bank', bankCode: '30-00-02', swiftCode: 'LOYDGB21' },
        { countryCode: 'GB', bankName: 'NatWest Bank', bankCode: '60-00-01', swiftCode: 'NWBKGB2L' },
        { countryCode: 'GB', bankName: 'Santander UK', bankCode: '09-01-26', swiftCode: 'ABBYGB2L' },
        { countryCode: 'GB', bankName: 'Halifax', bankCode: '11-01-01', swiftCode: 'HLFXGB21' },
        { countryCode: 'GB', bankName: 'TSB Bank', bankCode: '77-71-99', swiftCode: 'TSBUS44' },
        { countryCode: 'GB', bankName: 'Monzo Bank', bankCode: '04-00-04', swiftCode: 'MONZGB2L' },
        { countryCode: 'GB', bankName: 'Starling Bank', bankCode: '60-83-71', swiftCode: 'SRLGGB2L' },
        
        // Canada
        { countryCode: 'CA', bankName: 'Royal Bank of Canada', bankCode: '003', swiftCode: 'ROYCCAT2' },
        { countryCode: 'CA', bankName: 'Toronto-Dominion Bank', bankCode: '004', swiftCode: 'TDOMCATTTOR' },
        { countryCode: 'CA', bankName: 'Bank of Nova Scotia', bankCode: '002', swiftCode: 'NOSCCATT' },
        { countryCode: 'CA', bankName: 'Bank of Montreal', bankCode: '001', swiftCode: 'BOFMCAM2' },
        { countryCode: 'CA', bankName: 'Canadian Imperial Bank of Commerce', bankCode: '010', swiftCode: 'CIBCCATT' },
        { countryCode: 'CA', bankName: 'National Bank of Canada', bankCode: '006', swiftCode: 'BNDCCAMMINT' },
        { countryCode: 'CA', bankName: 'Canadian Western Bank', bankCode: '030', swiftCode: 'CWBKCATT' },
        
        // Australia
        { countryCode: 'AU', bankName: 'Commonwealth Bank of Australia', bankCode: '062-000', swiftCode: 'CTBAAU2S' },
        { countryCode: 'AU', bankName: 'Australia and New Zealand Banking Group', bankCode: '013-006', swiftCode: 'ANZBAU3M' },
        { countryCode: 'AU', bankName: 'Westpac Banking Corporation', bankCode: '732-001', swiftCode: 'WPACAU2S' },
        { countryCode: 'AU', bankName: 'National Australia Bank', bankCode: '083-004', swiftCode: 'NATAAU33' },
        { countryCode: 'AU', bankName: 'Bendigo Bank', bankCode: '633-000', swiftCode: 'BENDAU3B' },
        { countryCode: 'AU', bankName: 'Bank of Queensland', bankCode: '124-001', swiftCode: 'BOQLAU4B' },
        
        // Germany
        { countryCode: 'DE', bankName: 'Deutsche Bank', bankCode: '10070000', swiftCode: 'DEUTDEFF' },
        { countryCode: 'DE', bankName: 'Commerzbank', bankCode: '76040061', swiftCode: 'COBADEFF' },
        { countryCode: 'DE', bankName: 'UniCredit Bank', bankCode: '70020270', swiftCode: 'HYVEDEMMXXX' },
        { countryCode: 'DE', bankName: 'DZ Bank', bankCode: '50060400', swiftCode: 'GENODEFF' },
        { countryCode: 'DE', bankName: 'KfW', bankCode: '50120383', swiftCode: 'KFWIDEFF' },
        { countryCode: 'DE', bankName: 'Sparkasse', bankCode: '50050222', swiftCode: 'HELADEF1' },
        
        // France
        { countryCode: 'FR', bankName: 'BNP Paribas', bankCode: '30004', swiftCode: 'BNPAFRPP' },
        { countryCode: 'FR', bankName: 'CrÃ©dit Agricole', bankCode: '31589', swiftCode: 'AGRIFRPP' },
        { countryCode: 'FR', bankName: 'SociÃ©tÃ© GÃ©nÃ©rale', bankCode: '30003', swiftCode: 'SOGEFRPP' },
        { countryCode: 'FR', bankName: 'CrÃ©dit Lyonnais', bankCode: '30002', swiftCode: 'LYONFRPP' },
        { countryCode: 'FR', bankName: 'Banque Populaire', bankCode: '10707', swiftCode: 'CCBPFRPPSTR' },
        { countryCode: 'FR', bankName: 'Caisse d\'Epargne', bankCode: '10751', swiftCode: 'CEPAFRPP751' },
        
        // Spain
        { countryCode: 'ES', bankName: 'Banco Santander', bankCode: '0049', swiftCode: 'BSCHESMMXXX' },
        { countryCode: 'ES', bankName: 'BBVA', bankCode: '0182', swiftCode: 'BBVAESMM' },
        { countryCode: 'ES', bankName: 'CaixaBank', bankCode: '2100', swiftCode: 'CAIXESBBXXX' },
        { countryCode: 'ES', bankName: 'Banco Sabadell', bankCode: '0081', swiftCode: 'BSABESBB' },
        { countryCode: 'ES', bankName: 'Bankinter', bankCode: '0128', swiftCode: 'BKBKESMMXXX' },
        
        // Italy
        { countryCode: 'IT', bankName: 'Intesa Sanpaolo', bankCode: '03069', swiftCode: 'BCITITMM' },
        { countryCode: 'IT', bankName: 'UniCredit', bankCode: '02008', swiftCode: 'UNCRITMM' },
        { countryCode: 'IT', bankName: 'Banco BPM', bankCode: '05034', swiftCode: 'BAPPIT21' },
        { countryCode: 'IT', bankName: 'Monte dei Paschi di Siena', bankCode: '01030', swiftCode: 'PASCITM1' },
        { countryCode: 'IT', bankName: 'Mediobanca', bankCode: '03062', swiftCode: 'MEDBITMMXXX' },
        
        // Netherlands
        { countryCode: 'NL', bankName: 'ING Bank', bankCode: 'INGB', swiftCode: 'INGBNL2A' },
        { countryCode: 'NL', bankName: 'Rabobank', bankCode: 'RABO', swiftCode: 'RABONL2U' },
        { countryCode: 'NL', bankName: 'ABN AMRO Bank', bankCode: 'ABNA', swiftCode: 'ABNANL2A' },
        { countryCode: 'NL', bankName: 'de Volksbank', bankCode: 'ASNB', swiftCode: 'ASNBNL21' },
        { countryCode: 'NL', bankName: 'Triodos Bank', bankCode: 'TRIO', swiftCode: 'TRIONL2U' },
        
        // Switzerland
        { countryCode: 'CH', bankName: 'UBS', bankCode: '273', swiftCode: 'UBSWCHZH80A' },
        { countryCode: 'CH', bankName: 'Credit Suisse', bankCode: '4835', swiftCode: 'CRESCHZZ80A' },
        { countryCode: 'CH', bankName: 'PostFinance', bankCode: '09000', swiftCode: 'POFICHBEXXX' },
        { countryCode: 'CH', bankName: 'Raiffeisen', bankCode: '80808', swiftCode: 'RAIFCH22' },
        { countryCode: 'CH', bankName: 'ZÃ¼rcher Kantonalbank', bankCode: '700', swiftCode: 'ZKBKCHZZ80A' },
        
        // Japan
        { countryCode: 'JP', bankName: 'Mitsubishi UFJ Financial Group', bankCode: '0005', swiftCode: 'BOTKJPJT' },
        { countryCode: 'JP', bankName: 'Sumitomo Mitsui Banking Corporation', bankCode: '0009', swiftCode: 'SMBCJPJT' },
        { countryCode: 'JP', bankName: 'Mizuho Bank', bankCode: '0001', swiftCode: 'MHBKJPJT' },
        { countryCode: 'JP', bankName: 'Japan Post Bank', bankCode: '9900', swiftCode: 'JPPSJPJ1' },
        { countryCode: 'JP', bankName: 'Resona Bank', bankCode: '0010', swiftCode: 'DIWAJPJT' },
        { countryCode: 'JP', bankName: 'Sumitomo Mitsui Trust Bank', bankCode: '0294', swiftCode: 'SMTCJPJT' },
        
        // China
        { countryCode: 'CN', bankName: 'Industrial and Commercial Bank of China', bankCode: '102100099996', swiftCode: 'ICBKCNBJ' },
        { countryCode: 'CN', bankName: 'China Construction Bank', bankCode: '105100000017', swiftCode: 'PCBCCNBJ' },
        { countryCode: 'CN', bankName: 'Agricultural Bank of China', bankCode: '103100000026', swiftCode: 'ABOCCNBJ' },
        { countryCode: 'CN', bankName: 'Bank of China', bankCode: '104100000004', swiftCode: 'BKCHCNBJ' },
        { countryCode: 'CN', bankName: 'China Merchants Bank', bankCode: '308584000013', swiftCode: 'CMBCCNBS' },
        { countryCode: 'CN', bankName: 'China Minsheng Bank', bankCode: '305100000013', swiftCode: 'MSBCCNBJ' },
        
        // India
        { countryCode: 'IN', bankName: 'State Bank of India', bankCode: 'SBIN0000001', swiftCode: 'SBININBB' },
        { countryCode: 'IN', bankName: 'HDFC Bank', bankCode: 'HDFC0000001', swiftCode: 'HDFCINBB' },
        { countryCode: 'IN', bankName: 'ICICI Bank', bankCode: 'ICIC0000001', swiftCode: 'ICICINBB' },
        { countryCode: 'IN', bankName: 'Axis Bank', bankCode: 'UTIB0000001', swiftCode: 'AXISINBB' },
        { countryCode: 'IN', bankName: 'Kotak Mahindra Bank', bankCode: 'KKBK0000001', swiftCode: 'KKBKINBB' },
        { countryCode: 'IN', bankName: 'Punjab National Bank', bankCode: 'PUNB0000001', swiftCode: 'PUNBINBB' },
        { countryCode: 'IN', bankName: 'Bank of Baroda', bankCode: 'BARB0000001', swiftCode: 'BARBINBB' },
        { countryCode: 'IN', bankName: 'Union Bank of India', bankCode: 'UBIN0000001', swiftCode: 'UBININBB' },
        
        // Brazil
        { countryCode: 'BR', bankName: 'Banco do Brasil', bankCode: '001', swiftCode: 'BRASBRRJ' },
        { countryCode: 'BR', bankName: 'ItaÃº Unibanco', bankCode: '341', swiftCode: 'ITAUBRSP' },
        { countryCode: 'BR', bankName: 'Bradesco', bankCode: '237', swiftCode: 'BBDEBRSP' },
        { countryCode: 'BR', bankName: 'Caixa EconÃ´mica Federal', bankCode: '104', swiftCode: 'CEFXBRSP' },
        { countryCode: 'BR', bankName: 'Santander Brasil', bankCode: '033', swiftCode: 'BSCHBRSP' },
        { countryCode: 'BR', bankName: 'BTG Pactual', bankCode: '208', swiftCode: 'BTGPBRSP' },
        
        // Mexico
        { countryCode: 'MX', bankName: 'BBVA Mexico', bankCode: '012180002', swiftCode: 'BCMRMXMM' },
        { countryCode: 'MX', bankName: 'Santander Mexico', bankCode: '014180001', swiftCode: 'BMSXMXMM' },
        { countryCode: 'MX', bankName: 'Citibanamex', bankCode: '002180002', swiftCode: 'BNMXMXMM' },
        { countryCode: 'MX', bankName: 'Banorte', bankCode: '072180001', swiftCode: 'MENOMXMT' },
        { countryCode: 'MX', bankName: 'HSBC Mexico', bankCode: '021180001', swiftCode: 'BIMXMXMM' },
        
        // Argentina
        { countryCode: 'AR', bankName: 'Banco de la NaciÃ³n Argentina', bankCode: '011', swiftCode: 'NACNAR01' },
        { countryCode: 'AR', bankName: 'Banco Santander Rio', bankCode: '072', swiftCode: 'BSCHARBX' },
        { countryCode: 'AR', bankName: 'BBVA Argentina', bankCode: '017', swiftCode: 'BBVAARBX' },
        { countryCode: 'AR', bankName: 'Banco Macro', bankCode: '285', swiftCode: 'BMARBXAR' },
        { countryCode: 'AR', bankName: 'Banco Galicia', bankCode: '007', swiftCode: 'GABRARB1' },
        
        // South Africa
        { countryCode: 'ZA', bankName: 'Standard Bank', bankCode: '051001', swiftCode: 'SBZAZAJJ' },
        { countryCode: 'ZA', bankName: 'ABSA Bank', bankCode: '632005', swiftCode: 'ABSAZAJJ' },
        { countryCode: 'ZA', bankName: 'FirstRand Bank', bankCode: '250655', swiftCode: 'FIRNZAJJ' },
        { countryCode: 'ZA', bankName: 'Nedbank', bankCode: '198765', swiftCode: 'NEDSZAJJ' },
        { countryCode: 'ZA', bankName: 'Investec Bank', bankCode: '580105', swiftCode: 'IVESZAJJ' },
        { countryCode: 'ZA', bankName: 'Capitec Bank', bankCode: '470010', swiftCode: 'CABLZAJJ' },
        
        // Nigeria
        { countryCode: 'NG', bankName: 'First Bank of Nigeria', bankCode: '011', swiftCode: 'FBNINGLA' },
        { countryCode: 'NG', bankName: 'United Bank for Africa', bankCode: '033', swiftCode: 'UNAFNGLA' },
        { countryCode: 'NG', bankName: 'Access Bank', bankCode: '044', swiftCode: 'ABNGNGLA' },
        { countryCode: 'NG', bankName: 'Zenith Bank', bankCode: '057', swiftCode: 'ZEIBNGLA' },
        { countryCode: 'NG', bankName: 'Guaranty Trust Bank', bankCode: '058', swiftCode: 'GTBINGLA' },
        { countryCode: 'NG', bankName: 'Fidelity Bank', bankCode: '070', swiftCode: 'FIDTNGLA' },
        { countryCode: 'NG', bankName: 'Ecobank Nigeria', bankCode: '050', swiftCode: 'ECOCNGLA' },
        
        // Kenya
        { countryCode: 'KE', bankName: 'Kenya Commercial Bank', bankCode: '01', swiftCode: 'KCBLKENX' },
        { countryCode: 'KE', bankName: 'Equity Bank', bankCode: '68', swiftCode: 'EQBLKENA' },
        { countryCode: 'KE', bankName: 'Standard Chartered Bank Kenya', bankCode: '02', swiftCode: 'SCBLKENX' },
        { countryCode: 'KE', bankName: 'Cooperative Bank of Kenya', bankCode: '11', swiftCode: 'KCOOKENA' },
        { countryCode: 'KE', bankName: 'Barclays Bank Kenya', bankCode: '03', swiftCode: 'BARCKENX' },
        { countryCode: 'KE', bankName: 'NCBA Bank', bankCode: '07', swiftCode: 'CBAFKENX' },
        
        // Egypt
        { countryCode: 'EG', bankName: 'National Bank of Egypt', bankCode: '003', swiftCode: 'NBEGEGCX' },
        { countryCode: 'EG', bankName: 'Banque Misr', bankCode: '002', swiftCode: 'BMISEGCX' },
        { countryCode: 'EG', bankName: 'Commercial International Bank', bankCode: '030', swiftCode: 'CIBEEGCX' },
        { countryCode: 'EG', bankName: 'QNB ALAHLI', bankCode: '200', swiftCode: 'QNBAEGCX' },
        { countryCode: 'EG', bankName: 'HSBC Bank Egypt', bankCode: '135', swiftCode: 'HBUKEGCX' },
        
        // Morocco
        { countryCode: 'MA', bankName: 'Attijariwafa Bank', bankCode: '007', swiftCode: 'BCMAMAMC' },
        { countryCode: 'MA', bankName: 'Banque Populaire', bankCode: '025', swiftCode: 'BMCEMAMC' },
        { countryCode: 'MA', bankName: 'BMCE Bank', bankCode: '011', swiftCode: 'BMCEMAMC' },
        { countryCode: 'MA', bankName: 'CrÃ©dit du Maroc', bankCode: '175', swiftCode: 'CDMAMAMC' },
        { countryCode: 'MA', bankName: 'SociÃ©tÃ© GÃ©nÃ©rale Maroc', bankCode: '020', swiftCode: 'SOGEMAMCXXX' },
        
        // Ghana
        { countryCode: 'GH', bankName: 'Ghana Commercial Bank', bankCode: 'GCB', swiftCode: 'GHCBGHAC' },
        { countryCode: 'GH', bankName: 'Ecobank Ghana', bankCode: 'EBG', swiftCode: 'ECOCGHAC' },
        { countryCode: 'GH', bankName: 'Standard Chartered Bank Ghana', bankCode: 'SCB', swiftCode: 'SCBLGHAC' },
        { countryCode: 'GH', bankName: 'Barclays Bank Ghana', bankCode: 'BBG', swiftCode: 'BARCGHAC' },
        { countryCode: 'GH', bankName: 'Fidelity Bank Ghana', bankCode: 'FBL', swiftCode: 'FIDTGHAC' },
        
        // Zimbabwe  
        { countryCode: 'ZW', bankName: 'CBZ Bank', bankCode: 'CBZ', swiftCode: 'CBZWZWHA' },
        { countryCode: 'ZW', bankName: 'Stanbic Bank Zimbabwe', bankCode: 'STANBIC', swiftCode: 'SBICZWHA' },
        { countryCode: 'ZW', bankName: 'Standard Chartered Bank Zimbabwe', bankCode: 'STANCHART', swiftCode: 'SCBLZWHA' },
        { countryCode: 'ZW', bankName: 'FBC Bank', bankCode: 'FBC', swiftCode: 'FBCBZWHA' },
        { countryCode: 'ZW', bankName: 'CABS', bankCode: 'CABS', swiftCode: 'CABSZWHA' },
        
        // Singapore
        { countryCode: 'SG', bankName: 'DBS Bank', bankCode: '7171', swiftCode: 'DBSSSGSG' },
        { countryCode: 'SG', bankName: 'OCBC Bank', bankCode: '7339', swiftCode: 'OCBCSGSG' },
        { countryCode: 'SG', bankName: 'United Overseas Bank', bankCode: '7375', swiftCode: 'UOVBSGSG' },
        { countryCode: 'SG', bankName: 'Citibank Singapore', bankCode: '7214', swiftCode: 'CITISGSGGLO' },
        { countryCode: 'SG', bankName: 'Standard Chartered Singapore', bankCode: '7144', swiftCode: 'SCBLSGSG' },
        
        // Malaysia
        { countryCode: 'MY', bankName: 'Maybank', bankCode: 'MBB', swiftCode: 'MBBEMYKL' },
        { countryCode: 'MY', bankName: 'CIMB Bank', bankCode: 'CIMB', swiftCode: 'CIBBMYKL' },
        { countryCode: 'MY', bankName: 'Public Bank', bankCode: 'PBB', swiftCode: 'PBBEMYKL' },
        { countryCode: 'MY', bankName: 'RHB Bank', bankCode: 'RHB', swiftCode: 'RHBBMYKL' },
        { countryCode: 'MY', bankName: 'Hong Leong Bank', bankCode: 'HLB', swiftCode: 'HLBBMYKL' },
        
        // Thailand
        { countryCode: 'TH', bankName: 'Bangkok Bank', bankCode: '002', swiftCode: 'BKKBTHBK' },
        { countryCode: 'TH', bankName: 'Kasikornbank', bankCode: '004', swiftCode: 'KASITHBK' },
        { countryCode: 'TH', bankName: 'Krung Thai Bank', bankCode: '006', swiftCode: 'KRTHTHBK' },
        { countryCode: 'TH', bankName: 'Siam Commercial Bank', bankCode: '014', swiftCode: 'SICOTHBK' },
        { countryCode: 'TH', bankName: 'Bank of Ayudhya', bankCode: '025', swiftCode: 'AYUDTHBK' },
        
        // Indonesia
        { countryCode: 'ID', bankName: 'Bank Mandiri', bankCode: '008', swiftCode: 'BMRIIDJA' },
        { countryCode: 'ID', bankName: 'Bank Central Asia', bankCode: '014', swiftCode: 'CENAIDJA' },
        { countryCode: 'ID', bankName: 'Bank Rakyat Indonesia', bankCode: '002', swiftCode: 'BRINIDJA' },
        { countryCode: 'ID', bankName: 'Bank Negara Indonesia', bankCode: '009', swiftCode: 'BNINIDJA' },
        { countryCode: 'ID', bankName: 'CIMB Niaga', bankCode: '022', swiftCode: 'BNIAIDJA' },
        
        // Philippines
        { countryCode: 'PH', bankName: 'Banco de Oro', bankCode: 'BDO', swiftCode: 'BNORPHMM' },
        { countryCode: 'PH', bankName: 'Metropolitan Bank', bankCode: 'MBT', swiftCode: 'MBTCPHMM' },
        { countryCode: 'PH', bankName: 'Bank of the Philippine Islands', bankCode: 'BPI', swiftCode: 'BOPIPHMM' },
        { countryCode: 'PH', bankName: 'Land Bank of the Philippines', bankCode: 'LBP', swiftCode: 'TLBPPHMM' },
        { countryCode: 'PH', bankName: 'Philippine National Bank', bankCode: 'PNB', swiftCode: 'PNBMPHMM' },
        
        // Vietnam
        { countryCode: 'VN', bankName: 'Vietcombank', bankCode: '970436', swiftCode: 'BFTVVNVX' },
        { countryCode: 'VN', bankName: 'BIDV', bankCode: '970418', swiftCode: 'BIDVVNVX' },
        { countryCode: 'VN', bankName: 'VietinBank', bankCode: '970415', swiftCode: 'ICBVVNVX' },
        { countryCode: 'VN', bankName: 'Agribank', bankCode: '970405', swiftCode: 'VBAAVNVX' },
        { countryCode: 'VN', bankName: 'Techcombank', bankCode: '970407', swiftCode: 'VTCBVNVX' },
        
        // Europe - Additional Countries
        // Belgium
        { countryCode: 'BE', bankName: 'KBC Bank', bankCode: 'KBC', swiftCode: 'KREDBEBB' },
        { countryCode: 'BE', bankName: 'Belfius Bank', bankCode: 'BELFIUS', swiftCode: 'GKCCBEBB' },
        { countryCode: 'BE', bankName: 'ING Belgium', bankCode: 'ING', swiftCode: 'BBRUBEBB' },
        
        // Austria
        { countryCode: 'AT', bankName: 'Erste Bank', bankCode: '20111', swiftCode: 'GIBAATWW' },
        { countryCode: 'AT', bankName: 'Bank Austria', bankCode: '12000', swiftCode: 'BKAUATWW' },
        { countryCode: 'AT', bankName: 'Raiffeisen Bank', bankCode: '31000', swiftCode: 'RLNWATWW' },
        
        // Portugal
        { countryCode: 'PT', bankName: 'Banco Santander Portugal', bankCode: '0007', swiftCode: 'BSCHPTPL' },
        { countryCode: 'PT', bankName: 'Caixa Geral de DepÃ³sitos', bankCode: '0035', swiftCode: 'CGDIPTPL' },
        { countryCode: 'PT', bankName: 'Millennium BCP', bankCode: '0033', swiftCode: 'BCOMPTPL' },
        
        // Ireland
        { countryCode: 'IE', bankName: 'Bank of Ireland', bankCode: 'BOI', swiftCode: 'BOFIIE2D' },
        { countryCode: 'IE', bankName: 'AIB Bank', bankCode: 'AIB', swiftCode: 'AIBKIE2D' },
        { countryCode: 'IE', bankName: 'Ulster Bank Ireland', bankCode: 'UBI', swiftCode: 'ULSBIE2D' },
        
        // Poland
        { countryCode: 'PL', bankName: 'PKO Bank Polski', bankCode: '10201023', swiftCode: 'BPKOPLPW' },
        { countryCode: 'PL', bankName: 'Bank Pekao', bankCode: '12401020', swiftCode: 'PKOPPLPW' },
        { countryCode: 'PL', bankName: 'Santander Bank Polska', bankCode: '10901023', swiftCode: 'WBKPPLPP' },
        
        // Czech Republic
        { countryCode: 'CZ', bankName: 'ÄŒeskÃ¡ spoÅ™itelna', bankCode: '0800', swiftCode: 'GIBACZPX' },
        { countryCode: 'CZ', bankName: 'KomerÄnÃ­ banka', bankCode: '0100', swiftCode: 'KOMBCZPP' },
        { countryCode: 'CZ', bankName: 'ÄŒSOB Bank', bankCode: '0300', swiftCode: 'CEKOCZPP' },
        
        // Hungary
        { countryCode: 'HU', bankName: 'OTP Bank', bankCode: '11700024', swiftCode: 'OTPVHUHB' },
        { countryCode: 'HU', bankName: 'K&H Bank', bankCode: '10401007', swiftCode: 'OKHBHUHB' },
        { countryCode: 'HU', bankName: 'Erste Bank Hungary', bankCode: '11600006', swiftCode: 'GIBAHUHB' },
        
        // Romania
        { countryCode: 'RO', bankName: 'BCR Bank', bankCode: 'RNCB', swiftCode: 'RNCBROBU' },
        { countryCode: 'RO', bankName: 'BRD SociÃ©tÃ© GÃ©nÃ©rale', bankCode: 'BRDE', swiftCode: 'BRDEROBU' },
        { countryCode: 'RO', bankName: 'ING Bank Romania', bankCode: 'INGB', swiftCode: 'INGBROBU' },
        
        // Bulgaria
        { countryCode: 'BG', bankName: 'UniCredit Bulgaria', bankCode: 'UNCR', swiftCode: 'UNCRBGSF' },
        { countryCode: 'BG', bankName: 'DSK Bank', bankCode: 'DSK', swiftCode: 'BDSBBGSF' },
        { countryCode: 'BG', bankName: 'First Investment Bank', bankCode: 'FINV', swiftCode: 'FINVBGSF' },
        
        // Croatia
        { countryCode: 'HR', bankName: 'ZagrebaÄka banka', bankCode: '2360000', swiftCode: 'ZABAHR2X' },
        { countryCode: 'HR', bankName: 'Privredna banka Zagreb', bankCode: '2340009', swiftCode: 'PBZGHR2X' },
        { countryCode: 'HR', bankName: 'Erste Bank Croatia', bankCode: '2402008', swiftCode: 'ESBCHR22' },
        
        // Serbia
        { countryCode: 'RS', bankName: 'Komercijalna banka', bankCode: '205', swiftCode: 'KOBBRSBG' },
        { countryCode: 'RS', bankName: 'Banca Intesa', bankCode: '160', swiftCode: 'DBDBRSBG' },
        { countryCode: 'RS', bankName: 'Raiffeisen banka', bankCode: '265', swiftCode: 'RZBSRSBG' },
        
        // Nordic Countries
        // Sweden
        { countryCode: 'SE', bankName: 'Swedbank', bankCode: '8000', swiftCode: 'SWEDSESS' },
        { countryCode: 'SE', bankName: 'Handelsbanken', bankCode: '6000', swiftCode: 'HANDSESS' },
        { countryCode: 'SE', bankName: 'SEB Bank', bankCode: '5000', swiftCode: 'ESSESESS' },
        
        // Norway
        { countryCode: 'NO', bankName: 'DNB Bank', bankCode: '0200', swiftCode: 'DNBANOKKXXX' },
        { countryCode: 'NO', bankName: 'Nordea Bank Norge', bankCode: '6000', swiftCode: 'NDEANOKKXXX' },
        { countryCode: 'NO', bankName: 'Sparebank 1', bankCode: '8200', swiftCode: 'SPRONO22XXX' },
        
        // Denmark
        { countryCode: 'DK', bankName: 'Danske Bank', bankCode: '3000', swiftCode: 'DABADKKK' },
        { countryCode: 'DK', bankName: 'Nordea Denmark', bankCode: '2000', swiftCode: 'NDEADKKK' },
        { countryCode: 'DK', bankName: 'Jyske Bank', bankCode: '7000', swiftCode: 'JYBADKKK' },
        
        // Finland
        { countryCode: 'FI', bankName: 'Nordea Bank Finland', bankCode: '166030', swiftCode: 'NDEAFIHH' },
        { countryCode: 'FI', bankName: 'OP Corporate Bank', bankCode: '500000', swiftCode: 'OKOYFIHH' },
        { countryCode: 'FI', bankName: 'Danske Bank Finland', bankCode: '800000', swiftCode: 'DABAFIHH' },
        
        // Iceland
        { countryCode: 'IS', bankName: 'Landsbankinn', bankCode: '0111', swiftCode: 'NBIIISRE' },
        { countryCode: 'IS', bankName: 'Arion Bank', bankCode: '0116', swiftCode: 'KAUPIS22' },
        { countryCode: 'IS', bankName: 'Ãslandsbanki', bankCode: '0113', swiftCode: 'GLITISRE' },
        
        // Middle East
        // United Arab Emirates
        { countryCode: 'AE', bankName: 'Emirates NBD', bankCode: 'ENBD', swiftCode: 'EBILAEAD' },
        { countryCode: 'AE', bankName: 'First Abu Dhabi Bank', bankCode: 'FAB', swiftCode: 'NBADAEAD' },
        { countryCode: 'AE', bankName: 'Dubai Islamic Bank', bankCode: 'DIB', swiftCode: 'DUIBAEAD' },
        { countryCode: 'AE', bankName: 'ADCB Bank', bankCode: 'ADCB', swiftCode: 'ADCBAEAD' },
        
        // Saudi Arabia
        { countryCode: 'SA', bankName: 'Al Rajhi Bank', bankCode: '80', swiftCode: 'RJHISARI' },
        { countryCode: 'SA', bankName: 'National Commercial Bank', bankCode: '10', swiftCode: 'NCBKSAJE' },
        { countryCode: 'SA', bankName: 'Riyad Bank', bankCode: '20', swiftCode: 'RIBLSARI' },
        { countryCode: 'SA', bankName: 'Saudi British Bank', bankCode: '40', swiftCode: 'SABBSARI' },
        
        // Qatar
        { countryCode: 'QA', bankName: 'Qatar National Bank', bankCode: 'QNB', swiftCode: 'QNBKQAQA' },
        { countryCode: 'QA', bankName: 'Commercial Bank of Qatar', bankCode: 'CBQ', swiftCode: 'CBQAQAQA' },
        { countryCode: 'QA', bankName: 'Doha Bank', bankCode: 'DOHA', swiftCode: 'DOHBQAQA' },
        
        // Kuwait
        { countryCode: 'KW', bankName: 'National Bank of Kuwait', bankCode: 'NBK', swiftCode: 'NBOKKWKW' },
        { countryCode: 'KW', bankName: 'Kuwait Finance House', bankCode: 'KFH', swiftCode: 'KFHOKWKW' },
        { countryCode: 'KW', bankName: 'Gulf Bank Kuwait', bankCode: 'GBK', swiftCode: 'GULBKWKW' },
        
        // Israel
        { countryCode: 'IL', bankName: 'Bank Hapoalim', bankCode: '12', swiftCode: 'POALILIT' },
        { countryCode: 'IL', bankName: 'Bank Leumi', bankCode: '10', swiftCode: 'LUMIILITTLV' },
        { countryCode: 'IL', bankName: 'Discount Bank', bankCode: '11', swiftCode: 'IDBLILITTLV' },
        
        // Turkey
        { countryCode: 'TR', bankName: 'Ä°ÅŸ BankasÄ±', bankCode: '64', swiftCode: 'ISBKTRIS' },
        { countryCode: 'TR', bankName: 'Garanti BBVA', bankCode: '62', swiftCode: 'TGBATRIS' },
        { countryCode: 'TR', bankName: 'YapÄ± Kredi BankasÄ±', bankCode: '67', swiftCode: 'YAPITRIS' },
        
        // Asia-Pacific Additional
        // South Korea
        { countryCode: 'KR', bankName: 'KB Kookmin Bank', bankCode: '004', swiftCode: 'CZNBKRSE' },
        { countryCode: 'KR', bankName: 'Shinhan Bank', bankCode: '088', swiftCode: 'SHBKKRSE' },
        { countryCode: 'KR', bankName: 'Woori Bank', bankCode: '020', swiftCode: 'HVBKKRSE' },
        
        // Taiwan
        { countryCode: 'TW', bankName: 'Bank of Taiwan', bankCode: '004', swiftCode: 'BKTWTWTP' },
        { countryCode: 'TW', bankName: 'Cathay United Bank', bankCode: '013', swiftCode: 'CDCBTWTP' },
        { countryCode: 'TW', bankName: 'Fubon Bank', bankCode: '012', swiftCode: 'TPBKTWTP' },
        
        // Hong Kong
        { countryCode: 'HK', bankName: 'HSBC Hong Kong', bankCode: '004', swiftCode: 'HSBCHKHHHKH' },
        { countryCode: 'HK', bankName: 'Bank of China Hong Kong', bankCode: '012', swiftCode: 'BKCHHKHHXXX' },
        { countryCode: 'HK', bankName: 'Standard Chartered Hong Kong', bankCode: '003', swiftCode: 'SCBLHKHHXXX' },
        
        // New Zealand
        { countryCode: 'NZ', bankName: 'ANZ Bank New Zealand', bankCode: '01', swiftCode: 'ANZBNZ22' },
        { countryCode: 'NZ', bankName: 'ASB Bank', bankCode: '12', swiftCode: 'ASBBNZ2A' },
        { countryCode: 'NZ', bankName: 'Westpac New Zealand', bankCode: '03', swiftCode: 'WPACNZ2W' },
        
        // Bangladesh
        { countryCode: 'BD', bankName: 'Sonali Bank', bankCode: '000', swiftCode: 'SONBBD2D' },
        { countryCode: 'BD', bankName: 'Rupali Bank', bankCode: '001', swiftCode: 'RUBDDHKA' },
        { countryCode: 'BD', bankName: 'Dutch-Bangla Bank', bankCode: '205', swiftCode: 'DBBLBDDHXXX' },
        
        // Sri Lanka
        { countryCode: 'LK', bankName: 'Bank of Ceylon', bankCode: '7010', swiftCode: 'BCEYLKLX' },
        { countryCode: 'LK', bankName: 'Commercial Bank of Ceylon', bankCode: '7056', swiftCode: 'CCEYLKLX' },
        { countryCode: 'LK', bankName: 'Hatton National Bank', bankCode: '7083', swiftCode: 'HBLILKLX' },
        
        // Pakistan
        { countryCode: 'PK', bankName: 'Habib Bank Limited', bankCode: '014', swiftCode: 'HABBPKKA' },
        { countryCode: 'PK', bankName: 'United Bank Limited', bankCode: '006', swiftCode: 'UNILPKKA' },
        { countryCode: 'PK', bankName: 'MCB Bank', bankCode: '003', swiftCode: 'MUCBPKKA' },
        
        // Americas Additional
        // Chile
        { countryCode: 'CL', bankName: 'Banco de Chile', bankCode: '001', swiftCode: 'BCHICLRM' },
        { countryCode: 'CL', bankName: 'Banco Santander Chile', bankCode: '037', swiftCode: 'BSCHCLRM' },
        { countryCode: 'CL', bankName: 'BCI Bank', bankCode: '016', swiftCode: 'CREDCLRM' },
        
        // Colombia
        { countryCode: 'CO', bankName: 'Bancolombia', bankCode: '007', swiftCode: 'COLOCOBM' },
        { countryCode: 'CO', bankName: 'Banco de BogotÃ¡', bankCode: '001', swiftCode: 'BBOPCOBM' },
        { countryCode: 'CO', bankName: 'Davivienda', bankCode: '051', swiftCode: 'DAVICOBM' },
        
        // Peru
        { countryCode: 'PE', bankName: 'Banco de CrÃ©dito del PerÃº', bankCode: '002', swiftCode: 'BCPLPEPL' },
        { countryCode: 'PE', bankName: 'BBVA Continental', bankCode: '011', swiftCode: 'BCONPEPL' },
        { countryCode: 'PE', bankName: 'Scotiabank PerÃº', bankCode: '009', swiftCode: 'BSUDPEPL' },
        
        // Uruguay
        { countryCode: 'UY', bankName: 'Banco RepÃºblica', bankCode: '001', swiftCode: 'BROUUYMM' },
        { countryCode: 'UY', bankName: 'Banco Santander Uruguay', bankCode: '137', swiftCode: 'BSCHUYMMXXX' },
        { countryCode: 'UY', bankName: 'ItaÃº Uruguay', bankCode: '113', swiftCode: 'ITAUUYMMXXX' },
        
        // Ecuador
        { countryCode: 'EC', bankName: 'Banco Pichincha', bankCode: '001', swiftCode: 'PICHECEQ' },
        { countryCode: 'EC', bankName: 'Banco del PacÃ­fico', bankCode: '016', swiftCode: 'BPACECEQ' },
        { countryCode: 'EC', bankName: 'Produbanco', bankCode: '043', swiftCode: 'PRODECEQ' },
        
        // Venezuela
        { countryCode: 'VE', bankName: 'Banco de Venezuela', bankCode: '0102', swiftCode: 'BANVVECA' },
        { countryCode: 'VE', bankName: 'Mercantil Bank', bankCode: '0105', swiftCode: 'BAVEVECA' },
        { countryCode: 'VE', bankName: 'Banesco Bank', bankCode: '0134', swiftCode: 'BANEVECA' },
        
        // Africa Additional
        // Tunisia
        { countryCode: 'TN', bankName: 'SociÃ©tÃ© Tunisienne de Banque', bankCode: '008', swiftCode: 'STBKTNTT' },
        { countryCode: 'TN', bankName: 'Banque Nationale Agricole', bankCode: '004', swiftCode: 'BNATTNTT' },
        { countryCode: 'TN', bankName: 'Attijari Bank', bankCode: '020', swiftCode: 'BCMZTNTT' },
        
        // Algeria
        { countryCode: 'DZ', bankName: 'Banque Nationale d\'AlgÃ©rie', bankCode: '001', swiftCode: 'BNADDZAL' },
        { countryCode: 'DZ', bankName: 'CrÃ©dit Populaire d\'AlgÃ©rie', bankCode: '002', swiftCode: 'CPALDZAL' },
        { countryCode: 'DZ', bankName: 'Banque ExtÃ©rieure d\'AlgÃ©rie', bankCode: '003', swiftCode: 'BEALDZAL' },
        
        // Ethiopia
        { countryCode: 'ET', bankName: 'Commercial Bank of Ethiopia', bankCode: '001', swiftCode: 'CBETETAA' },
        { countryCode: 'ET', bankName: 'Dashen Bank', bankCode: '014', swiftCode: 'DASHETAA' },
        { countryCode: 'ET', bankName: 'Bank of Abyssinia', bankCode: '019', swiftCode: 'ABYSETAA' },
        
        // Tanzania
        { countryCode: 'TZ', bankName: 'CRDB Bank', bankCode: '154', swiftCode: 'CORUTZTZ' },
        { countryCode: 'TZ', bankName: 'NBC Bank', bankCode: '012', swiftCode: 'NLCBTZTZ' },
        { countryCode: 'TZ', bankName: 'Stanbic Bank Tanzania', bankCode: '040', swiftCode: 'SBICTZTZ' },
        
        // Uganda
        { countryCode: 'UG', bankName: 'Bank of Uganda', bankCode: '001', swiftCode: 'BOUGUNKA' },
        { countryCode: 'UG', bankName: 'Centenary Bank', bankCode: '320', swiftCode: 'CNTYUGKA' },
        { countryCode: 'UG', bankName: 'Stanbic Bank Uganda', bankCode: '224', swiftCode: 'SBICUGKA' },
        
        // Botswana
        { countryCode: 'BW', bankName: 'First National Bank Botswana', bankCode: '282', swiftCode: 'FIRNBWGX' },
        { countryCode: 'BW', bankName: 'Standard Chartered Bank Botswana', bankCode: '010', swiftCode: 'SCBLBWGX' },
        { countryCode: 'BW', bankName: 'Barclays Bank Botswana', bankCode: '030', swiftCode: 'BARCBWGX' },
        
        // Zambia
        { countryCode: 'ZM', bankName: 'Zanaco Bank', bankCode: '010330', swiftCode: 'ZANCZM22' },
        { countryCode: 'ZM', bankName: 'Stanbic Bank Zambia', bankCode: '040003', swiftCode: 'SBICZM22' },
        { countryCode: 'ZM', bankName: 'First Capital Bank', bankCode: '350001', swiftCode: 'FCBLZM22' },
        
        // Namibia
        { countryCode: 'NA', bankName: 'Bank Windhoek', bankCode: '483312', swiftCode: 'BWLINANX' },
        { countryCode: 'NA', bankName: 'First National Bank Namibia', bankCode: '281479', swiftCode: 'FIRNNANX' },
        { countryCode: 'NA', bankName: 'Standard Bank Namibia', bankCode: '087373', swiftCode: 'SBNMNANX' },
        
        // Mozambique
        { countryCode: 'MZ', bankName: 'Millennium BIM', bankCode: '008', swiftCode: 'BMOCMZMZ' },
        { countryCode: 'MZ', bankName: 'Standard Bank Mozambique', bankCode: '012', swiftCode: 'SBICMZMZ' },
        { countryCode: 'MZ', bankName: 'Barclays Mozambique', bankCode: '013', swiftCode: 'BARCMZMZ' },
        
        // Additional Asian Countries
        // Cambodia
        { countryCode: 'KH', bankName: 'ACLEDA Bank', bankCode: '001', swiftCode: 'ACLBKHHH' },
        { countryCode: 'KH', bankName: 'Canadia Bank', bankCode: '009', swiftCode: 'CADIKHHH' },
        { countryCode: 'KH', bankName: 'ANZ Royal Bank', bankCode: '020', swiftCode: 'ANZBKHPP' },
        
        // Laos
        { countryCode: 'LA', bankName: 'Banque pour le Commerce ExtÃ©rieur Lao', bankCode: '001', swiftCode: 'BCELLAOB' },
        { countryCode: 'LA', bankName: 'Lao Development Bank', bankCode: '003', swiftCode: 'LDBLLAOB' },
        { countryCode: 'LA', bankName: 'Joint Development Bank', bankCode: '004', swiftCode: 'JDBLLAOB' },
        
        // Myanmar
        { countryCode: 'MM', bankName: 'Myanmar Apex Bank', bankCode: '001', swiftCode: 'MABJMM2X' },
        { countryCode: 'MM', bankName: 'Kanbawza Bank', bankCode: '029', swiftCode: 'KBZAMM2X' },
        { countryCode: 'MM', bankName: 'CB Bank', bankCode: '035', swiftCode: 'CBCOMM2X' },
        
        // Pacific Islands
        // Fiji
        { countryCode: 'FJ', bankName: 'ANZ Bank Fiji', bankCode: '01', swiftCode: 'ANZBNZ22FJ' },
        { countryCode: 'FJ', bankName: 'Westpac Bank Fiji', bankCode: '03', swiftCode: 'WPACFJFJ' },
        { countryCode: 'FJ', bankName: 'Bank of South Pacific', bankCode: '05', swiftCode: 'BSPFFJFJ' },
        
        // Caribbean
        // Jamaica
        { countryCode: 'JM', bankName: 'Bank of Jamaica', bankCode: '001', swiftCode: 'BOJAâ€‹JMKGXXX' },
        { countryCode: 'JM', bankName: 'National Commercial Bank', bankCode: '002', swiftCode: 'JNCBJMKGXXX' },
        { countryCode: 'JM', bankName: 'Scotiabank Jamaica', bankCode: '004', swiftCode: 'NOSCJMKGXXX' },
        
        // Trinidad and Tobago
        { countryCode: 'TT', bankName: 'Republic Bank Trinidad', bankCode: '047', swiftCode: 'RBTTTT22XXX' },
        { countryCode: 'TT', bankName: 'First Citizens Bank', bankCode: '023', swiftCode: 'FCIBTTPS' },
        { countryCode: 'TT', bankName: 'Scotiabank Trinidad', bankCode: '045', swiftCode: 'NOSCTTTP' },
        
        // Additional European Countries
        // Luxembourg
        { countryCode: 'LU', bankName: 'Banque et Caisse d\'Epargne de l\'Etat', bankCode: '1111', swiftCode: 'BCEELULL' },
        { countryCode: 'LU', bankName: 'Banque Internationale Ã  Luxembourg', bankCode: '0010', swiftCode: 'BILLLULL' },
        { countryCode: 'LU', bankName: 'ING Luxembourg', bankCode: '0141', swiftCode: 'CELLLULL' },
        
        // Malta
        { countryCode: 'MT', bankName: 'Bank of Valletta', bankCode: 'BOV', swiftCode: 'VALLMTMT' },
        { countryCode: 'MT', bankName: 'HSBC Bank Malta', bankCode: 'HSBC', swiftCode: 'MMEBMTMT' },
        { countryCode: 'MT', bankName: 'APS Bank', bankCode: 'APS', swiftCode: 'APSRMTMT' },
        
        // Cyprus
        { countryCode: 'CY', bankName: 'Bank of Cyprus', bankCode: 'BOC', swiftCode: 'BCYPCY2N' },
        { countryCode: 'CY', bankName: 'Hellenic Bank', bankCode: 'HB', swiftCode: 'HEBACY2N' },
        { countryCode: 'CY', bankName: 'Alpha Bank Cyprus', bankCode: 'ALPHA', swiftCode: 'ALPHCY2N' },
        
        // Additional countries to ensure comprehensive coverage
        // Russia
        { countryCode: 'RU', bankName: 'Sberbank', bankCode: '044525225', swiftCode: 'SABRRUMM' },
        { countryCode: 'RU', bankName: 'VTB Bank', bankCode: '044525187', swiftCode: 'VTBRRUMM' },
        { countryCode: 'RU', bankName: 'Gazprombank', bankCode: '044525823', swiftCode: 'GAZPRUMM' },
        
        // Ukraine
        { countryCode: 'UA', bankName: 'PrivatBank', bankCode: '305299', swiftCode: 'PBANUA2X' },
        { countryCode: 'UA', bankName: 'Oschadbank', bankCode: '300012', swiftCode: 'OSBAAU2X' },
        { countryCode: 'UA', bankName: 'Raiffeisen Bank Aval', bankCode: '380805', swiftCode: 'AVALUAUKXXX' },
        
        // Kazakhstan
        { countryCode: 'KZ', bankName: 'Kaspi Bank', bankCode: 'KSPK', swiftCode: 'CASPKZKA' },
        { countryCode: 'KZ', bankName: 'Halyk Bank', bankCode: 'HSBK', swiftCode: 'HSBKKZKA' },
        { countryCode: 'KZ', bankName: 'Forte Bank', bankCode: 'IRTB', swiftCode: 'IRTYKZKA' },
        
        // Belarus
        { countryCode: 'BY', bankName: 'Belarusbank', bankCode: '153001001', swiftCode: 'UNBYBYMM' },
        { countryCode: 'BY', bankName: 'Alfa-Bank Belarus', bankCode: '270002351', swiftCode: 'ALFABY2X' },
        { countryCode: 'BY', bankName: 'Bank Dabrabyt', bankCode: '362000102', swiftCode: 'DABRBY22' },
        
        // Georgia
        { countryCode: 'GE', bankName: 'Bank of Georgia', bankCode: 'BAGAGE22', swiftCode: 'BAGAGE22' },
        { countryCode: 'GE', bankName: 'TBC Bank', bankCode: 'TBCBGE22', swiftCode: 'TBCBGE22' },
        { countryCode: 'GE', bankName: 'VTB Bank Georgia', bankCode: 'VTBGGE22', swiftCode: 'VTBGGE22' },
        
        // Armenia
        { countryCode: 'AM', bankName: 'ACBA Bank', bankCode: '044525761', swiftCode: 'ACBAAM22' },
        { countryCode: 'AM', bankName: 'Ameriabank', bankCode: '044525777', swiftCode: 'AMERAM22' },
        { countryCode: 'AM', bankName: 'VTB Bank Armenia', bankCode: '044525666', swiftCode: 'VTBRAM22' },
        
        // Azerbaijan
        { countryCode: 'AZ', bankName: 'International Bank of Azerbaijan', bankCode: '200037', swiftCode: 'NABZAZ2X' },
        { countryCode: 'AZ', bankName: 'Kapital Bank', bankCode: '200002', swiftCode: 'AIIBAZ2X' },
        { countryCode: 'AZ', bankName: 'AccessBank Azerbaijan', bankCode: '200051', swiftCode: 'ABAZAZ22' },
        
        // Nepal
        { countryCode: 'NP', bankName: 'Nepal Rastra Bank', bankCode: '001', swiftCode: 'NRBLNPKA' },
        { countryCode: 'NP', bankName: 'Nepal Investment Bank', bankCode: '017', swiftCode: 'NIBLNPKA' },
        { countryCode: 'NP', bankName: 'Himalayan Bank', bankCode: '026', swiftCode: 'HIMANPKA' },
        
        // Uzbekistan
        { countryCode: 'UZ', bankName: 'National Bank of Uzbekistan', bankCode: '00014', swiftCode: 'NBFAUZ22' },
        { countryCode: 'UZ', bankName: 'Kapitalbank', bankCode: '00381', swiftCode: 'KAPTUZ22' },
        { countryCode: 'UZ', bankName: 'Ipoteka-Bank', bankCode: '00822', swiftCode: 'IPOAUZ22' },
        
        // Mongolia
        { countryCode: 'MN', bankName: 'Trade and Development Bank of Mongolia', bankCode: '040000', swiftCode: 'TDBMMNUB' },
        { countryCode: 'MN', bankName: 'Khan Bank', bankCode: '150000', swiftCode: 'KHANMNUB' },
        { countryCode: 'MN', bankName: 'Golomt Bank', bankCode: '140000', swiftCode: 'GLOMMNUB' },
        
        // Moldova
        { countryCode: 'MD', bankName: 'MAIB Bank', bankCode: 'MAIB', swiftCode: 'AIBMMDCHI' },
        { countryCode: 'MD', bankName: 'Moldindconbank', bankCode: 'MICB', swiftCode: 'MOLDMDCH' },
        { countryCode: 'MD', bankName: 'Victoriabank', bankCode: 'VICT', swiftCode: 'VICBMDCH' },
        
        // Bosnia and Herzegovina
        { countryCode: 'BA', bankName: 'UniCredit Bank Banja Luka', bankCode: '1610', swiftCode: 'UNCRBA22' },
        { countryCode: 'BA', bankName: 'Raiffeisen Bank BiH', bankCode: '1330', swiftCode: 'RZBABA2S' },
        { countryCode: 'BA', bankName: 'Intesa Sanpaolo Banka BiH', bankCode: '1401', swiftCode: 'BSANBABA' },
        
        // North Macedonia
        { countryCode: 'MK', bankName: 'Komercijalna Banka', bankCode: '300', swiftCode: 'KOBMMK2X' },
        { countryCode: 'MK', bankName: 'Stopanska Banka', bankCode: '200', swiftCode: 'STBAMK22' },
        { countryCode: 'MK', bankName: 'NLB Tutunska Banka', bankCode: '270', swiftCode: 'TUTNMK22' },
        
        // Albania
        { countryCode: 'AL', bankName: 'Raiffeisen Bank Albania', bankCode: '20211', swiftCode: 'SGSBALTX' },
        { countryCode: 'AL', bankName: 'Intesa Sanpaolo Bank Albania', bankCode: '21241', swiftCode: 'BSANALTX' },
        { countryCode: 'AL', bankName: 'Union Bank', bankCode: '20802', swiftCode: 'UBNKALTX' },
        
        // Montenegro
        { countryCode: 'ME', bankName: 'Podgorica Bank', bankCode: '505', swiftCode: 'PGBAME2G' },
        { countryCode: 'ME', bankName: 'NLB Montenegrobanka', bankCode: '510', swiftCode: 'NLBAME2G' },
        { countryCode: 'ME', bankName: 'Hipotekarna Banka', bankCode: '520', swiftCode: 'HIPOME2G' },
        
        // Slovakia
        { countryCode: 'SK', bankName: 'SlovenskÃ¡ sporiteÄ¾Åˆa', bankCode: '0900', swiftCode: 'GIBASKBX' },
        { countryCode: 'SK', bankName: 'VÃšB Banka', bankCode: '0200', swiftCode: 'SUBASKBX' },
        { countryCode: 'SK', bankName: 'Tatra Banka', bankCode: '1100', swiftCode: 'TATRSKBX' },
        
        // Slovenia
        { countryCode: 'SI', bankName: 'Nova Ljubljanska Banka', bankCode: '02010', swiftCode: 'LJBASI2X' },
        { countryCode: 'SI', bankName: 'Nova KBM', bankCode: '04510', swiftCode: 'KBMASI2X' },
        { countryCode: 'SI', bankName: 'Abanka', bankCode: '05100', swiftCode: 'ABANSI2X' },
        
        // Lithuania
        { countryCode: 'LT', bankName: 'SEB bankas', bankCode: '70440', swiftCode: 'CBVILT2X' },
        { countryCode: 'LT', bankName: 'Swedbank', bankCode: '73000', swiftCode: 'HABALT22' },
        { countryCode: 'LT', bankName: 'Å iauliÅ³ bankas', bankCode: '71800', swiftCode: 'CBSBLT26' },
        
        // Latvia
        { countryCode: 'LV', bankName: 'Swedbank Latvia', bankCode: 'SWED', swiftCode: 'HABALV22' },
        { countryCode: 'LV', bankName: 'SEB banka', bankCode: 'UNLAV', swiftCode: 'UNLALV2X' },
        { countryCode: 'LV', bankName: 'Citadele banka', bankCode: 'PARX', swiftCode: 'PARXLV22' },
        
        // Estonia
        { countryCode: 'EE', bankName: 'Swedbank Estonia', bankCode: '22', swiftCode: 'HABAEE2X' },
        { countryCode: 'EE', bankName: 'SEB Pank', bankCode: '10', swiftCode: 'EEUHEE2X' },
        { countryCode: 'EE', bankName: 'LHV Pank', bankCode: '77', swiftCode: 'LHVBEE22' },
        
        // Kosovo
        { countryCode: 'XK', bankName: 'Raiffeisen Bank Kosovo', bankCode: 'RBKO', swiftCode: 'RBKOXKPR' },
        { countryCode: 'XK', bankName: 'ProCredit Bank Kosovo', bankCode: 'PCBK', swiftCode: 'BPKOXKPR' },
        { countryCode: 'XK', bankName: 'TEB Bank', bankCode: 'TEBK', swiftCode: 'TESBXKPR' },
        
        // Bahrain
        { countryCode: 'BH', bankName: 'National Bank of Bahrain', bankCode: 'NBBH', swiftCode: 'NBOFBHBM' },
        { countryCode: 'BH', bankName: 'Ahli United Bank', bankCode: 'AUBH', swiftCode: 'AUBHBHBM' },
        { countryCode: 'BH', bankName: 'Gulf International Bank', bankCode: 'GIBH', swiftCode: 'GULBBHBM' },
        
        // Oman
        { countryCode: 'OM', bankName: 'Bank Muscat', bankCode: 'BMAG', swiftCode: 'BMOMOMRU' },
        { countryCode: 'OM', bankName: 'National Bank of Oman', bankCode: 'NBOM', swiftCode: 'NBOMOMRU' },
        { countryCode: 'OM', bankName: 'HSBC Bank Oman', bankCode: 'HSBC', swiftCode: 'BBMEOMMU' },
        
        // Jordan
        { countryCode: 'JO', bankName: 'Arab Bank', bankCode: 'ARAB', swiftCode: 'ARABJOAX' },
        { countryCode: 'JO', bankName: 'Bank of Jordan', bankCode: 'BOJX', swiftCode: 'BJORJOAX' },
        { countryCode: 'JO', bankName: 'Jordan Islamic Bank', bankCode: 'JISB', swiftCode: 'JIIBJOAX' },
        
        // Lebanon
        { countryCode: 'LB', bankName: 'Banque du Liban', bankCode: '001', swiftCode: 'BDLBLBBX' },
        { countryCode: 'LB', bankName: 'Bank Audi', bankCode: '056', swiftCode: 'AUDILBBX' },
        { countryCode: 'LB', bankName: 'BLOM Bank', bankCode: '006', swiftCode: 'BLOMLBBX' },
        
        // Central Asian Additional
        { countryCode: 'KG', bankName: 'RSK Bank', bankCode: '440001', swiftCode: 'RSKBKGBK' },
        { countryCode: 'KG', bankName: 'Optima Bank', bankCode: '440004', swiftCode: 'OPINKG22' },
        { countryCode: 'KG', bankName: 'Kyrgyz Investment Credit Bank', bankCode: '440009', swiftCode: 'KICBKGBK' },
        
        { countryCode: 'TJ', bankName: 'Orienbank', bankCode: '350101001', swiftCode: 'ORINTJRT' },
        { countryCode: 'TJ', bankName: 'Amonatbonk', bankCode: '350301001', swiftCode: 'AMOTTJRT' },
        { countryCode: 'TJ', bankName: 'Eskhata Bank', bankCode: '350401001', swiftCode: 'ESHTJRT' },
        
        { countryCode: 'TM', bankName: 'Vnesheconombank of Turkmenistan', bankCode: '042001', swiftCode: 'VNEBASHG' },
        { countryCode: 'TM', bankName: 'Halk Bank', bankCode: '042002', swiftCode: 'HALKASHG' },
        { countryCode: 'TM', bankName: 'Senagat Bank', bankCode: '042003', swiftCode: 'SENAASHG' },
        
        // Additional African Countries
        { countryCode: 'RW', bankName: 'Bank of Kigali', bankCode: 'BOKI', swiftCode: 'BKIGRWRW' },
        { countryCode: 'RW', bankName: 'Equity Bank Rwanda', bankCode: 'EQTY', swiftCode: 'EQBLRWRW' },
        { countryCode: 'RW', bankName: 'Cogebanque', bankCode: 'COGB', swiftCode: 'COGERW22' },
        
        { countryCode: 'MW', bankName: 'National Bank of Malawi', bankCode: '001', swiftCode: 'NATIMWMW' },
        { countryCode: 'MW', bankName: 'Standard Bank Malawi', bankCode: '003', swiftCode: 'SBICMWMW' },
        { countryCode: 'MW', bankName: 'FDH Bank', bankCode: '009', swiftCode: 'FDHLMWMW' },
        
        { countryCode: 'LS', bankName: 'Central Bank of Lesotho', bankCode: '001', swiftCode: 'CBLSLSMR' },
        { countryCode: 'LS', bankName: 'Nedbank Lesotho', bankCode: '025', swiftCode: 'NEDSLSMR' },
        { countryCode: 'LS', bankName: 'First National Bank Lesotho', bankCode: '301', swiftCode: 'FIRNLSMR' },
        
        { countryCode: 'SZ', bankName: 'Central Bank of Swaziland', bankCode: '001', swiftCode: 'CBSWSZMT' },
        { countryCode: 'SZ', bankName: 'Nedbank Swaziland', bankCode: '296', swiftCode: 'NEDSZSZMT' },
        { countryCode: 'SZ', bankName: 'First National Bank Swaziland', bankCode: '361', swiftCode: 'FIRNSZMT' },
        
        // Additional Latin American Countries
        { countryCode: 'PY', bankName: 'Banco Nacional de Fomento', bankCode: '001', swiftCode: 'BNFOPYPZ' },
        { countryCode: 'PY', bankName: 'Banco Continental', bankCode: '013', swiftCode: 'BCPYPZPZ' },
        { countryCode: 'PY', bankName: 'Banco ItaÃº Paraguay', bankCode: '017', swiftCode: 'ITAUPZPZ' },
        
        { countryCode: 'BO', bankName: 'Banco Central de Bolivia', bankCode: '001', swiftCode: 'BCBLBOCP' },
        { countryCode: 'BO', bankName: 'Banco Nacional de Bolivia', bankCode: '002', swiftCode: 'BNBOBOCP' },
        { countryCode: 'BO', bankName: 'Banco de CrÃ©dito de Bolivia', bankCode: '040', swiftCode: 'BCRBBOCP' },
        
        { countryCode: 'GY', bankName: 'Bank of Guyana', bankCode: '001', swiftCode: 'BOYAGY22' },
        { countryCode: 'GY', bankName: 'Republic Bank Guyana', bankCode: '002', swiftCode: 'RBTTGY22' },
        { countryCode: 'GY', bankName: 'Demerara Bank', bankCode: '003', swiftCode: 'DEMEGY22' },
        
        { countryCode: 'SR', bankName: 'Centrale Bank van Suriname', bankCode: '001', swiftCode: 'CBSRSRPA' },
        { countryCode: 'SR', bankName: 'Hakrinbank', bankCode: '002', swiftCode: 'HAKSRSRPA' },
        { countryCode: 'SR', bankName: 'De Surinaamsche Bank', bankCode: '003', swiftCode: 'DSBASRPA' },
        
        { countryCode: 'BZ', bankName: 'Central Bank of Belize', bankCode: '001', swiftCode: 'CBBZBZBZ' },
        { countryCode: 'BZ', bankName: 'Belize Bank', bankCode: '002', swiftCode: 'BELIBZBZ' },
        { countryCode: 'BZ', bankName: 'Heritage Bank', bankCode: '003', swiftCode: 'HERIBZBZ' },
        
        { countryCode: 'SV', bankName: 'Banco Central de Reserva', bankCode: '001', swiftCode: 'BCRESVSV' },
        { countryCode: 'SV', bankName: 'Banco AgrÃ­cola', bankCode: '103', swiftCode: 'AGRISVSV' },
        { countryCode: 'SV', bankName: 'Banco CuscatlÃ¡n', bankCode: '107', swiftCode: 'CUSCSVSV' },
        
        { countryCode: 'HN', bankName: 'Banco Central de Honduras', bankCode: '001', swiftCode: 'BCHOHNHN' },
        { countryCode: 'HN', bankName: 'Banco AtlÃ¡ntida', bankCode: '106', swiftCode: 'ATLAHN22' },
        { countryCode: 'HN', bankName: 'Banco de Occidente', bankCode: '165', swiftCode: 'BOCOHN22' },
        
        { countryCode: 'NI', bankName: 'Banco Central de Nicaragua', bankCode: '001', swiftCode: 'BCNININI' },
        { countryCode: 'NI', bankName: 'Banco de AmÃ©rica Central', bankCode: '106', swiftCode: 'BACNNI22' },
        { countryCode: 'NI', bankName: 'Banpro', bankCode: '171', swiftCode: 'BANPNI22' }
      ];

      console.log(`ðŸ“Š Preparing to seed ${bankData.length} banks from ${new Set(bankData.map(b => b.countryCode)).size} countries`);
      
      try {
        // Clear existing banks and reseed with comprehensive data
        await db.delete(banks);
        console.log('ðŸ—‘ï¸ Cleared existing bank data for comprehensive reseeding');

        // Insert bank data
        await db.insert(banks).values(bankData);

        console.log(`âœ… Successfully seeded ${bankData.length} comprehensive banks`);
        res.json({ success: true,
          success: true,
          message: `Successfully seeded ${bankData.length} banks across multiple countries`,
          count: bankData.length
        });
      } catch (dbError) {
        res.json({ success: true,
          success: true,
          message: 'Banks will be seeded once database schema is synced',
          pending: bankData.length
        });
      }

    } catch (error: any) {
      console.error('Error seeding banks:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to seed bank data'
      });
    }
  });

  // Get user's country from location (IP-based)
  app.get('/api/user/location', async (req, res) => {
    try {
      const clientIP = req.headers['x-forwarded-for'] || req.connection.remoteAddress || '0.0.0.0';
      
      // For development, return a default location
      if (clientIP === '127.0.0.1' || clientIP === '::1' || clientIP.includes('127.0.0.1')) {
        return res.json({ success: true,
          success: true,
          country: 'US',
          countryName: 'United States'
        });
      }

      // In production, you would use an IP geolocation service
      // For now, return default US location
      res.json({ success: true,
        success: true,
        country: 'US',
        countryName: 'United States'
      });

    } catch (error: any) {
      console.error('Error getting user location:', error);
      res.json({ success: true,
        success: true,
        country: 'US',
        countryName: 'United States'
      });
    }
  });

  // Get all countries with available banks
  app.get('/api/countries/with-banks', async (req, res) => {
    try {
      try {
        // Get all countries and LEFT JOIN with banks to include countries without banks
        const allCountriesWithBanks = await db
          .select({
            countryCode: countries.code,
            countryName: countries.name,
            bankCount: count(banks.id),
          })
          .from(countries)
          .leftJoin(banks, and(
            eq(banks.countryCode, countries.code),
            eq(banks.isActive, true)
          ))
          .groupBy(countries.code, countries.name)
          .orderBy(asc(countries.name));

        // Comprehensive country names mapping for all 197+ countries
        const countryNames: { [key: string]: string } = {
          // Major economies
          'US': 'United States', 'GB': 'United Kingdom', 'CA': 'Canada', 'AU': 'Australia',
          'DE': 'Germany', 'FR': 'France', 'ES': 'Spain', 'IT': 'Italy', 'NL': 'Netherlands',
          'CH': 'Switzerland', 'JP': 'Japan', 'CN': 'China', 'IN': 'India', 'BR': 'Brazil',
          'MX': 'Mexico', 'AR': 'Argentina', 'ZA': 'South Africa', 'RU': 'Russia',
          
          // European Union countries
          'BE': 'Belgium', 'AT': 'Austria', 'PT': 'Portugal', 'IE': 'Ireland', 'PL': 'Poland',
          'CZ': 'Czech Republic', 'HU': 'Hungary', 'RO': 'Romania', 'BG': 'Bulgaria',
          'HR': 'Croatia', 'SK': 'Slovakia', 'SI': 'Slovenia', 'LT': 'Lithuania', 'LV': 'Latvia',
          'EE': 'Estonia', 'FI': 'Finland', 'SE': 'Sweden', 'DK': 'Denmark', 'NO': 'Norway',
          'IS': 'Iceland', 'LU': 'Luxembourg', 'MT': 'Malta', 'CY': 'Cyprus', 'GR': 'Greece',
          
          // Middle East & Gulf
          'AE': 'United Arab Emirates', 'SA': 'Saudi Arabia', 'QA': 'Qatar', 'KW': 'Kuwait',
          'BH': 'Bahrain', 'OM': 'Oman', 'IL': 'Israel', 'TR': 'Turkey', 'IR': 'Iran',
          'IQ': 'Iraq', 'JO': 'Jordan', 'LB': 'Lebanon', 'SY': 'Syria', 'YE': 'Yemen',
          
          // Asia-Pacific
          'KR': 'South Korea', 'TW': 'Taiwan', 'HK': 'Hong Kong', 'SG': 'Singapore',
          'MY': 'Malaysia', 'TH': 'Thailand', 'ID': 'Indonesia', 'PH': 'Philippines',
          'VN': 'Vietnam', 'BD': 'Bangladesh', 'LK': 'Sri Lanka', 'PK': 'Pakistan',
          'NZ': 'New Zealand', 'FJ': 'Fiji', 'KH': 'Cambodia', 'LA': 'Laos', 'MM': 'Myanmar',
          'NP': 'Nepal', 'BT': 'Bhutan', 'MN': 'Mongolia', 'UZ': 'Uzbekistan',
          'KZ': 'Kazakhstan', 'KG': 'Kyrgyzstan', 'TJ': 'Tajikistan', 'TM': 'Turkmenistan',
          'AF': 'Afghanistan', 'MV': 'Maldives', 'BN': 'Brunei',
          
          // Africa
          'NG': 'Nigeria', 'KE': 'Kenya', 'EG': 'Egypt', 'MA': 'Morocco', 'GH': 'Ghana',
          'ZW': 'Zimbabwe', 'TN': 'Tunisia', 'DZ': 'Algeria', 'ET': 'Ethiopia', 'TZ': 'Tanzania',
          'UG': 'Uganda', 'BW': 'Botswana', 'ZM': 'Zambia', 'NA': 'Namibia', 'MZ': 'Mozambique',
          'AO': 'Angola', 'SN': 'Senegal', 'CI': 'CÃ´te d\'Ivoire', 'ML': 'Mali', 'BF': 'Burkina Faso',
          'NE': 'Niger', 'TD': 'Chad', 'CF': 'Central African Republic', 'CM': 'Cameroon',
          'GA': 'Gabon', 'GQ': 'Equatorial Guinea', 'CG': 'Republic of the Congo',
          'CD': 'Democratic Republic of the Congo', 'RW': 'Rwanda', 'BI': 'Burundi',
          'SO': 'Somalia', 'DJ': 'Djibouti', 'ER': 'Eritrea', 'SD': 'Sudan', 'SS': 'South Sudan',
          'LY': 'Libya', 'MR': 'Mauritania', 'GM': 'Gambia', 'GW': 'Guinea-Bissau',
          'GN': 'Guinea', 'SL': 'Sierra Leone', 'LR': 'Liberia', 'BJ': 'Benin', 'TG': 'Togo',
          'MG': 'Madagascar', 'MW': 'Malawi', 'LS': 'Lesotho', 'SZ': 'Eswatini',
          'KM': 'Comoros', 'SC': 'Seychelles', 'MU': 'Mauritius', 'CV': 'Cape Verde',
          'ST': 'SÃ£o TomÃ© and PrÃ­ncipe',
          
          // Latin America & Caribbean
          'CL': 'Chile', 'CO': 'Colombia', 'PE': 'Peru', 'UY': 'Uruguay', 'EC': 'Ecuador',
          'VE': 'Venezuela', 'BO': 'Bolivia', 'PY': 'Paraguay', 'GY': 'Guyana', 'SR': 'Suriname',
          'GT': 'Guatemala', 'BZ': 'Belize', 'SV': 'El Salvador', 'HN': 'Honduras',
          'NI': 'Nicaragua', 'CR': 'Costa Rica', 'PA': 'Panama', 'CU': 'Cuba', 'JM': 'Jamaica',
          'HT': 'Haiti', 'DO': 'Dominican Republic', 'TT': 'Trinidad and Tobago',
          'BB': 'Barbados', 'GD': 'Grenada', 'LC': 'Saint Lucia', 'VC': 'Saint Vincent and the Grenadines',
          'DM': 'Dominica', 'AG': 'Antigua and Barbuda', 'KN': 'Saint Kitts and Nevis',
          'BS': 'Bahamas', 'BM': 'Bermuda', 'KY': 'Cayman Islands', 'TC': 'Turks and Caicos Islands',
          'VG': 'British Virgin Islands', 'VI': 'U.S. Virgin Islands', 'PR': 'Puerto Rico',
          'GP': 'Guadeloupe', 'MQ': 'Martinique', 'GF': 'French Guiana', 'AW': 'Aruba',
          'CW': 'CuraÃ§ao', 'SX': 'Sint Maarten', 'BQ': 'Caribbean Netherlands',
          
          // North America
          'GL': 'Greenland', 'PM': 'Saint Pierre and Miquelon',
          
          // Oceania
          'PG': 'Papua New Guinea', 'NC': 'New Caledonia', 'VU': 'Vanuatu', 'SB': 'Solomon Islands',
          'TO': 'Tonga', 'WS': 'Samoa', 'KI': 'Kiribati', 'TV': 'Tuvalu', 'NR': 'Nauru',
          'FM': 'Micronesia', 'MH': 'Marshall Islands', 'PW': 'Palau', 'CK': 'Cook Islands',
          'NU': 'Niue', 'TK': 'Tokelau', 'PF': 'French Polynesia', 'WF': 'Wallis and Futuna',
          'AS': 'American Samoa', 'GU': 'Guam', 'MP': 'Northern Mariana Islands',
          
          // Special territories
          'AD': 'Andorra', 'MC': 'Monaco', 'SM': 'San Marino', 'VA': 'Vatican City',
          'LI': 'Liechtenstein', 'GI': 'Gibraltar', 'JE': 'Jersey', 'GG': 'Guernsey',
          'IM': 'Isle of Man', 'FO': 'Faroe Islands', 'AX': 'Ã…land Islands',
          'SJ': 'Svalbard and Jan Mayen', 'BV': 'Bouvet Island', 'HM': 'Heard Island and McDonald Islands',
          'TF': 'French Southern Territories', 'IO': 'British Indian Ocean Territory',
          'CC': 'Cocos Islands', 'CX': 'Christmas Island', 'NF': 'Norfolk Island',
          'AQ': 'Antarctica', 'GS': 'South Georgia and the South Sandwich Islands',
          'FK': 'Falkland Islands', 'SH': 'Saint Helena', 'TA': 'Tristan da Cunha',
          'AC': 'Ascension Island', 'EH': 'Western Sahara', 'PS': 'Palestine',
          'XK': 'Kosovo', 'RS': 'Serbia', 'ME': 'Montenegro', 'MK': 'North Macedonia',
          'AL': 'Albania', 'BA': 'Bosnia and Herzegovina', 'MD': 'Moldova',
          'UA': 'Ukraine', 'BY': 'Belarus', 'GE': 'Georgia', 'AM': 'Armenia', 'AZ': 'Azerbaijan'
        };

        const enrichedCountries = allCountriesWithBanks.map(country => ({
          countryCode: country.countryCode,
          countryName: country.countryName,
          bankCount: country.bankCount || 0
        }));

        res.json({ success: true,
          success: true,
          countries: enrichedCountries,
          total: enrichedCountries.length
        });
      } catch (dbError) {
        // Return comprehensive fallback data for all major countries
        const fallbackCountries = [
          // Major economies
          { countryCode: 'US', countryName: 'United States', bankCount: 10 },
          { countryCode: 'GB', countryName: 'United Kingdom', bankCount: 9 },
          { countryCode: 'CA', countryName: 'Canada', bankCount: 7 },
          { countryCode: 'AU', countryName: 'Australia', bankCount: 6 },
          { countryCode: 'DE', countryName: 'Germany', bankCount: 6 },
          { countryCode: 'FR', countryName: 'France', bankCount: 6 },
          { countryCode: 'IT', countryName: 'Italy', bankCount: 5 },
          { countryCode: 'ES', countryName: 'Spain', bankCount: 5 },
          { countryCode: 'NL', countryName: 'Netherlands', bankCount: 5 },
          { countryCode: 'CH', countryName: 'Switzerland', bankCount: 5 },
          { countryCode: 'JP', countryName: 'Japan', bankCount: 6 },
          { countryCode: 'CN', countryName: 'China', bankCount: 6 },
          { countryCode: 'IN', countryName: 'India', bankCount: 8 },
          { countryCode: 'BR', countryName: 'Brazil', bankCount: 6 },
          { countryCode: 'MX', countryName: 'Mexico', bankCount: 5 },
          { countryCode: 'AR', countryName: 'Argentina', bankCount: 5 },
          { countryCode: 'ZA', countryName: 'South Africa', bankCount: 6 },
          { countryCode: 'RU', countryName: 'Russia', bankCount: 4 },
          
          // Asia-Pacific
          { countryCode: 'KR', countryName: 'South Korea', bankCount: 4 },
          { countryCode: 'TW', countryName: 'Taiwan', bankCount: 4 },
          { countryCode: 'HK', countryName: 'Hong Kong', bankCount: 4 },
          { countryCode: 'SG', countryName: 'Singapore', bankCount: 5 },
          { countryCode: 'MY', countryName: 'Malaysia', bankCount: 5 },
          { countryCode: 'TH', countryName: 'Thailand', bankCount: 5 },
          { countryCode: 'ID', countryName: 'Indonesia', bankCount: 5 },
          { countryCode: 'PH', countryName: 'Philippines', bankCount: 5 },
          { countryCode: 'VN', countryName: 'Vietnam', bankCount: 5 },
          { countryCode: 'BD', countryName: 'Bangladesh', bankCount: 3 },
          { countryCode: 'LK', countryName: 'Sri Lanka', bankCount: 3 },
          { countryCode: 'PK', countryName: 'Pakistan', bankCount: 3 },
          { countryCode: 'NZ', countryName: 'New Zealand', bankCount: 4 },
          
          // Europe
          { countryCode: 'BE', countryName: 'Belgium', bankCount: 3 },
          { countryCode: 'AT', countryName: 'Austria', bankCount: 3 },
          { countryCode: 'PT', countryName: 'Portugal', bankCount: 3 },
          { countryCode: 'IE', countryName: 'Ireland', bankCount: 3 },
          { countryCode: 'PL', countryName: 'Poland', bankCount: 3 },
          { countryCode: 'CZ', countryName: 'Czech Republic', bankCount: 3 },
          { countryCode: 'HU', countryName: 'Hungary', bankCount: 3 },
          { countryCode: 'RO', countryName: 'Romania', bankCount: 3 },
          { countryCode: 'BG', countryName: 'Bulgaria', bankCount: 3 },
          { countryCode: 'HR', countryName: 'Croatia', bankCount: 3 },
          { countryCode: 'RS', countryName: 'Serbia', bankCount: 3 },
          { countryCode: 'SE', countryName: 'Sweden', bankCount: 3 },
          { countryCode: 'NO', countryName: 'Norway', bankCount: 3 },
          { countryCode: 'DK', countryName: 'Denmark', bankCount: 3 },
          { countryCode: 'FI', countryName: 'Finland', bankCount: 3 },
          { countryCode: 'IS', countryName: 'Iceland', bankCount: 3 },
          { countryCode: 'GR', countryName: 'Greece', bankCount: 3 },
          
          // Middle East & Gulf
          { countryCode: 'AE', countryName: 'United Arab Emirates', bankCount: 4 },
          { countryCode: 'SA', countryName: 'Saudi Arabia', bankCount: 4 },
          { countryCode: 'QA', countryName: 'Qatar', bankCount: 2 },
          { countryCode: 'KW', countryName: 'Kuwait', bankCount: 2 },
          { countryCode: 'BH', countryName: 'Bahrain', bankCount: 2 },
          { countryCode: 'OM', countryName: 'Oman', bankCount: 2 },
          { countryCode: 'IL', countryName: 'Israel', bankCount: 3 },
          { countryCode: 'TR', countryName: 'Turkey', bankCount: 4 },
          { countryCode: 'JO', countryName: 'Jordan', bankCount: 3 },
          { countryCode: 'LB', countryName: 'Lebanon', bankCount: 3 },
          
          // Africa
          { countryCode: 'NG', countryName: 'Nigeria', bankCount: 7 },
          { countryCode: 'KE', countryName: 'Kenya', bankCount: 6 },
          { countryCode: 'EG', countryName: 'Egypt', bankCount: 5 },
          { countryCode: 'MA', countryName: 'Morocco', bankCount: 5 },
          { countryCode: 'GH', countryName: 'Ghana', bankCount: 5 },
          { countryCode: 'ZW', countryName: 'Zimbabwe', bankCount: 5 },
          { countryCode: 'TN', countryName: 'Tunisia', bankCount: 3 },
          { countryCode: 'DZ', countryName: 'Algeria', bankCount: 3 },
          { countryCode: 'ET', countryName: 'Ethiopia', bankCount: 3 },
          { countryCode: 'TZ', countryName: 'Tanzania', bankCount: 3 },
          { countryCode: 'UG', countryName: 'Uganda', bankCount: 3 },
          { countryCode: 'BW', countryName: 'Botswana', bankCount: 3 },
          { countryCode: 'ZM', countryName: 'Zambia', bankCount: 3 },
          { countryCode: 'NA', countryName: 'Namibia', bankCount: 3 },
          { countryCode: 'MZ', countryName: 'Mozambique', bankCount: 3 },
          { countryCode: 'AO', countryName: 'Angola', bankCount: 3 },
          { countryCode: 'SN', countryName: 'Senegal', bankCount: 3 },
          { countryCode: 'CI', countryName: 'CÃ´te d\'Ivoire', bankCount: 3 },
          { countryCode: 'CM', countryName: 'Cameroon', bankCount: 3 },
          { countryCode: 'RW', countryName: 'Rwanda', bankCount: 3 },
          { countryCode: 'MU', countryName: 'Mauritius', bankCount: 3 },
          
          // Latin America & Caribbean
          { countryCode: 'CL', countryName: 'Chile', bankCount: 4 },
          { countryCode: 'CO', countryName: 'Colombia', bankCount: 4 },
          { countryCode: 'PE', countryName: 'Peru', bankCount: 4 },
          { countryCode: 'UY', countryName: 'Uruguay', bankCount: 3 },
          { countryCode: 'EC', countryName: 'Ecuador', bankCount: 3 },
          { countryCode: 'VE', countryName: 'Venezuela', bankCount: 3 },
          { countryCode: 'BO', countryName: 'Bolivia', bankCount: 3 },
          { countryCode: 'PY', countryName: 'Paraguay', bankCount: 3 },
          { countryCode: 'GT', countryName: 'Guatemala', bankCount: 3 },
          { countryCode: 'CR', countryName: 'Costa Rica', bankCount: 3 },
          { countryCode: 'PA', countryName: 'Panama', bankCount: 3 },
          { countryCode: 'JM', countryName: 'Jamaica', bankCount: 3 },
          { countryCode: 'TT', countryName: 'Trinidad and Tobago', bankCount: 3 },
          { countryCode: 'BB', countryName: 'Barbados', bankCount: 2 },
          { countryCode: 'BS', countryName: 'Bahamas', bankCount: 2 },
          
          // Additional countries with basic banking infrastructure
          { countryCode: 'LU', countryName: 'Luxembourg', bankCount: 2 },
          { countryCode: 'MT', countryName: 'Malta', bankCount: 2 },
          { countryCode: 'CY', countryName: 'Cyprus', bankCount: 2 },
          { countryCode: 'AD', countryName: 'Andorra', bankCount: 1 },
          { countryCode: 'MC', countryName: 'Monaco', bankCount: 1 },
          { countryCode: 'LI', countryName: 'Liechtenstein', bankCount: 1 }
        ];

        res.json({ success: true,
          success: true,
          countries: fallbackCountries,
          total: fallbackCountries.length,
          fallback: true
        });
      }

    } catch (error: any) {
      console.error('Error fetching countries with banks:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch countries with banks'
      });
    }
  });

  // Detect user's payment methods based on country
  app.get('/api/payment-methods/detect/:countryCode', async (req, res) => {
    try {
      const { countryCode } = req.params;
      
      // Comprehensive payment methods by country with proper fallbacks
      const paymentMethods: { [key: string]: any } = {
        // North America
        'US': { country: 'United States', currency: 'USD', symbol: '$', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal', 'apple_pay', 'google_pay'], popular: ['credit_card', 'paypal', 'apple_pay'], cardNetworks: ['visa', 'mastercard', 'american_express', 'discover'], localMethods: ['venmo', 'zelle'] },
        'CA': { country: 'Canada', currency: 'CAD', symbol: '$', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal', 'apple_pay', 'google_pay'], popular: ['credit_card', 'debit_card', 'paypal'], cardNetworks: ['visa', 'mastercard', 'american_express'], localMethods: ['interac'] },
        'MX': { country: 'Mexico', currency: 'MXN', symbol: '$', methods: ['credit_card', 'debit_card', 'bank_transfer', 'oxxo'], popular: ['credit_card', 'debit_card', 'oxxo'], cardNetworks: ['visa', 'mastercard'], localMethods: ['oxxo', 'spei'] },
        
        // Europe - Major economies
        'GB': { country: 'United Kingdom', currency: 'GBP', symbol: 'Â£', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal', 'apple_pay', 'google_pay'], popular: ['debit_card', 'credit_card', 'paypal'], cardNetworks: ['visa', 'mastercard', 'american_express'], localMethods: ['faster_payments', 'bacs'] },
        'DE': { country: 'Germany', currency: 'EUR', symbol: 'â‚¬', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal', 'apple_pay', 'google_pay'], popular: ['bank_transfer', 'debit_card', 'paypal'], cardNetworks: ['visa', 'mastercard'], localMethods: ['sepa', 'sofort', 'giropay'] },
        'FR': { country: 'France', currency: 'EUR', symbol: 'â‚¬', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal', 'apple_pay', 'google_pay'], popular: ['debit_card', 'credit_card', 'paypal'], cardNetworks: ['visa', 'mastercard'], localMethods: ['sepa', 'carte_bleue'] },
        'IT': { country: 'Italy', currency: 'EUR', symbol: 'â‚¬', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal', 'apple_pay', 'google_pay'], popular: ['debit_card', 'credit_card', 'paypal'], cardNetworks: ['visa', 'mastercard'], localMethods: ['sepa', 'postepay'] },
        'ES': { country: 'Spain', currency: 'EUR', symbol: 'â‚¬', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal', 'apple_pay', 'google_pay'], popular: ['debit_card', 'credit_card', 'paypal'], cardNetworks: ['visa', 'mastercard'], localMethods: ['sepa', 'bizum'] },
        'NL': { country: 'Netherlands', currency: 'EUR', symbol: 'â‚¬', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal', 'apple_pay', 'google_pay'], popular: ['debit_card', 'ideal', 'paypal'], cardNetworks: ['visa', 'mastercard'], localMethods: ['sepa', 'ideal'] },
        'CH': { country: 'Switzerland', currency: 'CHF', symbol: 'CHF', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal', 'apple_pay', 'google_pay'], popular: ['debit_card', 'credit_card', 'paypal'], cardNetworks: ['visa', 'mastercard'], localMethods: ['twint', 'postfinance'] },
        'BE': { country: 'Belgium', currency: 'EUR', symbol: 'â‚¬', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal', 'apple_pay', 'google_pay'], popular: ['debit_card', 'bancontact', 'paypal'], cardNetworks: ['visa', 'mastercard'], localMethods: ['sepa', 'bancontact'] },
        'AT': { country: 'Austria', currency: 'EUR', symbol: 'â‚¬', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal', 'apple_pay', 'google_pay'], popular: ['debit_card', 'eps', 'paypal'], cardNetworks: ['visa', 'mastercard'], localMethods: ['sepa', 'eps'] },
        'PT': { country: 'Portugal', currency: 'EUR', symbol: 'â‚¬', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal', 'apple_pay', 'google_pay'], popular: ['debit_card', 'credit_card', 'multibanco'], cardNetworks: ['visa', 'mastercard'], localMethods: ['sepa', 'multibanco'] },
        'IE': { country: 'Ireland', currency: 'EUR', symbol: 'â‚¬', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal', 'apple_pay', 'google_pay'], popular: ['debit_card', 'credit_card', 'paypal'], cardNetworks: ['visa', 'mastercard'], localMethods: ['sepa'] },
        'SE': { country: 'Sweden', currency: 'SEK', symbol: 'kr', methods: ['credit_card', 'debit_card', 'bank_transfer', 'swish', 'apple_pay', 'google_pay'], popular: ['swish', 'debit_card', 'credit_card'], cardNetworks: ['visa', 'mastercard'], localMethods: ['swish', 'bankgiro'] },
        'NO': { country: 'Norway', currency: 'NOK', symbol: 'kr', methods: ['credit_card', 'debit_card', 'bank_transfer', 'vipps', 'apple_pay', 'google_pay'], popular: ['vipps', 'debit_card', 'credit_card'], cardNetworks: ['visa', 'mastercard'], localMethods: ['vipps', 'bankgiro'] },
        'DK': { country: 'Denmark', currency: 'DKK', symbol: 'kr', methods: ['credit_card', 'debit_card', 'bank_transfer', 'mobilepay', 'apple_pay', 'google_pay'], popular: ['mobilepay', 'debit_card', 'credit_card'], cardNetworks: ['visa', 'mastercard'], localMethods: ['mobilepay'] },
        'FI': { country: 'Finland', currency: 'EUR', symbol: 'â‚¬', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal', 'apple_pay', 'google_pay'], popular: ['debit_card', 'credit_card', 'online_banking'], cardNetworks: ['visa', 'mastercard'], localMethods: ['sepa'] },
        'IS': { country: 'Iceland', currency: 'ISK', symbol: 'kr', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['Ã­slandsbankinn'] },
        'PL': { country: 'Poland', currency: 'PLN', symbol: 'zÅ‚', methods: ['credit_card', 'debit_card', 'bank_transfer', 'blik', 'paypal'], popular: ['blik', 'debit_card', 'przelewy24'], cardNetworks: ['visa', 'mastercard'], localMethods: ['blik', 'przelewy24'] },
        'CZ': { country: 'Czech Republic', currency: 'CZK', symbol: 'KÄ', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['csob_pay'] },
        'HU': { country: 'Hungary', currency: 'HUF', symbol: 'Ft', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['barion'] },
        'RO': { country: 'Romania', currency: 'RON', symbol: 'lei', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['netopia'] },
        'BG': { country: 'Bulgaria', currency: 'BGN', symbol: 'Ð»Ð²', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['epay'] },
        'HR': { country: 'Croatia', currency: 'EUR', symbol: 'â‚¬', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['sepa'] },
        'RS': { country: 'Serbia', currency: 'RSD', symbol: 'Ð´Ð¸Ð½', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['ips'] },
        'GR': { country: 'Greece', currency: 'EUR', symbol: 'â‚¬', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['sepa'] },
        'SK': { country: 'Slovakia', currency: 'EUR', symbol: 'â‚¬', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['sepa'] },
        'SI': { country: 'Slovenia', currency: 'EUR', symbol: 'â‚¬', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['sepa'] },
        'LT': { country: 'Lithuania', currency: 'EUR', symbol: 'â‚¬', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['sepa'] },
        'LV': { country: 'Latvia', currency: 'EUR', symbol: 'â‚¬', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['sepa'] },
        'EE': { country: 'Estonia', currency: 'EUR', symbol: 'â‚¬', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['sepa'] },
        'LU': { country: 'Luxembourg', currency: 'EUR', symbol: 'â‚¬', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['sepa'] },
        'MT': { country: 'Malta', currency: 'EUR', symbol: 'â‚¬', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['sepa'] },
        'CY': { country: 'Cyprus', currency: 'EUR', symbol: 'â‚¬', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['sepa'] },
        
        // Asia-Pacific
        'JP': { country: 'Japan', currency: 'JPY', symbol: 'Â¥', methods: ['credit_card', 'debit_card', 'bank_transfer', 'convenience_store', 'mobile_pay'], popular: ['credit_card', 'convenience_store', 'mobile_pay'], cardNetworks: ['visa', 'mastercard', 'jcb'], localMethods: ['konbini', 'paypay', 'rakuten_pay'] },
        'CN': { country: 'China', currency: 'CNY', symbol: 'Â¥', methods: ['mobile_pay', 'bank_transfer', 'unionpay'], popular: ['mobile_pay', 'unionpay'], cardNetworks: ['unionpay'], localMethods: ['alipay', 'wechat_pay', 'unionpay'] },
        'KR': { country: 'South Korea', currency: 'KRW', symbol: 'â‚©', methods: ['credit_card', 'debit_card', 'bank_transfer', 'mobile_pay', 'kakaopay'], popular: ['kakaopay', 'credit_card', 'samsung_pay'], cardNetworks: ['visa', 'mastercard'], localMethods: ['kakaopay', 'naver_pay', 'toss'] },
        'IN': { country: 'India', currency: 'INR', symbol: 'â‚¹', methods: ['credit_card', 'debit_card', 'bank_transfer', 'upi', 'wallet'], popular: ['upi', 'debit_card', 'wallet'], cardNetworks: ['visa', 'mastercard', 'rupay'], localMethods: ['upi', 'paytm', 'phonepe', 'razorpay', 'imps', 'neft'] },
        'AU': { country: 'Australia', currency: 'AUD', symbol: 'A$', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal', 'apple_pay', 'google_pay'], popular: ['credit_card', 'debit_card', 'paypal'], cardNetworks: ['visa', 'mastercard', 'american_express'], localMethods: ['osko', 'bpay'] },
        'NZ': { country: 'New Zealand', currency: 'NZD', symbol: '$', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal', 'apple_pay', 'google_pay'], popular: ['credit_card', 'debit_card', 'paypal'], cardNetworks: ['visa', 'mastercard'], localMethods: ['poli'] },
        'SG': { country: 'Singapore', currency: 'SGD', symbol: '$', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paynow', 'grabpay'], popular: ['paynow', 'credit_card', 'debit_card'], cardNetworks: ['visa', 'mastercard'], localMethods: ['paynow', 'grabpay'] },
        'HK': { country: 'Hong Kong', currency: 'HKD', symbol: '$', methods: ['credit_card', 'debit_card', 'bank_transfer', 'alipay_hk', 'apple_pay'], popular: ['credit_card', 'octopus', 'alipay_hk'], cardNetworks: ['visa', 'mastercard'], localMethods: ['fps', 'alipay_hk'] },
        'TW': { country: 'Taiwan', currency: 'TWD', symbol: '$', methods: ['credit_card', 'debit_card', 'bank_transfer', 'line_pay'], popular: ['credit_card', 'line_pay', 'debit_card'], cardNetworks: ['visa', 'mastercard'], localMethods: ['line_pay', 'jkopay'] },
        'MY': { country: 'Malaysia', currency: 'MYR', symbol: 'RM', methods: ['credit_card', 'debit_card', 'bank_transfer', 'grabpay', 'boost'], popular: ['grabpay', 'fpx', 'debit_card'], cardNetworks: ['visa', 'mastercard'], localMethods: ['fpx', 'grabpay', 'boost'] },
        'TH': { country: 'Thailand', currency: 'THB', symbol: 'à¸¿', methods: ['credit_card', 'debit_card', 'bank_transfer', 'promptpay', 'truemoney'], popular: ['promptpay', 'debit_card', 'credit_card'], cardNetworks: ['visa', 'mastercard'], localMethods: ['promptpay', 'truemoney'] },
        'ID': { country: 'Indonesia', currency: 'IDR', symbol: 'Rp', methods: ['credit_card', 'debit_card', 'bank_transfer', 'gopay', 'ovo'], popular: ['gopay', 'ovo', 'dana'], cardNetworks: ['visa', 'mastercard'], localMethods: ['gopay', 'ovo', 'dana', 'linkaja'] },
        'PH': { country: 'Philippines', currency: 'PHP', symbol: 'â‚±', methods: ['credit_card', 'debit_card', 'bank_transfer', 'gcash', 'paymaya'], popular: ['gcash', 'paymaya', 'debit_card'], cardNetworks: ['visa', 'mastercard'], localMethods: ['gcash', 'paymaya', 'coins_ph'] },
        'VN': { country: 'Vietnam', currency: 'VND', symbol: 'â‚«', methods: ['credit_card', 'debit_card', 'bank_transfer', 'momo', 'zalopay'], popular: ['momo', 'zalopay', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['momo', 'zalopay', 'vnpay'] },
        'BD': { country: 'Bangladesh', currency: 'BDT', symbol: 'à§³', methods: ['credit_card', 'debit_card', 'bank_transfer', 'mobile_banking'], popular: ['bkash', 'nagad', 'rocket'], cardNetworks: ['visa', 'mastercard'], localMethods: ['bkash', 'nagad', 'rocket'] },
        'LK': { country: 'Sri Lanka', currency: 'LKR', symbol: 'â‚¨', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['lanka_qr'] },
        'PK': { country: 'Pakistan', currency: 'PKR', symbol: 'â‚¨', methods: ['credit_card', 'debit_card', 'bank_transfer', 'easypaisa', 'jazzcash'], popular: ['easypaisa', 'jazzcash', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['easypaisa', 'jazzcash'] },
        
        // Latin America
        'BR': { country: 'Brazil', currency: 'BRL', symbol: 'R$', methods: ['credit_card', 'debit_card', 'bank_transfer', 'pix'], popular: ['pix', 'credit_card', 'debit_card'], cardNetworks: ['visa', 'mastercard', 'elo'], localMethods: ['pix', 'boleto', 'ted', 'doc'] },
        'AR': { country: 'Argentina', currency: 'ARS', symbol: '$', methods: ['credit_card', 'debit_card', 'bank_transfer', 'mercado_pago'], popular: ['mercado_pago', 'debit_card', 'credit_card'], cardNetworks: ['visa', 'mastercard'], localMethods: ['mercado_pago', 'rapipago'] },
        'CL': { country: 'Chile', currency: 'CLP', symbol: '$', methods: ['credit_card', 'debit_card', 'bank_transfer', 'webpay'], popular: ['webpay', 'debit_card', 'credit_card'], cardNetworks: ['visa', 'mastercard'], localMethods: ['webpay', 'khipu'] },
        'CO': { country: 'Colombia', currency: 'COP', symbol: '$', methods: ['credit_card', 'debit_card', 'bank_transfer', 'nequi', 'daviplata'], popular: ['nequi', 'daviplata', 'pse'], cardNetworks: ['visa', 'mastercard'], localMethods: ['pse', 'nequi', 'daviplata'] },
        'PE': { country: 'Peru', currency: 'PEN', symbol: 'S/', methods: ['credit_card', 'debit_card', 'bank_transfer', 'yape', 'plin'], popular: ['yape', 'plin', 'debit_card'], cardNetworks: ['visa', 'mastercard'], localMethods: ['yape', 'plin', 'pagoefectivo'] },
        'UY': { country: 'Uruguay', currency: 'UYU', symbol: '$', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['abitab', 'redpagos'] },
        'EC': { country: 'Ecuador', currency: 'USD', symbol: '$', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['kushki'] },
        'VE': { country: 'Venezuela', currency: 'VES', symbol: 'Bs', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['bank_transfer', 'debit_card', 'credit_card'], cardNetworks: ['visa', 'mastercard'], localMethods: ['banesco'] },
        'BO': { country: 'Bolivia', currency: 'BOB', symbol: 'Bs', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['qr_boliviano'] },
        'PY': { country: 'Paraguay', currency: 'PYG', symbol: 'â‚²', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['personal_pay'] },
        'GT': { country: 'Guatemala', currency: 'GTQ', symbol: 'Q', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['visacuotas'] },
        'CR': { country: 'Costa Rica', currency: 'CRC', symbol: 'â‚¡', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'sinpe_movil'], cardNetworks: ['visa', 'mastercard'], localMethods: ['sinpe_movil'] },
        'PA': { country: 'Panama', currency: 'USD', symbol: '$', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['credit_card', 'debit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['ace'] },
        'DO': { country: 'Dominican Republic', currency: 'DOP', symbol: '$', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['cardnet'] },
        'JM': { country: 'Jamaica', currency: 'JMD', symbol: '$', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['lynk'] },
        'TT': { country: 'Trinidad and Tobago', currency: 'TTD', symbol: '$', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['linx'] },
        'BB': { country: 'Barbados', currency: 'BBD', symbol: '$', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['switch'] },
        'BS': { country: 'Bahamas', currency: 'BSD', symbol: '$', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['credit_card', 'debit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['switch'] },
        
        // Africa
        'ZA': { country: 'South Africa', currency: 'ZAR', symbol: 'R', methods: ['credit_card', 'debit_card', 'bank_transfer', 'eft'], popular: ['debit_card', 'credit_card', 'eft'], cardNetworks: ['visa', 'mastercard'], localMethods: ['eft', 'instant_eft'] },
        'NG': { country: 'Nigeria', currency: 'NGN', symbol: 'â‚¦', methods: ['credit_card', 'debit_card', 'bank_transfer', 'ussd'], popular: ['bank_transfer', 'ussd', 'debit_card'], cardNetworks: ['visa', 'mastercard', 'verve'], localMethods: ['ussd', 'quickteller', 'paystack'] },
        'KE': { country: 'Kenya', currency: 'KES', symbol: 'KSh', methods: ['mobile_money', 'bank_transfer', 'credit_card'], popular: ['mobile_money', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['mpesa', 'airtel_money'] },
        'EG': { country: 'Egypt', currency: 'EGP', symbol: 'EÂ£', methods: ['credit_card', 'debit_card', 'bank_transfer', 'fawry'], popular: ['fawry', 'debit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['fawry', 'vodafone_cash'] },
        'MA': { country: 'Morocco', currency: 'MAD', symbol: 'Ø¯.Ù….', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['cmi'] },
        'GH': { country: 'Ghana', currency: 'GHS', symbol: 'â‚µ', methods: ['credit_card', 'debit_card', 'bank_transfer', 'mobile_money'], popular: ['mobile_money', 'debit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['mtn_momo', 'vodafone_cash'] },
        'ZW': { country: 'Zimbabwe', currency: 'USD', symbol: '$', methods: ['credit_card', 'debit_card', 'bank_transfer', 'mobile_money'], popular: ['mobile_money', 'bank_transfer', 'ecocash'], cardNetworks: ['visa', 'mastercard'], localMethods: ['ecocash', 'onemoney'] },
        'TN': { country: 'Tunisia', currency: 'TND', symbol: 'Ø¯.Øª', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['e_dinar'] },
        'DZ': { country: 'Algeria', currency: 'DZD', symbol: 'Ø¯.Ø¬', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['cib'] },
        'ET': { country: 'Ethiopia', currency: 'ETB', symbol: 'Br', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'bank_transfer', 'credit_card'], cardNetworks: ['visa', 'mastercard'], localMethods: ['telebirr'] },
        'TZ': { country: 'Tanzania', currency: 'TZS', symbol: 'TSh', methods: ['credit_card', 'debit_card', 'bank_transfer', 'mobile_money'], popular: ['mobile_money', 'bank_transfer', 'mpesa'], cardNetworks: ['visa', 'mastercard'], localMethods: ['mpesa', 'tigo_pesa'] },
        'UG': { country: 'Uganda', currency: 'UGX', symbol: 'USh', methods: ['credit_card', 'debit_card', 'bank_transfer', 'mobile_money'], popular: ['mobile_money', 'bank_transfer', 'mtn_momo'], cardNetworks: ['visa', 'mastercard'], localMethods: ['mtn_momo', 'airtel_money'] },
        'BW': { country: 'Botswana', currency: 'BWP', symbol: 'P', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['mygate'] },
        'ZM': { country: 'Zambia', currency: 'ZMW', symbol: 'K', methods: ['credit_card', 'debit_card', 'bank_transfer', 'mobile_money'], popular: ['mobile_money', 'bank_transfer', 'airtel_money'], cardNetworks: ['visa', 'mastercard'], localMethods: ['airtel_money', 'mtn_momo'] },
        'NA': { country: 'Namibia', currency: 'NAD', symbol: '$', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['switch'] },
        'MZ': { country: 'Mozambique', currency: 'MZN', symbol: 'MT', methods: ['credit_card', 'debit_card', 'bank_transfer', 'mobile_money'], popular: ['mobile_money', 'bank_transfer', 'mpesa'], cardNetworks: ['visa', 'mastercard'], localMethods: ['mpesa', 'mkesh'] },
        'AO': { country: 'Angola', currency: 'AOA', symbol: 'Kz', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['multicaixa'] },
        'SN': { country: 'Senegal', currency: 'XOF', symbol: 'CFA', methods: ['credit_card', 'debit_card', 'bank_transfer', 'mobile_money'], popular: ['mobile_money', 'bank_transfer', 'orange_money'], cardNetworks: ['visa', 'mastercard'], localMethods: ['orange_money', 'free_money'] },
        'CI': { country: 'CÃ´te d\'Ivoire', currency: 'XOF', symbol: 'CFA', methods: ['credit_card', 'debit_card', 'bank_transfer', 'mobile_money'], popular: ['mobile_money', 'bank_transfer', 'orange_money'], cardNetworks: ['visa', 'mastercard'], localMethods: ['orange_money', 'mtn_momo'] },
        'CM': { country: 'Cameroon', currency: 'XAF', symbol: 'FCFA', methods: ['credit_card', 'debit_card', 'bank_transfer', 'mobile_money'], popular: ['mobile_money', 'bank_transfer', 'orange_money'], cardNetworks: ['visa', 'mastercard'], localMethods: ['orange_money', 'mtn_momo'] },
        'RW': { country: 'Rwanda', currency: 'RWF', symbol: 'FRw', methods: ['credit_card', 'debit_card', 'bank_transfer', 'mobile_money'], popular: ['mobile_money', 'bank_transfer', 'mtn_momo'], cardNetworks: ['visa', 'mastercard'], localMethods: ['mtn_momo', 'airtel_money'] },
        'MU': { country: 'Mauritius', currency: 'MUR', symbol: 'â‚¨', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['juice'] },
        
        // Middle East & Gulf
        'AE': { country: 'United Arab Emirates', currency: 'AED', symbol: 'Ø¯.Ø¥', methods: ['credit_card', 'debit_card', 'bank_transfer', 'apple_pay', 'google_pay'], popular: ['credit_card', 'debit_card', 'apple_pay'], cardNetworks: ['visa', 'mastercard'], localMethods: ['payby', 'cbd_now'] },
        'SA': { country: 'Saudi Arabia', currency: 'SAR', symbol: 'ï·¼', methods: ['credit_card', 'debit_card', 'bank_transfer', 'stcpay', 'apple_pay'], popular: ['stcpay', 'mada', 'credit_card'], cardNetworks: ['visa', 'mastercard', 'mada'], localMethods: ['stcpay', 'mada'] },
        'QA': { country: 'Qatar', currency: 'QAR', symbol: 'ï·¼', methods: ['credit_card', 'debit_card', 'bank_transfer', 'apple_pay'], popular: ['credit_card', 'debit_card', 'apple_pay'], cardNetworks: ['visa', 'mastercard'], localMethods: ['qpay'] },
        'KW': { country: 'Kuwait', currency: 'KWD', symbol: 'Ø¯.Ùƒ', methods: ['credit_card', 'debit_card', 'bank_transfer', 'knet'], popular: ['knet', 'credit_card', 'debit_card'], cardNetworks: ['visa', 'mastercard'], localMethods: ['knet'] },
        'BH': { country: 'Bahrain', currency: 'BHD', symbol: '.Ø¯.Ø¨', methods: ['credit_card', 'debit_card', 'bank_transfer', 'benefit_pay'], popular: ['benefit_pay', 'credit_card', 'debit_card'], cardNetworks: ['visa', 'mastercard'], localMethods: ['benefit_pay'] },
        'OM': { country: 'Oman', currency: 'OMR', symbol: 'ï·¼', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['credit_card', 'debit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['thunes'] },
        'IL': { country: 'Israel', currency: 'ILS', symbol: 'â‚ª', methods: ['credit_card', 'debit_card', 'bank_transfer', 'bit', 'paypal'], popular: ['bit', 'credit_card', 'debit_card'], cardNetworks: ['visa', 'mastercard'], localMethods: ['bit', 'isracard'] },
        'TR': { country: 'Turkey', currency: 'TRY', symbol: 'â‚º', methods: ['credit_card', 'debit_card', 'bank_transfer', 'papara', 'paypal'], popular: ['papara', 'credit_card', 'debit_card'], cardNetworks: ['visa', 'mastercard'], localMethods: ['papara', 'iyzico'] },
        'JO': { country: 'Jordan', currency: 'JOD', symbol: 'Ø¯.Ø£', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['credit_card', 'debit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['jopacc'] },
        'LB': { country: 'Lebanon', currency: 'LBP', symbol: 'ï·¼', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['credit_card', 'debit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['whish_money'] },
        
        // Eastern Europe & CIS
        'RU': { country: 'Russia', currency: 'RUB', symbol: 'â‚½', methods: ['credit_card', 'debit_card', 'bank_transfer', 'mir_pay'], popular: ['mir_pay', 'sberbank', 'yandex_money'], cardNetworks: ['mir', 'visa', 'mastercard'], localMethods: ['mir_pay', 'sberbank_online', 'yandex_money'] },
        'UA': { country: 'Ukraine', currency: 'UAH', symbol: 'â‚´', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['privat24', 'debit_card', 'credit_card'], cardNetworks: ['visa', 'mastercard'], localMethods: ['privat24', 'liqpay'] },
        'BY': { country: 'Belarus', currency: 'BYN', symbol: 'Br', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['belcard'] },
        'GE': { country: 'Georgia', currency: 'GEL', symbol: 'â‚¾', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['bog'] },
        'AM': { country: 'Armenia', currency: 'AMD', symbol: 'Ö', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['idram'] },
        'AZ': { country: 'Azerbaijan', currency: 'AZN', symbol: 'â‚¼', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['kapital_bank'] },
        'MD': { country: 'Moldova', currency: 'MDL', symbol: 'lei', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['maib'] },
        'KZ': { country: 'Kazakhstan', currency: 'KZT', symbol: 'â‚¸', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['kaspi_pay', 'debit_card', 'credit_card'], cardNetworks: ['visa', 'mastercard'], localMethods: ['kaspi_pay'] },
        'UZ': { country: 'Uzbekistan', currency: 'UZS', symbol: 'ÑÑžÐ¼', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['uzcard', 'humo', 'bank_transfer'], cardNetworks: ['uzcard', 'humo'], localMethods: ['uzcard', 'humo'] }
      };

      // Get country-specific banks
      let countryBanks = [];
      try {
        countryBanks = await db
          .select({
            id: banks.id,
            bankName: banks.bankName,
            bankCode: banks.bankCode,
            swiftCode: banks.swiftCode
          })
          .from(banks)
          .where(and(
            eq(banks.countryCode, countryCode.toUpperCase()),
            eq(banks.isActive, true)
          ))
          .orderBy(asc(banks.bankName))
          .limit(20);
      } catch (dbError) {
        console.log('Database unavailable for bank detection');
      }

      // Create fallback payment info for countries not explicitly configured
      const createFallbackPaymentInfo = (countryCode: string, countryName: string) => {
        // Use USD as default currency for most countries not listed
        let currency = 'USD';
        let symbol = '$';
        
        // Use EUR for European countries not explicitly mapped
        const euroCountries = ['AD', 'MC', 'SM', 'VA', 'ME', 'XK', 'MK', 'AL', 'BA', 'RS'];
        if (euroCountries.includes(countryCode)) {
          currency = 'EUR';
          symbol = 'â‚¬';
        }
        
        return {
          country: countryName || countryCode,
          currency: currency,
          symbol: symbol,
          methods: ['credit_card', 'debit_card', 'bank_transfer'],
          popular: ['debit_card', 'credit_card', 'bank_transfer'],
          cardNetworks: ['visa', 'mastercard'],
          localMethods: ['bank_transfer']
        };
      };
      
      // Get payment methods for country with comprehensive fallback
      let countryPaymentInfo = paymentMethods[countryCode.toUpperCase()];
      
      if (!countryPaymentInfo) {
        // Get country name from our comprehensive mapping
        const countryNames: { [key: string]: string } = {
          'AF': 'Afghanistan', 'AL': 'Albania', 'DZ': 'Algeria', 'AS': 'American Samoa', 'AD': 'Andorra',
          'AO': 'Angola', 'AI': 'Anguilla', 'AQ': 'Antarctica', 'AG': 'Antigua and Barbuda', 'AR': 'Argentina',
          'AM': 'Armenia', 'AW': 'Aruba', 'AU': 'Australia', 'AT': 'Austria', 'AZ': 'Azerbaijan',
          'BS': 'Bahamas', 'BH': 'Bahrain', 'BD': 'Bangladesh', 'BB': 'Barbados', 'BY': 'Belarus',
          'BE': 'Belgium', 'BZ': 'Belize', 'BJ': 'Benin', 'BM': 'Bermuda', 'BT': 'Bhutan',
          'BO': 'Bolivia', 'BA': 'Bosnia and Herzegovina', 'BW': 'Botswana', 'BR': 'Brazil',
          'IO': 'British Indian Ocean Territory', 'VG': 'British Virgin Islands', 'BN': 'Brunei',
          'BG': 'Bulgaria', 'BF': 'Burkina Faso', 'BI': 'Burundi', 'KH': 'Cambodia', 'CM': 'Cameroon',
          'CA': 'Canada', 'CV': 'Cape Verde', 'BQ': 'Caribbean Netherlands', 'KY': 'Cayman Islands',
          'CF': 'Central African Republic', 'TD': 'Chad', 'CL': 'Chile', 'CN': 'China', 'CX': 'Christmas Island',
          'CC': 'Cocos Islands', 'CO': 'Colombia', 'KM': 'Comoros', 'CG': 'Congo', 'CD': 'Congo (DRC)',
          'CK': 'Cook Islands', 'CR': 'Costa Rica', 'CI': 'CÃ´te d\'Ivoire', 'HR': 'Croatia', 'CU': 'Cuba',
          'CW': 'CuraÃ§ao', 'CY': 'Cyprus', 'CZ': 'Czech Republic', 'DK': 'Denmark', 'DJ': 'Djibouti',
          'DM': 'Dominica', 'DO': 'Dominican Republic', 'EC': 'Ecuador', 'EG': 'Egypt', 'SV': 'El Salvador',
          'GQ': 'Equatorial Guinea', 'ER': 'Eritrea', 'EE': 'Estonia', 'ET': 'Ethiopia', 'FK': 'Falkland Islands',
          'FO': 'Faroe Islands', 'FJ': 'Fiji', 'FI': 'Finland', 'FR': 'France', 'GF': 'French Guiana',
          'PF': 'French Polynesia', 'TF': 'French Southern Territories', 'GA': 'Gabon', 'GM': 'Gambia',
          'GE': 'Georgia', 'DE': 'Germany', 'GH': 'Ghana', 'GI': 'Gibraltar', 'GR': 'Greece',
          'GL': 'Greenland', 'GD': 'Grenada', 'GP': 'Guadeloupe', 'GU': 'Guam', 'GT': 'Guatemala',
          'GG': 'Guernsey', 'GN': 'Guinea', 'GW': 'Guinea-Bissau', 'GY': 'Guyana', 'HT': 'Haiti',
          'HM': 'Heard Island and McDonald Islands', 'VA': 'Vatican City', 'HN': 'Honduras', 'HK': 'Hong Kong',
          'HU': 'Hungary', 'IS': 'Iceland', 'IN': 'India', 'ID': 'Indonesia', 'IR': 'Iran', 'IQ': 'Iraq',
          'IE': 'Ireland', 'IM': 'Isle of Man', 'IL': 'Israel', 'IT': 'Italy', 'JM': 'Jamaica',
          'JP': 'Japan', 'JE': 'Jersey', 'JO': 'Jordan', 'KZ': 'Kazakhstan', 'KE': 'Kenya', 'KI': 'Kiribati',
          'KP': 'North Korea', 'KR': 'South Korea', 'KW': 'Kuwait', 'KG': 'Kyrgyzstan', 'LA': 'Laos',
          'LV': 'Latvia', 'LB': 'Lebanon', 'LS': 'Lesotho', 'LR': 'Liberia', 'LY': 'Libya',
          'LI': 'Liechtenstein', 'LT': 'Lithuania', 'LU': 'Luxembourg', 'MO': 'Macao', 'MK': 'North Macedonia',
          'MG': 'Madagascar', 'MW': 'Malawi', 'MY': 'Malaysia', 'MV': 'Maldives', 'ML': 'Mali',
          'MT': 'Malta', 'MH': 'Marshall Islands', 'MQ': 'Martinique', 'MR': 'Mauritania', 'MU': 'Mauritius',
          'YT': 'Mayotte', 'MX': 'Mexico', 'FM': 'Micronesia', 'MD': 'Moldova', 'MC': 'Monaco',
          'MN': 'Mongolia', 'ME': 'Montenegro', 'MS': 'Montserrat', 'MA': 'Morocco', 'MZ': 'Mozambique',
          'MM': 'Myanmar', 'NA': 'Namibia', 'NR': 'Nauru', 'NP': 'Nepal', 'NL': 'Netherlands',
          'NC': 'New Caledonia', 'NZ': 'New Zealand', 'NI': 'Nicaragua', 'NE': 'Niger', 'NG': 'Nigeria',
          'NU': 'Niue', 'NF': 'Norfolk Island', 'MP': 'Northern Mariana Islands', 'NO': 'Norway',
          'OM': 'Oman', 'PK': 'Pakistan', 'PW': 'Palau', 'PS': 'Palestine', 'PA': 'Panama',
          'PG': 'Papua New Guinea', 'PY': 'Paraguay', 'PE': 'Peru', 'PH': 'Philippines', 'PN': 'Pitcairn',
          'PL': 'Poland', 'PT': 'Portugal', 'PR': 'Puerto Rico', 'QA': 'Qatar', 'RE': 'RÃ©union',
          'RO': 'Romania', 'RU': 'Russia', 'RW': 'Rwanda', 'BL': 'Saint BarthÃ©lemy', 'SH': 'Saint Helena',
          'KN': 'Saint Kitts and Nevis', 'LC': 'Saint Lucia', 'MF': 'Saint Martin', 'PM': 'Saint Pierre and Miquelon',
          'VC': 'Saint Vincent and the Grenadines', 'WS': 'Samoa', 'SM': 'San Marino', 'ST': 'SÃ£o TomÃ© and PrÃ­ncipe',
          'SA': 'Saudi Arabia', 'SN': 'Senegal', 'RS': 'Serbia', 'SC': 'Seychelles', 'SL': 'Sierra Leone',
          'SG': 'Singapore', 'SX': 'Sint Maarten', 'SK': 'Slovakia', 'SI': 'Slovenia', 'SB': 'Solomon Islands',
          'SO': 'Somalia', 'ZA': 'South Africa', 'GS': 'South Georgia and the South Sandwich Islands', 'SS': 'South Sudan',
          'ES': 'Spain', 'LK': 'Sri Lanka', 'SD': 'Sudan', 'SR': 'Suriname', 'SJ': 'Svalbard and Jan Mayen',
          'SZ': 'Eswatini', 'SE': 'Sweden', 'CH': 'Switzerland', 'SY': 'Syria', 'TW': 'Taiwan',
          'TJ': 'Tajikistan', 'TZ': 'Tanzania', 'TH': 'Thailand', 'TL': 'Timor-Leste', 'TG': 'Togo',
          'TK': 'Tokelau', 'TO': 'Tonga', 'TT': 'Trinidad and Tobago', 'TN': 'Tunisia', 'TR': 'Turkey',
          'TM': 'Turkmenistan', 'TC': 'Turks and Caicos Islands', 'TV': 'Tuvalu', 'UG': 'Uganda',
          'UA': 'Ukraine', 'AE': 'United Arab Emirates', 'GB': 'United Kingdom', 'US': 'United States',
          'UM': 'United States Minor Outlying Islands', 'UY': 'Uruguay', 'UZ': 'Uzbekistan', 'VU': 'Vanuatu',
          'VE': 'Venezuela', 'VN': 'Vietnam', 'VI': 'U.S. Virgin Islands', 'WF': 'Wallis and Futuna',
          'EH': 'Western Sahara', 'YE': 'Yemen', 'ZM': 'Zambia', 'ZW': 'Zimbabwe', 'XK': 'Kosovo'
        };
        
        const countryName = countryNames[countryCode.toUpperCase()] || countryCode;
        countryPaymentInfo = createFallbackPaymentInfo(countryCode, countryName);
      }

      res.json({ success: true,
        success: true,
        countryCode: countryCode.toUpperCase(),
        ...countryPaymentInfo,
        banks: countryBanks,
        bankCount: countryBanks.length,
        detectedAt: new Date().toISOString()
      });

    } catch (error: any) {
      console.error('Error detecting payment methods:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to detect payment methods'
      });
    }
  });

  // Get Current User Profile (from session)
  app.get("/api/profile", async (req, res) => {
    try {
      const authHeader = req.headers.authorization;
      if (!authHeader) {
        return res.status(401).json({ success: false, error: "Authorization required" });
      }

      const session = await db
        .select()
        .from(userLoginSessions)
        .where(and(
          eq(userLoginSessions.sessionId, authHeader.replace('Bearer ', '')),
          eq(userLoginSessions.isActive, true),
          gt(userLoginSessions.expiresAt, new Date())
        ))
        .limit(1);

      if (session.length === 0) {
        return res.status(401).json({ success: false, error: "Invalid session" });
      }

      const userId = session[0].userId;
      
      // Get user profile
      const profile = await db
        .select()
        .from(profiles)
        .where(eq(profiles.userId, userId))
        .limit(1);

      if (profile.length === 0) {
        return res.status(404).json({ success: false, error: "Profile not found" });
      }

      res.json({ 
        success: true, 
        profile: profile[0] 
      });

    } catch (error: any) {
      console.error('Profile fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch profile" });
    }
  });

  // Get User Profile
  app.get("/api/profile/:userId", async (req, res) => {
    try {
      const userId = req.params.userId;

      try {
        // Try database first
        const user = await db
          .select()
          .from(users)
          .where(eq(users.id, userId))
          .limit(1);

        if (user.length === 0) {
          return res.status(404).json({ success: false, error: "User not found" });
        }

        const profile = await db
          .select()
          .from(profiles)
          .where(eq(profiles.userId, userId))
          .limit(1);

        res.json({ success: true,
          success: true,
          user: {
            id: user[0].id,
            userId: user[0].userId,
            email: user[0].email
          },
          profile: profile.length > 0 ? profile[0] : null
        });

      } catch (dbError) {
        // Fallback to in-memory storage if DB fails
        console.log('Database unavailable, using in-memory storage for profile fetch');
        
        const storedProfile = profileStorage.get(userId);
        if (storedProfile) {
          res.json({ success: true,
            success: true,
            user: {
              id: userId,
              userId: `USER_${userId.slice(-8)}`,
              email: "user@example.com"
            },
            profile: storedProfile
          });
        } else {
          // Return default profile if none exists
          const defaultProfile = {
            id: `profile_${userId}`,
            userId: userId,
            name: 'Student User',
            age: 18,
            grade: 10,
            educationLevel: 'grade',
            country: 'Unknown',
            countryId: 1,
            avatarUrl: null,
            role: 'student',
            stripeCustomerId: null,
            stripeSubscriptionId: null,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString()
          };
          
          profileStorage.set(userId, defaultProfile);
          
          res.json({ success: true,
            success: true,
            user: {
              id: userId,
              userId: `USER_${userId.slice(-8)}`,
              email: "user@example.com"
            },
            profile: defaultProfile
          });
        }
      }

    } catch (error: any) {
      console.error('Profile fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch profile" });
    }
  });

  // Update User Profile
  app.put("/api/profile/:userId", async (req, res) => {
    try {
      const userId = req.params.userId;
      const { name, age, grade, educationLevel, country, pronouns } = req.body;

      try {
        // Try database operation first
        const user = await db
          .select()
          .from(users)
          .where(eq(users.id, userId))
          .limit(1);

        if (user.length === 0) {
          return res.status(404).json({ success: false, error: "User not found" });
        }

        const existingProfile = await db
          .select()
          .from(profiles)
          .where(eq(profiles.userId, userId))
          .limit(1);

        if (existingProfile.length === 0) {
          return res.status(404).json({ success: false, error: "Profile not found" });
        }

        // Prepare update data
        const updateData: any = { updatedAt: new Date() };
        
        if (name !== undefined) updateData.name = name;
        if (age !== undefined) updateData.age = age;
        if (grade !== undefined) updateData.grade = grade;
        if (educationLevel !== undefined) updateData.educationLevel = educationLevel;
        if (country !== undefined) updateData.country = country;
        if (pronouns !== undefined) updateData.pronouns = pronouns;

        // Update profile in database
        await db
          .update(profiles)
          .set(updateData)
          .where(eq(profiles.userId, userId));

        // Get updated profile
        const updatedProfile = await db
          .select()
          .from(profiles)
          .where(eq(profiles.userId, userId))
          .limit(1);

        res.json({ success: true,
          success: true,
          message: "Profile updated successfully",
          profile: updatedProfile[0]
        });

      } catch (dbError) {
        console.error('Database error:', dbError);
        return res.status(500).json({ 
          success: false, 
          error: "Database connection failed. Please try again later." 
        });
      }

    } catch (error: any) {
      console.error('Profile update error:', error);
      res.status(500).json({ success: false, error: "Failed to update profile" });
    }
  });

  // Admin Dashboard - Get Platform Statistics
  app.get("/api/admin/stats", requireAuth, requireAdmin, async (req, res) => {
    try {
      // Get basic user statistics
      const totalUsers = await db.select({ count: count() }).from(users);
      const totalProfiles = await db.select({ count: count() }).from(profiles);
      
      // Get users by role
      const usersByRole = await db
        .select({
          role: profiles.role,
          count: count()
        })
        .from(profiles)
        .groupBy(profiles.role);

      // Get recent registrations (last 30 days)
      const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
      const recentRegistrations = await db
        .select({ count: count() })
        .from(users)
        .where(gt(users.createdAt, thirtyDaysAgo));

      res.json({ success: true,
        success: true,
        data: {
          totalUsers: totalUsers[0].count,
          totalProfiles: totalProfiles[0].count,
          usersByRole,
          recentRegistrations: recentRegistrations[0].count,
          platformHealth: {
            database: "healthy",
            services: "operational"
          }
        }
      });

    } catch (error: any) {
      console.error('Admin stats error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch admin statistics" });
    }
  });
  app.get("/api/support-tickets/stats", async (req, res) => {
    try {
      const [totalResult, openResult, inProgressResult, resolvedResult] = await Promise.all([
        db.select({ count: count() }).from(shopSupportTickets),
        db.select({ count: count() }).from(shopSupportTickets).where(eq(shopSupportTickets.status, 'open')),
        db.select({ count: count() }).from(shopSupportTickets).where(eq(shopSupportTickets.status, 'in_progress')),
        db.select({ count: count() }).from(shopSupportTickets).where(eq(shopSupportTickets.status, 'resolved')),
      ]);

      res.json({ success: true,
        success: true,
        data: {
          total: totalResult[0]?.count || 0,
          open: openResult[0]?.count || 0,
          inProgress: inProgressResult[0]?.count || 0,
          resolved: resolvedResult[0]?.count || 0,
        }
      });
    } catch (error: any) {
      console.error('Support tickets stats error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch support ticket statistics" });
    }
  });

  // Admin Dashboard - Get Plan Statistics
  app.get('/api/admin/plan-stats', requireAuth, requireAdmin, async (req, res) => {
    try {
      // Count subscriptions from all sources
      const [
        shopMembershipsCount,
        manualAssignmentsCount,
        userSubscriptionsCount
      ] = await Promise.all([
        db.select({ count: count() }).from(shopMemberships),
        db.select({ count: count() }).from(manualPlanAssignments).where(eq(manualPlanAssignments.isActive, true)),
        db.select({ count: count() }).from(userSubscriptions)
      ]);

      const totalSubscriptions = 
        (shopMembershipsCount[0]?.count || 0) +
        (manualAssignmentsCount[0]?.count || 0) +
        (userSubscriptionsCount[0]?.count || 0);

      // Count active subscriptions from all sources
      const [
        activeShopMemberships,
        activeManualAssignments,
        activeUserSubscriptions
      ] = await Promise.all([
        db.select({ count: count() }).from(shopMemberships).where(eq(shopMemberships.status, 'active')),
        db.select({ count: count() }).from(manualPlanAssignments).where(eq(manualPlanAssignments.isActive, true)),
        db.select({ count: count() }).from(userSubscriptions).where(eq(userSubscriptions.subscriptionStatus, 'active'))
      ]);

      const activeSubscriptions =
        (activeShopMemberships[0]?.count || 0) +
        (activeManualAssignments[0]?.count || 0) +
        (activeUserSubscriptions[0]?.count || 0);

      // Calculate total revenue from all successful payments
      const totalRevenueResult = await db
        .select({
          total: sql<string>`COALESCE(SUM(CAST(${payments.amount} AS DECIMAL)), 0)`
        })
        .from(payments)
        .where(eq(payments.status, 'succeeded'));
      
      const totalRevenue = parseFloat(totalRevenueResult[0]?.total || '0');

      // Calculate revenue by user role
      const revenueByRoleResult = await db
        .select({
          role: profiles.role,
          total: sql<string>`COALESCE(SUM(CAST(${payments.amount} AS DECIMAL)), 0)`
        })
        .from(payments)
        .leftJoin(users, eq(payments.userId, users.id))
        .leftJoin(profiles, eq(users.id, profiles.userId))
        .where(eq(payments.status, 'succeeded'))
        .groupBy(profiles.role);

      // Build revenue by role object
      const revenueByRole = {
        student: 0,
        freelancer: 0,
        teacher: 0,
        general: 0
      };

      revenueByRoleResult.forEach((row: any) => {
        const role = row.role || 'general';
        const amount = parseFloat(row.total || '0');
        
        if (role === 'student') {
          revenueByRole.student += amount;
        } else if (role === 'freelancer') {
          revenueByRole.freelancer += amount;
        } else if (role === 'teacher') {
          revenueByRole.teacher += amount;
        } else {
          revenueByRole.general += amount;
        }
      });

      // Get plan statistics from shop memberships
      const shopPlanStats = await db
        .select({
          planName: shopMemberships.plan,
          count: count(),
          activeCount: sql<number>`COUNT(CASE WHEN ${shopMemberships.status} = 'active' THEN 1 END)`
        })
        .from(shopMemberships)
        .groupBy(shopMemberships.plan);

      // Get plan statistics from user subscriptions
      const userPlanStats = await db
        .select({
          planId: userSubscriptions.planId,
          planName: pricingPlans.displayName,
          gradeTier: pricingPlans.gradeTier,
          count: count(),
          activeCount: sql<number>`COUNT(CASE WHEN ${userSubscriptions.subscriptionStatus} = 'active' THEN 1 END)`
        })
        .from(userSubscriptions)
        .leftJoin(pricingPlans, eq(userSubscriptions.planId, pricingPlans.id))
        .groupBy(userSubscriptions.planId, pricingPlans.displayName, pricingPlans.gradeTier);

      // Combine plan stats
      const planStats = [
        ...shopPlanStats.map((stat: any) => ({
          planName: stat.planName,
          count: stat.count,
          activeCount: stat.activeCount
        })),
        ...userPlanStats
      ];

      // Get recent subscriptions from shop memberships
      const recentShopSubscriptions = await db
        .select({
          id: shopMemberships.id,
          userId: shopCustomers.userId,
          userName: profiles.name,
          userEmail: profiles.email,
          userRole: profiles.role,
          planName: shopMemberships.plan,
          status: shopMemberships.status,
          startDate: shopMemberships.createdAt,
          endDate: shopMemberships.renewalDate,
          createdAt: shopMemberships.createdAt
        })
        .from(shopMemberships)
        .leftJoin(shopCustomers, eq(shopMemberships.customerId, shopCustomers.id))
        .leftJoin(users, eq(shopCustomers.userId, users.id))
        .leftJoin(profiles, eq(users.id, profiles.userId))
        .orderBy(desc(shopMemberships.createdAt))
        .limit(10);

      // Get recent subscriptions from user subscriptions
      const recentUserSubscriptions = await db
        .select({
          id: userSubscriptions.id,
          userId: userSubscriptions.userId,
          userName: profiles.name,
          userEmail: profiles.email,
          userRole: profiles.role,
          planName: pricingPlans.displayName,
          gradeTier: pricingPlans.gradeTier,
          status: userSubscriptions.subscriptionStatus,
          startDate: userSubscriptions.startDate,
          endDate: userSubscriptions.endDate,
          createdAt: userSubscriptions.createdAt
        })
        .from(userSubscriptions)
        .leftJoin(users, sql`${userSubscriptions.userId} = ${users.userId}`)
        .leftJoin(profiles, eq(users.id, profiles.userId))
        .leftJoin(pricingPlans, eq(userSubscriptions.planId, pricingPlans.id))
        .orderBy(desc(userSubscriptions.createdAt))
        .limit(10);

      // Combine and sort recent subscriptions
      const recentSubscriptions = [...recentShopSubscriptions, ...recentUserSubscriptions]
        .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())
        .slice(0, 20);

      // Get recent payments with user details
      const recentPayments = await db
        .select({
          id: payments.id,
          userId: payments.userId,
          userName: profiles.name,
          userEmail: profiles.email,
          amount: payments.amount,
          status: payments.status,
          planType: payments.planType,
          createdAt: payments.createdAt
        })
        .from(payments)
        .leftJoin(users, eq(payments.userId, users.id))
        .leftJoin(profiles, eq(users.id, profiles.userId))
        .orderBy(desc(payments.createdAt))
        .limit(20);

      res.json({ success: true,
        success: true,
        stats: {
          totalRevenue,
          revenueByRole,
          totalSubscriptions,
          activeSubscriptions,
          planStats,
          recentSubscriptions,
          recentPayments
        }
      });

    } catch (error: any) {
      console.error('Admin plan stats error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch plan statistics" });
    }
  });

  // Admin Dashboard - Get All Users
  app.get("/api/admin/users", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { page = 1, limit = 50, search = '', role = '' } = req.query;
      const offset = (parseInt(page as string) - 1) * parseInt(limit as string);

      let query = db
        .select({
          id: users.id,
          userId: users.userId,
          email: users.email,
          createdAt: users.createdAt,
          name: profiles.name,
          age: profiles.age,
          grade: profiles.grade,
          country: profiles.country,
          role: profiles.role,
          status: profiles.status,
          avatarUrl: profiles.avatarUrl,
          verificationBadge: profiles.verificationBadge,
          isFeatured: profiles.isFeatured,
          subscriptionTier: profiles.subscriptionTier,
          planExpiry: profiles.planExpiry,
        })
        .from(users)
        .leftJoin(profiles, eq(users.id, profiles.userId));

      // Apply filters
      const conditions = [];
      
      if (search) {
        conditions.push(
          or(
            like(users.email, `%${search}%`),
            like(profiles.name, `%${search}%`),
            like(users.userId, `%${search}%`)
          )
        );
      }

      if (role) {
        conditions.push(eq(profiles.role, role as string));
      }

      if (conditions.length > 0) {
        query = query.where(and(...conditions)) as any;
      }

      const usersData = await query
        .orderBy(desc(users.createdAt))
        .limit(parseInt(limit as string))
        .offset(offset);

      // Get total count for pagination
      let countQuery = db.select({ count: count() }).from(users).leftJoin(profiles, eq(users.id, profiles.userId));
      if (conditions.length > 0) {
        countQuery = countQuery.where(and(...conditions)) as any;
      }
      const totalCount = await countQuery;

      res.json({ success: true,
        success: true,
        data: usersData,
        pagination: {
          page: parseInt(page as string),
          limit: parseInt(limit as string),
          total: totalCount[0].count,
          pages: Math.ceil(totalCount[0].count / parseInt(limit as string))
        }
      });

    } catch (error: any) {
      console.error('Admin users fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch users" });
    }
  });

  // Admin Dashboard - Update User Role
  app.put("/api/admin/users/:userId/role", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { userId } = req.params;
      const { role } = req.body;

      if (!['admin', 'moderator', 'teacher', 'student', 'user', 'freelancer', 'general', 'accountant', 'customer_service'].includes(role)) {
        return res.status(400).json({ success: false, error: "Invalid role" });
      }

      // First get the UUID for the user
      const user = await db
        .select({ id: users.id })
        .from(users)
        .where(eq(users.userId, userId))
        .limit(1);

      if (user.length === 0) {
        return res.status(404).json({ success: false, error: "User not found" });
      }

      const userUuid = user[0].id;

      // Update profile using UUID
      await db
        .update(profiles)
        .set({ role, updatedAt: new Date() })
        .where(eq(profiles.userId, userUuid));

      res.json({ success: true, message: "User role updated successfully" });

    } catch (error: any) {
      console.error('Update user role error:', error);
      res.status(500).json({ success: false, error: "Failed to update user role" });
    }
  });

  // Admin Dashboard - Update User Verification Badge
  app.put("/api/admin/users/:userId/verification", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { userId } = req.params;
      const { verificationBadge } = req.body;

      if (!['none', 'green', 'blue'].includes(verificationBadge)) {
        return res.status(400).json({ success: false, error: "Invalid verification badge" });
      }

      // First get the UUID for the user
      const user = await db
        .select({ id: users.id })
        .from(users)
        .where(eq(users.userId, userId))
        .limit(1);

      if (user.length === 0) {
        return res.status(404).json({ success: false, error: "User not found" });
      }

      const userUuid = user[0].id;

      // Update profile using UUID
      await db
        .update(profiles)
        .set({ verificationBadge, updatedAt: new Date() })
        .where(eq(profiles.userId, userUuid));

      res.json({ success: true, message: "User verification badge updated successfully" });

    } catch (error: any) {
      console.error('Update verification badge error:', error);
      res.status(500).json({ success: false, error: "Failed to update verification badge" });
    }
  });

  // Admin Dashboard - Edit User Profile
  app.put("/api/admin/users/:userId", async (req, res) => {
    try {
      const { userId } = req.params;
      const { name, email, age, grade, country, role, verificationBadge } = req.body;

      // Validate inputs
      if (!name || !email || !age || !grade || !country || !role) {
        return res.status(400).json({ success: false, error: "All fields are required" });
      }

      if (!['admin', 'moderator', 'teacher', 'student', 'user', 'freelancer', 'general', 'accountant', 'customer_service'].includes(role)) {
        return res.status(400).json({ success: false, error: "Invalid role" });
      }

      if (verificationBadge && !['none', 'green', 'blue'].includes(verificationBadge)) {
        return res.status(400).json({ success: false, error: "Invalid verification badge" });
      }

      // First get the UUID for the user
      const user = await db
        .select({ id: users.id })
        .from(users)
        .where(eq(users.userId, userId))
        .limit(1);

      if (user.length === 0) {
        return res.status(404).json({ success: false, error: "User not found" });
      }

      const userUuid = user[0].id;

      // Update profile using UUID
      const profileUpdate: any = { 
        name, 
        age: parseInt(age), 
        grade: parseInt(grade), 
        country, 
        role,
        updatedAt: new Date() 
      };

      if (verificationBadge !== undefined) {
        profileUpdate.verificationBadge = verificationBadge;
      }

      await db
        .update(profiles)
        .set(profileUpdate)
        .where(eq(profiles.userId, userUuid));

      // Update email in users table if changed
      await db
        .update(users)
        .set({ 
          email,
          updatedAt: new Date() 
        })
        .where(eq(users.userId, userId));

      res.json({ success: true, message: "User profile updated successfully" });

    } catch (error: any) {
      console.error('Update user profile error:', error);
      res.status(500).json({ success: false, error: "Failed to update user profile" });
    }
  });

  // Admin Dashboard - Delete User
  app.delete("/api/admin/users/:userId", async (req, res) => {
    try {
      const { userId } = req.params;
      console.log(`Starting delete for userId: ${userId}`);

      // First get the UUID for the user
      console.log('Looking up user UUID...');
      const user = await db
        .select({ id: users.id })
        .from(users)
        .where(eq(users.userId, userId))
        .limit(1);

      if (user.length === 0) {
        return res.status(404).json({ success: false, error: "User not found" });
      }

      const userUuid = user[0].id;

      // Get the profile ID for this user (needed for message deletions)
      const profileRecord = await db
        .select({ id: profiles.id })
        .from(profiles)
        .where(eq(profiles.userId, userUuid))
        .limit(1);
      
      const profileId = profileRecord.length > 0 ? profileRecord[0].id : null;

      // Get the shop customer ID for this user (needed for shop-related deletions)
      const shopCustomerRecord = await db
        .select({ id: shopCustomers.id })
        .from(shopCustomers)
        .where(eq(shopCustomers.userId, userUuid))
        .limit(1);
      
      const shopCustomerId = shopCustomerRecord.length > 0 ? shopCustomerRecord[0].id : null;

      // Delete in correct order to avoid foreign key conflicts
      // Some tables reference users.userId (text), others reference users.id (uuid)
      
      console.log(`Deleting user: userId=${userId}, userUuid=${userUuid}, profileId=${profileId}, shopCustomerId=${shopCustomerId}`);
      
      // Delete related data with error handling for each table
      // All deletions run in parallel for performance
      const deletions = [
        // Core user data
        { name: 'userLoginSessions', fn: () => db.delete(userLoginSessions).where(eq(userLoginSessions.userId, userUuid)) },
        { name: 'userNotificationPreferences', fn: () => db.delete(userNotificationPreferences).where(eq(userNotificationPreferences.userId, userUuid)) },
        { name: 'userPrivacySettings', fn: () => db.delete(userPrivacySettings).where(eq(userPrivacySettings.userId, userUuid)) },
        
        // Educational data
        { name: 'courseEnrollments', fn: () => db.delete(courseEnrollments).where(eq(courseEnrollments.userId, userUuid)) },
        { name: 'notifications', fn: () => db.delete(notifications).where(eq(notifications.userId, userUuid)) },
        { name: 'teacherApplications', fn: () => db.delete(teacherApplications).where(eq(teacherApplications.userId, userUuid)) },
        { name: 'tasks', fn: () => db.delete(tasks).where(eq(tasks.userId, userUuid)) },
        { name: 'studyNotes', fn: () => db.delete(studyNotes).where(eq(studyNotes.userId, userUuid)) },
        { name: 'teacherStudentAssignments (as teacher)', fn: () => db.delete(teacherStudentAssignments).where(eq(teacherStudentAssignments.teacherId, userUuid)) },
        { name: 'teacherStudentAssignments (as student)', fn: () => db.delete(teacherStudentAssignments).where(eq(teacherStudentAssignments.studentId, userUuid)) },
        
        // Social features
        { name: 'friendships (as requester)', fn: () => db.delete(friendships).where(eq(friendships.requesterId, userUuid)) },
        { name: 'friendships (as receiver)', fn: () => db.delete(friendships).where(eq(friendships.receiverId, userUuid)) },
        { name: 'workLikes', fn: () => db.delete(workLikes).where(eq(workLikes.userId, userUuid)) },
        { name: 'workComments', fn: () => db.delete(workComments).where(eq(workComments.userId, userUuid)) },
        { name: 'workViews', fn: () => db.delete(workViews).where(eq(workViews.userId, userUuid)) },
        
        // Shop-related data (must be deleted before shopCustomers)
        ...(shopCustomerId ? [
          { name: 'shopPurchases', fn: () => db.delete(shopPurchases).where(eq(shopPurchases.customerId, shopCustomerId)) },
          { name: 'shopAds', fn: () => db.delete(shopAds).where(eq(shopAds.customerId, shopCustomerId)) },
          { name: 'shopMemberships', fn: () => db.delete(shopMemberships).where(eq(shopMemberships.customerId, shopCustomerId)) },
          { name: 'shopTransactions', fn: () => db.delete(shopTransactions).where(eq(shopTransactions.customerId, shopCustomerId)) },
          { name: 'shopSupportTickets', fn: () => db.delete(shopSupportTickets).where(eq(shopSupportTickets.customerId, shopCustomerId)) },
        ] : []),
        
        // Shop/customer data (delete after shop-related tables)
        { name: 'shopCustomers', fn: () => db.delete(shopCustomers).where(eq(shopCustomers.userId, userUuid)) },
        
        // Advertising
        { name: 'adsBanners', fn: () => db.delete(adsBanners).where(eq(adsBanners.userId, userUuid)) },
        { name: 'heroSections', fn: () => db.delete(heroSections).where(eq(heroSections.userId, userUuid)) },
        
        // Messages (must be deleted before profile)
        ...(profileId ? [
          { name: 'messages (as sender)', fn: () => db.delete(messages).where(eq(messages.senderId, profileId)) },
          { name: 'messages (as receiver)', fn: () => db.delete(messages).where(eq(messages.receiverId, profileId)) },
        ] : []),
        
        // Profile (delete last as it may have dependencies)
        { name: 'profiles', fn: () => db.delete(profiles).where(eq(profiles.userId, userUuid)) },
      ];

      // Run all deletions in parallel for better performance
      const results = await Promise.allSettled(
        deletions.map(deletion => 
          deletion.fn().catch(err => {
            console.log(`Error deleting ${deletion.name}:`, err instanceof Error ? err.message : err);
            throw err;
          })
        )
      );

      // Log results
      results.forEach((result, index) => {
        const deletion = deletions[index];
        if (result.status === 'fulfilled') {
          console.log(`âœ“ Deleted ${deletion.name}`);
        } else {
          console.log(`âœ— Failed to delete ${deletion.name}:`, result.reason);
        }
      });
      
      // Delete user last
      console.log('Deleting user...');
      await db.delete(users).where(eq(users.id, userUuid));
      
      console.log('User deletion completed successfully');

      res.json({ success: true, message: "User deleted successfully" });

    } catch (error: any) {
      console.error('Delete user error:', error);
      res.status(500).json({ success: false, error: "Failed to delete user" });
    }
  });

  // Admin Dashboard - Update User Status (Ban/Unban)
  app.put("/api/admin/users/:userId/status", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { userId } = req.params;
      const { status, reason } = req.body;

      if (!['active', 'banned', 'suspended'].includes(status)) {
        return res.status(400).json({ success: false, error: "Invalid status. Must be active, banned, or suspended" });
      }

      // First get the UUID and email for the user
      const userResult = await db
        .select({ 
          id: users.id, 
          email: users.email 
        })
        .from(users)
        .where(eq(users.userId, userId))
        .limit(1);

      if (userResult.length === 0) {
        return res.status(404).json({ success: false, error: "User not found" });
      }

      const user = userResult[0];

      // Get user profile for name
      const profileResult = await db
        .select({ 
          displayName: profiles.displayName,
          name: profiles.name
        })
        .from(profiles)
        .where(eq(profiles.userId, user.id))
        .limit(1);

      const profile = profileResult[0];
      const userName = profile?.displayName || profile?.name || 'User';

      await db
        .update(profiles)
        .set({ status, updatedAt: new Date() })
        .where(eq(profiles.userId, user.id));

      // Send email notification for ban/suspension
      if (status === 'banned' || status === 'suspended') {
        try {
          const { emailService } = await import('./utils/email.js');
          const fs = await import('fs');
          const path = await import('path');
          
          const statusLabel = status === 'banned' ? 'Banned' : 'Suspended';
          
          // Read suspension email template
          const templatePath = path.join(process.cwd(), 'public', 'email-assets', 'suspension', 'template.html');
          let emailHtml = fs.readFileSync(templatePath, 'utf-8');
          
          // Replace dynamic placeholders - handle split span pattern from email builder
          // Pattern: Hi {{</span><span...>fullName</span><span...>}},
          emailHtml = emailHtml.replace(/Hi \{\{<\/span><span[^>]*>fullName<\/span><span[^>]*>\}\},/gi, `Hi ${userName},`);
          emailHtml = emailHtml.replace(/\{\{<\/span><span[^>]*>fullName<\/span><span[^>]*>\}\}/gi, userName);
          emailHtml = emailHtml.replace(/\{\{fullName\}\}/gi, userName);
          emailHtml = emailHtml.replace(/\{\{FullName\}\}/gi, userName);
          emailHtml = emailHtml.replace(/\{\{ fullName \}\}/gi, userName);
          
          // Replace image paths with CID references for embedded images
          emailHtml = emailHtml.replace(/images\/db561a55b2cf0bc6e877bb934b39b700\.png/g, 'cid:spiral1');
          emailHtml = emailHtml.replace(/images\/f28befc0a869e8a352bf79aa02080dc7\.png/g, 'cid:logo');
          emailHtml = emailHtml.replace(/images\/83faf7f361d9ba8dfdc904427b5b6423\.png/g, 'cid:spiral2');
          emailHtml = emailHtml.replace(/images\/53d788456ae4cc2800001f0737c2d843\.png/g, 'cid:arrow');
          emailHtml = emailHtml.replace(/images\/9f7291948d8486bdd26690d0c32796e0\.png/g, 'cid:logofull');
          
          // Prepare image attachments with CID
          const imagesPath = path.join(process.cwd(), 'public', 'email-assets', 'suspension', 'images');
          const attachments = [
            {
              filename: 'db561a55b2cf0bc6e877bb934b39b700.png',
              path: path.join(imagesPath, 'db561a55b2cf0bc6e877bb934b39b700.png'),
              cid: 'spiral1',
              contentType: 'image/png'
            },
            {
              filename: 'f28befc0a869e8a352bf79aa02080dc7.png',
              path: path.join(imagesPath, 'f28befc0a869e8a352bf79aa02080dc7.png'),
              cid: 'logo',
              contentType: 'image/png'
            },
            {
              filename: '83faf7f361d9ba8dfdc904427b5b6423.png',
              path: path.join(imagesPath, '83faf7f361d9ba8dfdc904427b5b6423.png'),
              cid: 'spiral2',
              contentType: 'image/png'
            },
            {
              filename: '53d788456ae4cc2800001f0737c2d843.png',
              path: path.join(imagesPath, '53d788456ae4cc2800001f0737c2d843.png'),
              cid: 'arrow',
              contentType: 'image/png'
            },
            {
              filename: '9f7291948d8486bdd26690d0c32796e0.png',
              path: path.join(imagesPath, '9f7291948d8486bdd26690d0c32796e0.png'),
              cid: 'logofull',
              contentType: 'image/png'
            }
          ];

          await emailService.sendEmail({
            to: user.email,
            subject: `Important: Your EduFiliova Account Has Been ${statusLabel}`,
            html: emailHtml,
            from: '"EduFiliova Trust & Safety" <support@edufiliova.com>',
            attachments
          });

          console.log(`ðŸ“§ ${statusLabel} notification email sent to ${user.email}`);
        } catch (emailError) {
          console.error('Failed to send status notification email:', emailError);
          // Continue even if email fails - status update was successful
        }
      }
          
        try {
          const emailHtml = `<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<style>body{font-family:Arial,sans-serif;line-height:1.6;color:#333}.container{max-width:600px;margin:0 auto;padding:20px}.header{background-color:#4CAF50;color:white;padding:20px;text-align:center;border-radius:5px}.content{padding:20px;background-color:#f9f9f9;margin-top:20px;border-radius:5px}.footer{text-align:center;padding:20px;color:#999;font-size:12px}.button{display:inline-block;background-color:#4CAF50;color:white;padding:10px 20px;text-decoration:none;border-radius:5px;margin-top:20px}</style>
</head>
<body>
<div class="container">
<div class="header"><h1>Your Account Has Been Activated!</h1></div>
<div class="content">
<p>Hi ${userName},</p>
<p>Great news! Your EduFiliova account has been successfully activated.</p>
<p>You can now access all features, enroll in courses, and connect with peers.</p>
<a href="${process.env.REPLIT_DEV_DOMAIN ? `https://${process.env.REPLIT_DEV_DOMAIN}` : process.env.BASE_URL || 'https://edufiliova.com'}/student-dashboard" class="button">Go to Dashboard</a>
<p>Happy learning!<br>The EduFiliova Team</p>
</div>
<div class="footer"><p>&copy; 2025 EduFiliova. All rights reserved.</p></div>
</div>
</body>
</html>`;
          
          await emailService.sendEmail({
            to: user.email,
            subject: 'Your EduFiliova Account Has Been Activated',
            html: emailHtml,
            from: '"EduFiliova Support" <support@edufiliova.com>'
          });
          console.log(`ðŸ“§ Activation email sent to ${user.email}`);
        } catch (emailError) {
          console.error('Failed to send activation email:', emailError);
        }
      const statusMessage = status === 'active' ? 'User unbanned successfully' : 
                           status === 'banned' ? 'User banned successfully' : 
                           'User suspended successfully';
